<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nash Note</title>
  <link rel="icon" type="image/svg+xml"
    href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%20100%20100%22%3E%0A%20%20%3Crect%20width%3D%22100%22%20height%3D%22100%22%20rx%3D%2220%22%20fill%3D%22black%22%2F%3E%0A%20%20%3Ctext%20x%3D%2250%25%22%20y%3D%2250%25%22%20font-size%3D%2260%22%20font-weight%3D%22bold%22%20text-anchor%3D%22middle%22%20fill%3D%22white%22%20font-family%3D%22Arial%2C%20sans-serif%22%20dominant-baseline%3D%22central%22%3EN.%3C%2Ftext%3E%0A%3C%2Fsvg%3E" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mathup/dist/mathup.css" />
  <style>
    :root {
      --page-bg-color: #f8f9fa;
      --page-text-color: #333;

      --control-bg-color: #f8f9fa;
      --control-text-color: buttontext;
      --control-hover-bg-color: #f0f0f0;
      --control-hover-text-color: #bbb;

      --control-disabled-bg-color: #f8f9fa;
      --control-disabled-text-color: #bbb;

      --note-bg-color: #fff;
      --note-placeholer-color: #bbb;
      --note-link-color: #616161;

      --attribution-color: #bbb;

      --code-bg-color: #e5e4e2;
      --code-text-color: #333;

      --audio-recording-controls-bg-color: #e5e4e2;
      --audio-recording-controls-text-color: #333;

      --table-border-color: #000;

      /* text colors */
      --note-text-color-1: #000000;
      /* black */
      --note-text-color-2: #FF3B30;
      /* red */
      --note-text-color-3: #FF9500;
      /* orange */
      --note-text-color-4: #FFCC00;
      /* yellow */
      --note-text-color-5: #4CD964;
      /* green */
      --note-text-color-6: #5AC8FA;
      /* light-blue */
      --note-text-color-7: #007AFF;
      /* dark-blue */
      --note-text-color-8: #5856D6;
      /* violet */

      /* highlight background colors */
      --note-highlight-color-1: #000000;
      /* red */
      --note-highlight-color-2: #FF3B30;
      /* orange */
      --note-highlight-color-3: #FF9500;
      /* yellow */
      --note-highlight-color-4: #FFCC00;
      /* green */
      --note-highlight-color-5: #4CD964;
      /* light-blue */
      --note-highlight-color-6: #5AC8FA;
      /* violet */
      --note-highlight-color-7: #007AFF;
      /* dark-blue */
      --note-highlight-color-8: #5856D6;
      /* purple */
    }

    /* dark mode */
    @media (prefers-color-scheme: dark) {
      :root {
        --page-bg-color: #3a3a3a;
        --page-text-color: #ddd;

        --control-bg-color: #444;
        --control-text-color: #aaa;
        --control-hover-bg-color: #666;
        --control-hover-text-color: #eee;

        --control-disabled-bg-color: #444;
        --control-disabled-text-color: #666;

        --note-bg-color: #333;
        --note-placeholder-color: #555;

        --code-bg-color: #36454f;
        --code-text-color: #fff;

        --audio-recording-controls-bg-color: #36454f;
        --audio-recording-controls-text-color: #fff;

        --table-border-color: #fff;

        /* text colors */
        --note-text-color-1: #FAFAFA;
        /* black / white */
        --note-text-color-2: #FF3B30;
        /* red */
        --note-text-color-3: #FF9500;
        /* orange */
        --note-text-color-4: #FFCC00;
        /* yellow */
        --note-text-color-5: #4CD964;
        /* green */
        --note-text-color-6: #5AC8FA;
        /* light-blue */
        --note-text-color-7: #007AFF;
        /* dark-blue */
        --note-text-color-8: #5856D6;
        /* violet */

        /* highlight background colors */
        --note-highlight-color-1: #FAFAFA;
        /* red */
        --note-highlight-color-2: #FF3B30;
        /* orange */
        --note-highlight-color-3: #FF9500;
        /* yellow */
        --note-highlight-color-4: #FFCC00;
        /* green */
        --note-highlight-color-5: #4CD964;
        /* light-blue */
        --note-highlight-color-6: #5AC8FA;
        /* violet */
        --note-highlight-color-7: #007AFF;
        /* dark-blue */
        --note-highlight-color-8: #5856D6;
        /* purple */
      }
    }

    body {
      font-family: 'Arial', sans-serif;
      background-color: var(--page-bg-color);
      color: var(--page-text-color);
      margin: 0;
      padding: 40px;
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .editor-container {
      width: 100%;
      max-width: 90%;
      background: var(--note-bg-color);
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0px 5px 15px rgba(0, 0, 0, 0.1);
    }

    .file-title {
      font-size: 28px;
      font-weight: bold;
      margin-bottom: 15px;
      padding: 0px 15px;
      outline: none;
      border: none;
      width: 100%;
      background: transparent;
    }

    .file-title:empty::before {
      content: "Write your title here...";
      color: var(--note-placeholder-color);
      display: block;
    }

    .top-container {
      position: sticky;
      position: -webkit-sticky;
      top: 5px;
      padding: 0 10px;
      z-index: 9998;
    }

    #toolbar {
      gap: 8px;
      background-color: var(--control-bg-color);
      border-radius: 12px;
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      align-items: center;
      overflow: visible;
    }

    #toolbar #splitbar {
      font-size: 24px;
    }

    #toolbar input[type="file"] {
      display: none;
    }

    #toolbar button,
    #toolbar label,
    #toolbar select {
      padding: 8px;
      border: none;
      background: none;
      color: var(--control-text-color);
      font-size: 24px;
      cursor: pointer;
      transition: opacity 0.2s
    }

    #toolbar button:hover,
    #toolbar label:hover,
    #toolbar select:hover {
      background: var(--control-hover-bg-color);
      border-color: var(--control-hover-text-color);
      color: var(--control-hover-text-color);
    }

    #toolbar button:disabled,
    #toolbar label:disabled,
    #toolbar select:disabled {
      background: var(--control-disabled-bg-color);
      border-color: var(--control-disabled-text-color);
      color: var(--control-disabled-text-color);
      cursor: not-allowed;
    }

    /* Dropdown container */
    .dropdown {
      position: relative;
      display: inline-block;
    }

    /* Dropdown button style */
    .dropdown > button {
      padding: 6px 10px;
    }

    /* Dropdown content (hidden by default) */
    .dropdown-content {
      display: none;
      position: absolute;
      top: 110%;
      left: 0;
      background: var(--control-bg-color);
      border: 1px solid var(--control-bg-color);
      color: var(--control-text-color);
      padding: 8px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      z-index: 10;
    }

    /* Show dropdown when .show is added */
    .dropdown-content.show {
      display: block;
    }

    /* Text dropdown container */
    .text-dropdown {
      position: relative;
      display: inline-block;
    }

    /* Text dropdown button style */
    .text-dropdown > button {
      padding: 6px 10px;
    }

    .text-dropdown button {
      width: 100%;
      text-align: left;
    }

    .text-dropdown .fileUpload label {
      max-width: 100%;
      text-align: left;
      display: block;
    }

    /* Text dropdown content (hidden by default) */
    .text-dropdown-content {
      display: none;
      position: absolute;
      width: 200px;
      top: 110%;
      left: 0;
      background: var(--control-bg-color);
      border: 1px solid var(--control-bg-color);
      color: var(--control-text-color);
      padding: 8px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      z-index: 10;
    }

    /* Show text dropdown when .show is added */
    .text-dropdown-content.show {
      display: block;
    }

    /* Page dropdown container (hidden by default) */
    .page-dropdown {
      display: none;
      position: absolute;
      width: 100vw;
      top: 0;
      left: 0;
      background: var(--control-bg-color);
      z-index: 9999;
    }

    /* Show page dropdown when .show is added */
    .page-dropdown.show {
      display: block;
    }

    /* Page dropdown toolbar button */
    .page-dropdown-toolbar-item > button {
      padding: 6px 10px;
    }

    .page-dropdown button {
      width: 100%;
      text-align: left;
    }

    .page-dropdown .fileUpload label {
      max-width: 100%;
      text-align: left;
      display: block;
    }

    .page-dropdown-title {
      width: 100%;
      padding: 1rem;
      text-align: left;
      background: var(--control-bg-color);
      color: var(--control-text-color);
      border: none;
      outline: none;
      font-size: 2rem;
      font-weight: 500;
    }

    .page-dropdown-item {
      border-bottom: 1px solid #ccc;
    }

    /* Page dropdown content (collapsed by default) */
    .page-dropdown-content {
      display: block;
      position: relative;
      width: 100%;
      top: 0;
      left: 0;
      overflow: hidden;
      max-height: 0;
      background: var(--control-bg-color);
      color: var(--control-text-color);
      padding: 0 1rem;
      z-index: 9999;
      transition: max-height 0.3s ease, padding 0.3s ease;
    }

    .page-dropdown-content.open {
      padding: 1rem;
    }

    .page-dropdown-content-open { /* Always open */
      display: block;
      position: relative;
      width: 100%;
      top: 0;
      left: 0;
      overflow: hidden;
      background: var(--control-bg-color);
      color: var(--control-text-color);
      padding: 1rem;
      z-index: 9999;
    }

    .page-dropdown input[type="file"] {
      display: none;
    }

    .page-dropdown button,
    .page-dropdown label {
      padding: 0.8rem;
      border: none;
      background: none;
      color: var(--control-text-color);
      font-size: 1.4rem;
      cursor: pointer;
      transition: opacity 0.2s
    }

    .page-dropdown button:hover,
    .page-dropdown label:hover {
      background: var(--control-hover-bg-color);
      border-color: var(--control-hover-text-color);
      color: var(--control-hover-text-color);
    }

    .page-dropdown button:disabled,
    .page-dropdown label:disabled {
      background: var(--control-disabled-bg-color);
      border-color: var(--control-disabled-text-color);
      color: var(--control-disabled-text-color);
      cursor: not-allowed;
    }

    .page-dropdown-header {
      padding: 1rem !important;
      font-size: 1.6rem !important;
    }

    .page-dropdown-close {
      padding: 1rem !important;
      font-size: 1.6rem !important;
    }

    /* Grid of swatches */
    .swatch-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, 24px);
      gap: 6px;
    }

    .color-swatch {
      width: 24px;
      height: 24px;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .color-swatch:hover {
      transform: scale(1.1);
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);
    }

    #fontScaleDropdown {
      width: 100px;
    }

    #alignDropdown {
      width: 100px;
    }

    #linksDropdown {
      width: 180px;
    }

    #embedDropdown {
      width: 130px;
    }

    #saveDropdown {
      width: 270px;
      right: 0;
      left: auto;
    }

    #editor {
      border-radius: 12px;
      padding: 15px;
      min-height: 250px;
      outline: none;
      font-size: 16px;
      line-height: 1.6;
      /* background: #f4f4f4; */
    }

    #editor p {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
    }

    #editor a {
      color: var(--note-link-color);
      text-decoration: none;
      font-weight: 800;
      transition: all 0.2s ease-in-out;
      border-bottom: 2px solid transparent;
    }

    #editor a:hover {
      border-bottom: 2px solid var(--note-link-color);
      color: var(--note-link-color);
    }

    #editor pre code {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
      background: var(--code-bg-color);
      color: var(--code-text-color);
      display: block;
      margin: 0;
      padding: 8px;
      border-radius: 6px;
      white-space: pre-line;
    }

    #footer {
      text-align: center;
      margin-top: 20px;
      color: var(--attribution-color);
    }

    #footer a {
      text-decoration: none;
      color: var(--attribution-color);
    }

    .non-selectable {
      user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      -webkit-touch-callout: none;
      -o-user-select: none;
      -moz-user-select: none;
    }

    img {
      max-width: 100%;
      height: auto;
      display: block;
      border-radius: 12px;
    }

    audio {
      width: 100%;
      display: block;
    }

    video {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 12px;
    }

    .image-link {
      margin: 10px 0;
    }

    .video-link {
      margin: 10px 0;
    }

    .audio-link {
      margin: 10px 0;
    }

    .embedded-local-image {
      margin: 10px 0;
    }

    .embedded-local-audio {
      margin: 10px 0;
    }

    .embedded-content {
      margin: 10px 0;
    }

    .embedded-math {
      margin: 10px 0;
    }

    .embedded-math mrow,
    .embedded-math math {
      font-size: 28px;
    }

    .embedded-local-epub {
      margin: 20px 0;
    }

    .embedded-local-pdf {
      margin: 20px 0;
    }

    .pdf-link {
      margin: 20px 0;
    }

    .embedded-table {
      margin: 10px 0;
    }

    .embedded-table table {
      width: 100%;
      height: auto;
      padding: 0 0;
      margin: 0 0;
      text-align: left;
      table-layout:fixed;
      border: 1px solid var(--table-border-color);
      border-collapse: collapse;
      border-spacing: 0;
    }

    .embedded-table table th,
    .embedded-table table td {
      overflow: hidden;
      border: 1px solid var(--table-border-color);
      margin: 0 0;
      padding: 0 8px;
    }

    .epub-loading::before {
      content: "ePUB document is loading...";
      display: block;
      color: var(--note-placeholer-color);
      margin: 0;
    }

    .pdf-loading::before {
      content: "PDF document is loading...";
      display: block;
      color: var(--note-placeholer-color);
      margin: 0;
    }

    .thin-line::before {
      content: "";
      display: block;
      width: 100%;
      height: 1px;
      background-color: var(--control-bg-color);
      color: var(--control-text-color);
      margin: 10px 0;
    }

    .embedded-local-epub,
    .embedded-local-pdf,
    .embedded-local-image,
    .embedded-local-audio,
    .embedded-content,
    .embedded-math,
    .embedded-table,
    .image-link,
    .audio-link,
    .video-link,
    .pdf-link,
    .audio-recording {
      width: 100%;
      height: auto;
      display: block;
      position: relative;
    }

    .x-remover {
      background-color: #aaa;
      padding: 6.5px 6.7px 3.8px 6.5px;
      color: #ff3b30;
      display: none;
      position: absolute;
      top: 0;
      right: 0;
      margin-top: -10px;
      margin-right: -10px;
      font-weight: 700;
      border-radius: 50%;
      border: 1px solid #333;
      text-align: center;
      line-height: 20px;
      font-family: sans-serif;
      cursor: pointer;
    }

    .embedded-local-epub:hover .x-remover,
    .embedded-local-pdf:hover .x-remover,
    .embedded-local-image:hover .x-remover,
    .embedded-local-audio:hover .x-remover,
    .embedded-content:hover .x-remover,
    .embedded-math:hover .x-remover,
    .embedded-table:hover .x-remover,
    .image-link:hover .x-remover,
    .audio-link:hover .x-remover,
    .video-link:hover .x-remover,
    .pdf-link:hover .x-remover,
    .audio-recording:hover .x-remover {
      display: block;
    }

    /* Audio Recording UI */

    #recordingBar {
      content: "";
      display: block;
      height: 4px;
      border-radius: 2px;
      background-color: red;
      color: red;
      margin: 10px 0;
      /*transitions with Firefox, IE and Opera Support browser support*/
      animation-name: flashing-recording-dot;
      -webkit-animation-name: flashing-recording-dot;
      -moz-animation-name: flashing-recording-dot;
      -o-animation-name: flashing-recording-dot;
      animation-duration: 2s;
      -webkit-animation-duration: 2s;
      -moz-animation-duration: 2s;
      -o-animation-duration: 2s;
      animation-iteration-count: infinite;
      -webkit-animation-iteration-count: infinite;
      -moz-animation-iteration-count: infinite;
      -o-animation-iteration-count: infinite;
    }

    #recordingBar.hidden {
      display: none;
    }

    .audio-recording {
      margin: 20px 0;
    }

    .recording-control-buttons-container {
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      justify-content: space-evenly;
      /*horizontal centering*/
      align-items: center;
      width: 100%;
      height: auto;
      margin: 0;
      border-radius: 12px;
      background-color: var(--audio-recording-controls-bg-color);
      color: var(--audio-recording-controls-text-color);
    }

    .recording-cancelled-container {
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      align-items: start;
      width: 100%;
      height: auto;
      margin: 0;
      padding: 10px 0px;
      border-radius: 12px;
      background-color: var(--audio-recording-controls-bg-color);
      color: var(--audio-recording-controls-text-color);
    }

    .cancel-recording-button,
    .stop-recording-button {
      font-size: 32px;
      cursor: pointer;
      background-color: transparent;
      border-color: transparent;
    }

    .cancel-recording-button {
      color: red;
      opacity: 0.7;
    }

    .cancel-recording-button:hover {
      color: rgb(206, 4, 4);
    }

    .stop-recording-button {
      color: #33cc33;
      opacity: 0.7;
    }

    .stop-recording-button:hover {
      color: #27a527;
    }

    .recording-elapsed-time {
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      justify-content: center;
      /*horizontal centering*/
      align-items: center;
    }

    .red-recording-dot {
      font-size: 24px;
      color: red;
      margin-right: 12px;
      /*transitions with Firefox, IE and Opera Support browser support*/
      animation-name: flashing-recording-dot;
      -webkit-animation-name: flashing-recording-dot;
      -moz-animation-name: flashing-recording-dot;
      -o-animation-name: flashing-recording-dot;
      animation-duration: 2s;
      -webkit-animation-duration: 2s;
      -moz-animation-duration: 2s;
      -o-animation-duration: 2s;
      animation-iteration-count: infinite;
      -webkit-animation-iteration-count: infinite;
      -moz-animation-iteration-count: infinite;
      -o-animation-iteration-count: infinite;
    }

    /* The animation code */
    @keyframes flashing-recording-dot {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0;
      }
      100% {
        opacity: 1;
      }
    }

    @-webkit-keyframes flashing-recording-dot {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0;
      }
      100% {
        opacity: 1;
      }
    }

    @-moz-keyframes flashing-recording-dot {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0;
      }
      100% {
        opacity: 1;
      }
    }

    @-o-keyframes flashing-recording-dot {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0;
      }
      100% {
        opacity: 1;
      }
    }
    /* END OF Audio Recording UI */

    small {
      display: block;
    }

    .xlarge-text {
      font-size: 32px;
    }

    .large-text {
      font-size: 24px;
    }

    .medium-text {
      font-size: 16px;
    }

    .small-text {
      font-size: 12px;
    }

    .left-text {
      text-align: left;
    }

    .center-text {
      text-align: center;
    }

    .right-text {
      text-align: right;
    }

    .justify-text {
      text-align: justify;
    }

    .left-align {
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      flex-direction: row;
      justify-content: flex-start;
    }

    .center-align {
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      flex-direction: row;
      justify-content: center;
    }

    .right-align {
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      flex-direction: row;
      justify-content: flex-end;
    }

    .mobile-only {
      display: none;
    }

    @media (max-width: 800px) {
      .mobile-only {
        display: block !important;
      }

      .no-mobile {
        display: none !important;
      }

      #toolbar {
        overflow: hidden;
      }

      .swatch-grid {
        gap: 32px;
      }
    }

    @media print {
      .no-print {
        display: none !important;
      }

      .editor-container {
        width: 100%;
        max-width: 100%;
        box-shadow: none;
      }

      .embedded-local-audio,
      .audio-link,
      .audio-recording {
        display: none !important;
      }
    }
  </style>
</head>

<body>

  <div class="editor-container">
    <div id="filename" contenteditable="plaintext-only" class="file-title"></div>

    <div class="top-container">
      <div id="toolbar" class="no-print">
        <button id="btnH1" class="no-mobile" title="Extra large text">XL</button>
        <button id="btnH2" class="no-mobile" title="Large text">L</button>
        <button id="btnM" class="no-mobile" title="Medium text">M</button>
        <button id="btnS" class="no-mobile" title="Small text">S</button>

        <button id="btnB" title="Select a text to make bold" disabled><b>B</b></button>
        <button id="btnI" title="Select a text to make italic" disabled><i>I</i></button>
        <button id="btnU" title="Select a text to underline" disabled><u>U</u></button>
        <button id="btnStrikethrough" title="Select a text to strikethrough" disabled>Ꞩ</button>

        <div class="dropdown no-mobile">
          <button id="btnTextColorMenu" title="Select a text to colorize" disabled>Color</button>
          <div id="textColorDropdown" class="dropdown-content">
            <div class="swatch-grid">
              <button id="btnTextColor1" class="color-swatch" style="background: var(--note-text-color-1);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor2" class="color-swatch" style="background: var(--note-text-color-2);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor3" class="color-swatch" style="background: var(--note-text-color-3);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor4" class="color-swatch" style="background: var(--note-text-color-4);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor5" class="color-swatch" style="background: var(--note-text-color-5);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor6" class="color-swatch" style="background: var(--note-text-color-6);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor7" class="color-swatch" style="background: var(--note-text-color-7);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor8" class="color-swatch" style="background: var(--note-text-color-8);"
                onmousedown="event.preventDefault();"></button>
            </div>
          </div>
        </div>

        <!-- Highlight Color Dropdown -->
        <div class="dropdown no-mobile">
          <button id="btnTextHighlightMenu" title="Select a text to highlight" disabled>Highlight</button>
          <div id="highlightDropdown" class="dropdown-content">
            <div class="swatch-grid">
              <button id="btnTextHighlight1" class="color-swatch" style="background: var(--note-highlight-color-1);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight2" class="color-swatch" style="background: var(--note-highlight-color-2);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight3" class="color-swatch" style="background: var(--note-highlight-color-3);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight4" class="color-swatch" style="background: var(--note-highlight-color-4);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight5" class="color-swatch" style="background: var(--note-highlight-color-5);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight6" class="color-swatch" style="background: var(--note-highlight-color-6);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight7" class="color-swatch" style="background: var(--note-highlight-color-7);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight8" class="color-swatch" style="background: var(--note-highlight-color-8);"
                onmousedown="event.preventDefault();"></button>
            </div>
          </div>
        </div>

        <!-- Font Size Dropdown -->
        <div class="text-dropdown no-mobile">
          <button id="btnFontScaleMenu" title="Select a text to change scale" disabled><b>T</b></button>
          <div id="fontScaleDropdown" class="text-dropdown-content">
            <div class="text">
              <button id="btnFontScale1" title="25%">25%</button>
              <button id="btnFontScale2" title="33.33%">33.33%</button>
              <button id="btnFontScale3" title="50%">50%</button>
              <button id="btnFontScale4" title="66.66%">66.66%</button>
              <button id="btnFontScale5" title="75%">75%</button>
              <button id="btnFontScale6" title="125%">125%</button>
              <button id="btnFontScale7" title="150%">150%</button>
              <button id="btnFontScale8" title="175%">175%</button>
              <button id="btnFontScale9" title="200%">200%</button>
              <button id="btnFontScale10" title="250%">250%</button>
              <button id="btnFontScale11" title="300%">300%</button>
              <button id="btnFontScale12" title="350%">350%</button>
            </div>
          </div>
        </div>

        <div class="text-dropdown no-mobile">
          <button id="btnAlign" title="Alignment">Align</button>
          <div id="alignDropdown" class="text-dropdown-content">
            <button id="btnLeftTextAlign" title="Align to the left">Left</button>
            <button id="btnCenterTextAlign" title="Align to the center">Center</button>
            <button id="btnRightTextAlign" title="Align to the right">Right</button>
            <button id="btnJustifyTextAlign" title="Justify text">Justify</button>
          </div>
        </div>

        <div class="page-dropdown-toolbar-item mobile-only">
          <button id="mbtnStyle" title="Styling">Style</button>
        </div>

        <div id="splitbar">|</div>
        <button id="btnText" title="Add text">📝</button>
        <button id="btnCode" title="Add source code text">🖥</button>

        <div class="text-dropdown no-mobile">
          <button id="btnLinks" title="Insert links">🔗</button>
          <div id="linksDropdown" class="text-dropdown-content">
            <button id="btnLinkText" title="Select a text to make link" disabled>🌎 Text Link</button>
            <button id="btnLinkImage" title="Insert image link">📷 Image Link</button>
            <button id="btnLinkAudio" title="Insert audio link">🔈 Audio Link</button>
            <button id="btnLinkVideo" title="Insert video link">🎞 Video Link</button>
            <button id="btnLinkPdf" title="Insert PDF file link">📕 PDF Link</button>
          </div>
        </div>

        <div class="text-dropdown no-mobile">
          <button id="btnEmbed" title="Embed contents">📎</button>
          <div id="embedDropdown" class="text-dropdown-content">
            <button id="btnEmbedWeb" title="Embed web page or HTML object">🌎 Web</button>

            <div class="fileUpload">
              <label for="imageUpload" title="Embed image file">📷 Image</label>
              <input type="file" id="imageUpload" accept="image/*" onclick="this.value = null">
            </div>

            <div class="fileUpload">
              <label for="audioUpload" title="Embed audio file">🔈 Audio</label>
              <input type="file" id="audioUpload" accept="audio/*" onclick="this.value = null">
            </div>

            <div class="fileUpload">
              <label for="pdfUpload" title="Embed PDF file">📕 PDF</label>
              <input type="file" id="pdfUpload" accept=".pdf" onclick="this.value = null">
            </div>

            <div class="fileUpload">
              <label for="epubUpload" title="Embed ePub file">📖 ePub</label>
              <input type="file" id="epubUpload" accept=".epub" onclick="this.value = null">
            </div>
          </div>
        </div>

        <button id="btnRecordAudio" title="Record audio">🎤</button>
        <button id="btnEmbedMath" class="no-mobile" title="Insert math expression">Σ</button>

        <div class="text-dropdown no-mobile">
          <button id="btnTable" title="Add table">Table</button>
          <div id="tableDropdown" class="text-dropdown-content">
            <button id="btnSimpleTable" title="Add simple table">Simple Table</button>
            <button id="btnHeadlessTable" title="Add headless table">Headless Table</button>
          </div>
        </div>

        <div class="page-dropdown-toolbar-item mobile-only">
          <button id="mbtnInsert" title="Insert objects">Insert</button>
        </div>

        <div id="splitbar">|</div>
        <button id="btnUndo" disabled title="Undo">↩</button>
        <button id="btnRedo" disabled title="Redo">↪</button>

        <div id="splitbar" style="margin-left: auto;">|</div>

        <div class="text-dropdown no-mobile">
          <button id="btnSaveMenu" title="Save or share">💾</button>
          <div id="saveDropdown" class="text-dropdown-content">
            <button id="btnSave">Save</button>
            <button id="btnSaveTo">Save To...</button>
            <button id="btnShare">Share</button>
            <button id="btnSaveReadOnly">Save as Read-Only</button>
            <button id="btnSaveToReadOnly">Save To as Read-Only</button>
            <button id="btnShareReadOnly">Share as Read-Only</button>
          </div>
        </div>

        <div class="page-dropdown-toolbar-item mobile-only">
          <button id="mbtnSaveMenu" title="Save or share">💾</button>
        </div>
      </div>
      <div id="recordingBar" class="hidden" aria-hidden="true"></div>
    </div>

    <div id="editorContainer" class="thin-line">
      <div id="editor" contenteditable="true">
        <p id="text28096aea6fa9cc5d10934d24509e2c83" class="text-block"><br/></p>
      </div>
    </div>

    <div id="footer">
      <small><a href="https://github.com/flaviup">flaviup@github.com</a></small>
      <br/>
      <small>Nash 1.0.20250507</small>
    </div>

    <div id="styleDropdown" class="page-dropdown">
      <div class="page-dropdown-title">Style</div>
      <div class="page-dropdown-item">
        <button id="mbtnFontSizeMenu" class="page-dropdown-header" title="Change text size">Font Sizing</button>
        <div class="page-dropdown-content">
          <button id="mbtnH1" title="Extra large text">Extra Large</button>
          <button id="mbtnH2" title="Large text">Large</button>
          <button id="mbtnM" title="Medium text">Medium</button>
          <button id="mbtnS" title="Small text">Small</button>
        </div>
      </div>
      <div class="page-dropdown-item">
        <button id="mbtnFontScaleMenu" class="page-dropdown-header" title="Select a text to change scale" disabled>Font Scaling</button>
        <div class="page-dropdown-content">
          <button id="mbtnFontScale1" title="25%">25%</button>
          <button id="mbtnFontScale2" title="33.33%">33.33%</button>
          <button id="mbtnFontScale3" title="50%">50%</button>
          <button id="mbtnFontScale4" title="66.66%">66.66%</button>
          <button id="mbtnFontScale5" title="75%">75%</button>
          <button id="mbtnFontScale6" title="125%">125%</button>
          <button id="mbtnFontScale7" title="150%">150%</button>
          <button id="mbtnFontScale8" title="175%">175%</button>
          <button id="mbtnFontScale9" title="200%">200%</button>
          <button id="mbtnFontScale10" title="250%">250%</button>
          <button id="mbtnFontScale11" title="300%">300%</button>
          <button id="mbtnFontScale12" title="350%">350%</button>
        </div>
      </div>
      <div class="page-dropdown-item">
        <button id="mbtnTextColorMenu" class="page-dropdown-header" title="Select a text to colorize" disabled>Text Color</button>
        <div class="page-dropdown-content">
          <div class="swatch-grid">
            <button id="mbtnTextColor1" class="color-swatch" style="background: var(--note-text-color-1);"
              onmousedown="event.preventDefault();"></button>
            <button id="mbtnTextColor2" class="color-swatch" style="background: var(--note-text-color-2);"
              onmousedown="event.preventDefault();"></button>
            <button id="mbtnTextColor3" class="color-swatch" style="background: var(--note-text-color-3);"
              onmousedown="event.preventDefault();"></button>
            <button id="mbtnTextColor4" class="color-swatch" style="background: var(--note-text-color-4);"
              onmousedown="event.preventDefault();"></button>
            <button id="mbtnTextColor5" class="color-swatch" style="background: var(--note-text-color-5);"
              onmousedown="event.preventDefault();"></button>
            <button id="mbtnTextColor6" class="color-swatch" style="background: var(--note-text-color-6);"
              onmousedown="event.preventDefault();"></button>
            <button id="mbtnTextColor7" class="color-swatch" style="background: var(--note-text-color-7);"
              onmousedown="event.preventDefault();"></button>
            <button id="mbtnTextColor8" class="color-swatch" style="background: var(--note-text-color-8);"
              onmousedown="event.preventDefault();"></button>
          </div>
        </div>
      </div>
      <div class="page-dropdown-item">
        <button id="mbtnTextHighlightMenu" class="page-dropdown-header" title="Select a text to highlight" disabled>Highlight Color</button>
        <div class="page-dropdown-content">
          <div class="swatch-grid">
            <button id="mbtnTextHighlight1" class="color-swatch" style="background: var(--note-highlight-color-1);"
              onmousedown="event.preventDefault();"></button>
            <button id="mbtnTextHighlight2" class="color-swatch" style="background: var(--note-highlight-color-2);"
              onmousedown="event.preventDefault();"></button>
            <button id="mbtnTextHighlight3" class="color-swatch" style="background: var(--note-highlight-color-3);"
              onmousedown="event.preventDefault();"></button>
            <button id="mbtnTextHighlight4" class="color-swatch" style="background: var(--note-highlight-color-4);"
              onmousedown="event.preventDefault();"></button>
            <button id="mbtnTextHighlight5" class="color-swatch" style="background: var(--note-highlight-color-5);"
              onmousedown="event.preventDefault();"></button>
            <button id="mbtnTextHighlight6" class="color-swatch" style="background: var(--note-highlight-color-6);"
              onmousedown="event.preventDefault();"></button>
            <button id="mbtnTextHighlight7" class="color-swatch" style="background: var(--note-highlight-color-7);"
              onmousedown="event.preventDefault();"></button>
            <button id="mbtnTextHighlight8" class="color-swatch" style="background: var(--note-highlight-color-8);"
              onmousedown="event.preventDefault();"></button>
          </div>
        </div>
      </div>
      <div class="page-dropdown-item">
        <button id="mbtnAlign" class="page-dropdown-header" title="Alignment">Align</button>
        <div class="page-dropdown-content">
          <button id="mbtnLeftTextAlign" title="Align to the left">Left</button>
          <button id="mbtnCenterTextAlign" title="Align to the center">Center</button>
          <button id="mbtnRightTextAlign" title="Align to the right">Right</button>
          <button id="mbtnJustifyTextAlign" title="Justify text">Justify</button>
        </div>
      </div>
      <button id="mbtnCancelStyle" class="page-dropdown-close" title="Close the menu">❌</button>
    </div>

    <div id="insertDropdown" class="page-dropdown">
      <div class="page-dropdown-title">Insert</div>
      <div class="page-dropdown-item">
        <button id="mbtnLinks" class="page-dropdown-header" title="Insert links">Link</button>
        <div class="page-dropdown-content">
          <button id="mbtnLinkText" title="Select a text to make link" disabled>🌎 Text Link</button>
          <button id="mbtnLinkImage" title="Insert image link">📷 Image Link</button>
          <button id="mbtnLinkAudio" title="Insert audio link">🔈 Audio Link</button>
          <button id="mbtnLinkVideo" title="Insert video link">🎞 Video Link</button>
          <button id="mbtnLinkPdf" title="Insert PDF file link">📕 PDF Link</button>
        </div>
      </div>
      <div class="page-dropdown-item">
        <button id="mbtnEmbed" class="page-dropdown-header" title="Embed contents">Embed</button>
        <div class="page-dropdown-content">
          <button id="mbtnEmbedWeb" title="Embed web page or HTML object">🌎 Web</button>

          <div class="fileUpload">
            <label for="mimageUpload" title="Embed image file">📷 Image</label>
            <input type="file" id="mimageUpload" accept="image/*" onclick="this.value = null">
          </div>

          <div class="fileUpload">
            <label for="maudioUpload" title="Embed audio file">🔈 Audio</label>
            <input type="file" id="maudioUpload" accept="audio/*" onclick="this.value = null">
          </div>

          <div class="fileUpload">
            <label for="mpdfUpload" title="Embed PDF file">📕 PDF</label>
            <input type="file" id="mpdfUpload" accept=".pdf" onclick="this.value = null">
          </div>

          <div class="fileUpload">
            <label for="mepubUpload" title="Embed ePub file">📖 ePub</label>
            <input type="file" id="mepubUpload" accept=".epub" onclick="this.value = null">
          </div>

          <button id="mbtnEmbedMath" title="Insert math expression">Σ Math</button>
        </div>
      </div>
      <div class="page-dropdown-item">
        <button id="mbtnTable" class="page-dropdown-header" title="Add table">Table</button>
        <div class="page-dropdown-content">
          <button id="mbtnSimpleTable" title="Add simple table">Simple Table</button>
          <button id="mbtnHeadlessTable" title="Add headless table">Headless Table</button>
        </div>
      </div>
      <button id="mbtnCancelInsert" class="page-dropdown-close" title="Close the menu">❌</button>
    </div>

    <div id="msaveDropdown" class="page-dropdown">
      <div class="page-dropdown-title">Save & Share</div>
      <div class="page-dropdown-item">
        <div class="page-dropdown-content-open">
          <button id="mbtnSave">Save</button>
          <button id="mbtnSaveTo">Save To...</button>
          <button id="mbtnShare">Share</button>
          <button id="mbtnSaveReadOnly">Save as Read-Only</button>
          <button id="mbtnSaveToReadOnly">Save To as Read-Only</button>
          <button id="mbtnShareReadOnly">Share as Read-Only</button>
        </div>
      </div>
      <button id="mbtnCancelSave" class="page-dropdown-close" title="Close the menu">❌</button>
    </div>

  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script -->
  <script src="https://github.com/futurepress/epub.js/releases/download/v0.3.88/epub.min.js"></script> <!-- check newer versions like 0.3.93 -->
  <script src="https://cdn.jsdelivr.net/npm/mathup/dist/browser/mathup.iife.min.js"></script>

  <script type="module">
    /**
     *  PDFObject v2.3.1
     *  https://github.com/pipwerks/PDFObject
     *  @license
     *  Copyright (c) 2008-2025 Philip Hutchison
     *  MIT-style license: http://pipwerks.mit-license.org/
     *  UMD module pattern from https://github.com/umdjs/umd/blob/master/templates/returnExports.js
     */

    (function (root, factory) {
        if (typeof define === "function" && define.amd) {
            // AMD. Register as an anonymous module.
            define([], factory);
        } else if (typeof module === "object" && module.exports) {
            // Node. Does not work with strict CommonJS, but
            // only CommonJS-like environments that support module.exports,
            // like Node.
            module.exports = factory();
        } else {
            // Browser globals (root is window)
            root.PDFObject = factory();
        }
    }(globalThis, function () {

        "use strict";

        //PDFObject is designed for client-side (browsers), not server-side (node)
        //Will choke on undefined navigator and window vars when run on server
        //Return boolean false and exit function when running server-side

        if(typeof window === "undefined" || window.navigator === undefined || window.navigator.userAgent === undefined){ return false; }

        let pdfobjectversion = "2.3.1";
        let win = window;
        let nav = win.navigator;
        let ua = nav.userAgent;
        let suppressConsole = false;

        //Fallback validation when navigator.pdfViewerEnabled is not supported
        let isModernBrowser = function (){

            /*
              userAgent sniffing is not the ideal path, but most browsers revoked the ability to check navigator.mimeTypes
              for security purposes. As of 2023, browsers have begun implementing navigator.pdfViewerEnabled, but older versions
              do not have navigator.pdfViewerEnabled or the ability to check navigator.mimeTypes. We're left with basic browser
              sniffing and assumptions of PDF support based on browser vendor.
            */

            //Chromium has provided native PDF support since 2011.
            //Most modern browsers use Chromium under the hood: Google Chrome, Microsoft Edge, Opera, Brave, Vivaldi, Arc, and more.
            //Chromium uses the PDFium rendering engine, which is based on Foxit's PDF rendering engine.
            //Note that MS Edge opts to use a different PDF rendering engine. As of 2024, Edge uses a version of Adobe's Reader
            let isChromium = (win.chrome !== undefined);

            //Safari on macOS has provided native PDF support since 2009.
            //This code snippet also detects the DuckDuckGo browser, which uses Safari/Webkit under the hood.
            let isSafari = (win.safari !== undefined || (nav.vendor !== undefined && /Apple/.test(nav.vendor) && /Safari/.test(ua)));

            //Firefox has provided PDF support via PDFJS since 2013.
            let isFirefox = (win.Mozilla !== undefined || /irefox/.test(ua));

            return isChromium || isSafari || isFirefox;

        };

        /*
          Special handling for Internet Explorer 11.
          Check for ActiveX support, then whether "AcroPDF.PDF" or "PDF.PdfCtrl" are valid.
          IE11 uses ActiveX for Adobe Reader and other PDF plugins, but window.ActiveXObject will evaluate to false.
          ("ActiveXObject" in window) evaluates to true.
          MS Edge does not support ActiveX so this test will evaluate false for MS Edge.
        */
        let validateAX = function (type){
            var ax = null;
            try {
                ax = new ActiveXObject(type);
            } catch (e) {
                //ensure ax remains null when ActiveXObject attempt fails
                ax = null;
            }
            return !!ax; //convert resulting object to boolean
        };

        let hasActiveXPDFPlugin = function (){ return ("ActiveXObject" in win) && (validateAX("AcroPDF.PDF") || validateAX("PDF.PdfCtrl")) };

        let checkSupport = function (){

            //Safari on iPadOS doesn't report as 'mobile' when requesting desktop site, yet still fails to embed PDFs
            let isSafariIOSDesktopMode = (nav.platform !== undefined && nav.platform === "MacIntel" && nav.maxTouchPoints !== undefined && nav.maxTouchPoints > 1);

            let isMobileDevice = (isSafariIOSDesktopMode || /Mobi|Tablet|Android|iPad|iPhone/.test(ua));

            //As of June 2023, no mobile browsers properly support inline PDFs. If mobile, just say no.
            if(isMobileDevice){ return false; }

            //Modern browsers began supporting navigator.pdfViewerEnabled in late 2022 and early 2023.
            let supportsPDFVE = (typeof nav.pdfViewerEnabled === "boolean");

            //If browser supports nav.pdfViewerEnabled and is explicitly saying PDFs are NOT supported (e.g. PDFJS disabled by user in Firefox), respect it.
            if(supportsPDFVE && !nav.pdfViewerEnabled){ return false; }

            return (supportsPDFVE && nav.pdfViewerEnabled) || isModernBrowser() || hasActiveXPDFPlugin();

        };

        //Determines whether PDF support is available
        let supportsPDFs = checkSupport();

        //Create a fragment identifier for using PDF Open parameters when embedding PDF
        let buildURLFragmentString = function(pdfParams){

            let string = "";
            let prop;
            let paramArray = [];
            let fdf = "";

            //The comment, viewrect, and highlight parameters require page to be set first.

            //Check to ensure page is used if comment, viewrect, or highlight are specified
            if(pdfParams.comment || pdfParams.viewrect || pdfParams.highlight){

                if(!pdfParams.page){

                    //If page is not set, use the first page
                    pdfParams.page = 1;

                    //Inform user that page needs to be set properly
                    embedError("The comment, viewrect, and highlight parameters require a page parameter, but none was specified. Defaulting to page 1.");

                }

            }

            //Let's go ahead and ensure page is always the first parameter.
            if(pdfParams.page){
                paramArray.push("page=" + encodeURIComponent(pdfParams.page));
                delete pdfParams.page;
            }

            //FDF needs to be the last parameter in the string
            if(pdfParams.fdf){
                fdf = pdfParams.fdf;
                delete pdfParams.fdf;
            }

            //Add all other parameters, as needed
            if(pdfParams){

                for (prop in pdfParams) {
                    if (pdfParams.hasOwnProperty(prop)) {
                        paramArray.push(encodeURIComponent(prop) + "=" + encodeURIComponent(pdfParams[prop]));
                    }
                }

                //Add fdf as the last parameter, if needed
                if(fdf){
                    paramArray.push("fdf=" + encodeURIComponent(fdf));
                }

                //Join all parameters in the array into a string
                string = paramArray.join("&");

                //The string will be empty if no PDF Parameters were provided
                //Only prepend the hash if the string is not empty
                if(string){
                    string = "#" + string;
                }

            }

            return string;

        };

        let embedError = function (msg){
            if(!suppressConsole){
                console.log("[PDFObject]", msg);
            }
            return false;
        };

        let emptyNodeContents = function (node){
            while(node.firstChild){
                node.removeChild(node.firstChild);
            }
        };

        let getTargetElement = function (targetSelector){

            //Default to body for full-browser PDF
            let targetNode = document.body;

            //If a targetSelector is specified, check to see whether
            //it's passing a selector, jQuery object, or an HTML element

            if(typeof targetSelector === "string"){

                //Is CSS selector
                targetNode = document.querySelector(targetSelector);

            } else if (win.jQuery !== undefined && targetSelector instanceof jQuery && targetSelector.length) {

                //Is jQuery element. Extract HTML node
                targetNode = targetSelector.get(0);

            } else if (targetSelector.nodeType !== undefined && targetSelector.nodeType === 1){

                //Is HTML element
                targetNode = targetSelector;

            }

            return targetNode;

        };

        let convertBase64ToDownloadableLink = function (b64, filename, targetNode, fallbackHTML) {

            //IE-11 safe version. More verbose than modern fetch()
            if (window.Blob && window.URL && window.URL.createObjectURL) {

                var xhr = new XMLHttpRequest();
                xhr.open('GET', b64, true);
                xhr.responseType = 'blob';
                xhr.onload = function() {

                    if (xhr.status === 200) {

                        var blob = xhr.response;
                        var link = document.createElement('a');
                        link.innerText = "Download PDF";
                        link.href = URL.createObjectURL(blob);
                        link.setAttribute('download', filename);
                        targetNode.innerHTML = fallbackHTML.replace(/\[pdflink\]/g, link.outerHTML);

                    }

                };

                xhr.send();

            }

        };


        let generatePDFObjectMarkup = function (embedType, targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute, PDFJS_URL){

            //Ensure target element is empty first
            emptyNodeContents(targetNode);

            let source = url;

            if(embedType === "pdfjs"){
                //If PDFJS_URL already contains a ?, assume querystring is in place, and use an ampersand to append PDFJS's file parameter
                let connector = (PDFJS_URL.indexOf("?") !== -1) ? "&" : "?";
                source = PDFJS_URL + connector + "file=" + encodeURIComponent(url) + pdfOpenFragment;
            } else {
                source += pdfOpenFragment;
            }

            let el = document.createElement("iframe");
            el.className = "pdfobject";
            el.type = "application/pdf";
            el.title = title;
            el.src = source;
            el.allow = "fullscreen";
            el.frameborder = "0";
            if(id){ el.id = id; }

            if(!omitInlineStyles){

                let style = "border: none;";

                if(targetNode !== document.body){
                    //assign width and height to target node
                    style += "width: " + width + "; height: " + height + ";";
                } else {
                    //this is a full-page embed, use CSS to fill the viewport
                    style += "position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: 100%; height: 100%;";
                }

                el.style.cssText = style;

            }

            //Allow developer to insert custom attribute on iframe element, but ensure it does not conflict with attributes used by PDFObject
            let reservedTokens = ["className", "type", "title", "src", "style", "id", "allow", "frameborder"];
            if(customAttribute && customAttribute.key && reservedTokens.indexOf(customAttribute.key) === -1){
                el.setAttribute(customAttribute.key, (typeof customAttribute.value !== "undefined") ? customAttribute.value : "");
            }

            targetNode.classList.add("pdfobject-container");
            targetNode.appendChild(el);

            return targetNode.getElementsByTagName("iframe")[0];

        };

        let embed = function(url, targetSelector, options){

            //If targetSelector is not defined, convert to boolean
            let selector = targetSelector || false;

            //Ensure options object is not undefined -- enables easier error checking below
            let opt = options || {};

            //Get passed options, or set reasonable defaults
            suppressConsole = (typeof opt.suppressConsole === "boolean") ? opt.suppressConsole : false;
            let id = (typeof opt.id === "string") ? opt.id : "";
            let page = opt.page || false;
            let pdfOpenParams = opt.pdfOpenParams || {};
            let fallbackLink = (typeof opt.fallbackLink === "string" || typeof opt.fallbackLink === "boolean") ? opt.fallbackLink : true;
            let width = opt.width || "100%";
            let height = opt.height || "100%";
            let title = opt.title || "Embedded PDF";
            let forcePDFJS = (typeof opt.forcePDFJS === "boolean") ? opt.forcePDFJS : false;
            let omitInlineStyles = (typeof opt.omitInlineStyles === "boolean") ? opt.omitInlineStyles : false;
            let PDFJS_URL = opt.PDFJS_URL || false;
            let targetNode = getTargetElement(selector);
            let pdfOpenFragment = "";
            let customAttribute = opt.customAttribute || {};
            let fallbackFileNameForBase64 = opt.fallbackFileNameForBase64;
            let fallbackHTML_default = "<p>This browser does not support inline PDFs. Please download the PDF to view it: [pdflink]</p>";

            //Ensure URL is available. If not, exit now.
            if(typeof url !== "string"){ return embedError("URL is not valid"); }

            //If target element is specified but is not valid, exit without doing anything
            if(!targetNode){ return embedError("Target element cannot be determined"); }

            //page option overrides pdfOpenParams, if found
            if(page){ pdfOpenParams.page = page; }

            //Stringify optional Adobe params for opening document (as fragment identifier)
            pdfOpenFragment = buildURLFragmentString(pdfOpenParams);


            // --== Do the dance: Embed attempt #1 ==--

            //If the forcePDFJS option is invoked, skip everything else and embed as directed
            if(forcePDFJS && PDFJS_URL){
                return generatePDFObjectMarkup("pdfjs", targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute, PDFJS_URL);
            }

            // --== Embed attempt #2 ==--

            //Embed PDF if support is detected, or if this is a relatively modern browser
            if(supportsPDFs){
                return generatePDFObjectMarkup("iframe", targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute);
            }

            // --== Embed attempt #3 ==--

            //If everything else has failed and a PDFJS fallback is provided, try to use it
            if(PDFJS_URL){
                return generatePDFObjectMarkup("pdfjs", targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute, PDFJS_URL);
            }

            // --== PDF embed not supported! Use fallback ==--

            //Display the fallback link if available
            if(fallbackLink){

                //If a custom fallback has been provided, handle it now
                if(typeof fallbackLink === "string"){

                    //Ensure [url] is set in custom fallback
                    targetNode.innerHTML = fallbackLink.replace(/\[url\]/g, url);

                } else {

                    //If the PDF is a base64 string, convert it to a downloadable link
                    const match = url.match(/data:application\/pdf;(?:.*filename=([^;]+);)?.*base64,/i);
                    if(match){

                        fallbackFileNameForBase64 =
                            fallbackFileNameForBase64 // from options
                            || match[1] // from data URI metadata
                            || "file.pdf"; // default

                        //Asynchronously append the link to the targetNode
                        convertBase64ToDownloadableLink(url, fallbackFileNameForBase64, targetNode, fallbackHTML_default);

                    } else {

                        //Use default fallback link
                        let link = "<a href='" + url + "'>Download PDF</a>";
                        targetNode.innerHTML = fallbackHTML_default.replace(/\[pdflink\]/g, link);

                    }

                }

            }

            return embedError("This browser does not support embedded PDFs");

        };

        return {
            embed: function (a,b,c){ return embed(a,b,c); },
            pdfobjectversion: (function () { return pdfobjectversion; })(),
            supportsPDFs: (function (){ return supportsPDFs; })()
        };

    })); // END OF PDFObject

    // Pub-Sub / Observer Pattern
    // based on https://github.com/hassanshaikley/pico-pubsub
    const t = new EventTarget();
    const sub = (e, c) => (t.addEventListener(e, c), () => t.removeEventListener(e, c));
    const pub = (n, d) => t.dispatchEvent(new CustomEvent(n, { detail: d }));

    // Undo-Redo
    // based on https://blog.julik.nl/2025/03/a-tiny-undo-stack

    class UndoStack {

      static MAX_UNDO = 4_000_000_000;

      static #_UNDO_STACK_CHANGE_EVENT_NAME = "UNDO_STACK_CHANGE";

      static #_UNDO_STACK_CHANGE_EVENT_CLEAR = 0;
      static #_UNDO_STACK_CHANGE_EVENT_CLEAR_REDO = 1;
      static #_UNDO_STACK_CHANGE_EVENT_PUSH = 2;
      static #_UNDO_STACK_CHANGE_EVENT_UNDO = 3;
      static #_UNDO_STACK_CHANGE_EVENT_REDO = 4;
      static #_UNDO_STACK_CHANGE_EVENT_REMOVE_LAST = 5;
      static #_UNDO_STACK_CHANGE_EVENT_REMOVE_FIRST = 6;

      #_past = [];
      #_future = [];

      constructor() {}

      get undoCount() {
        return this.#_past.length;
      }

      get redoCount() {
        return this.#_future.length;
      }

      get undoAvailable() {
        return this.#_past.length > 0;
      }

      get redoAvailable() {
        return this.#_future.length > 0;
      }

      onChange(callback) {
        return sub(UndoStack.#_UNDO_STACK_CHANGE_EVENT_NAME, callback);
      }

      static #_cleanup(actions) {

        for (let a of actions) {
          a?.cleanup();
        }
      }

      clear() {

        if (this.#_past.length > 0 || this.#_future.length > 0) {

          UndoStack.#_cleanup(this.#_past);
          UndoStack.#_cleanup(this.#_future);
          this.#_past.length = 0;
          this.#_future.length = 0;

          console.log("Undo/redo stacks cleared.");
          pub(UndoStack.#_UNDO_STACK_CHANGE_EVENT_NAME, UndoStack.#_UNDO_STACK_CHANGE_EVENT_CLEAR);
        }
      }

      clearRedo() {

        if (this.#_future.length > 0) {

          UndoStack.#_cleanup(this.#_future);
          this.#_future.length = 0;
          console.log("Redo stack cleared.");
          pub(UndoStack.#_UNDO_STACK_CHANGE_EVENT_NAME, UndoStack.#_UNDO_STACK_CHANGE_EVENT_CLEAR_REDO);
        }
      }

      push(doFn, undoFn, ...withArguments) {

        const args = withArguments; // structuredClone(withArguments);
        const action = {
          doWithData() {
            doFn(...args);
          },
          undoWithData() {
            undoFn(...args);
          },
          cleanup () {
            if (doFn.cleanup) doFn.cleanup();
            if (undoFn.cleanup) undoFn.cleanup();
          }
        };
        action.doWithData();

        if (this.#_past.length === UndoStack.MAX_UNDO) {

          const firstAction = this.#_past.shift();

          if (firstAction) {

            firstAction.cleanup();
            pub(UndoStack.#_UNDO_STACK_CHANGE_EVENT_NAME, UndoStack.#_UNDO_STACK_CHANGE_EVENT_REMOVE_FIRST);
          }
        }

        // Adding a new action wipes the redoable steps
        this.#_past.push(action);
        UndoStack.#_cleanup(this.#_future);
        this.#_future.length = 0;

        pub(UndoStack.#_UNDO_STACK_CHANGE_EVENT_NAME, UndoStack.#_UNDO_STACK_CHANGE_EVENT_PUSH);

        return this.#_past.length - 1;
      }

      replace(index, doFn, undoFn, ...withArguments) {

        if (index > -1 && index < this.#_past.length) {

          const args = withArguments; // structuredClone(withArguments);
          const action = {
            doWithData() {
              doFn(...args);
            },
            undoWithData() {
              undoFn(...args);
            },
            cleanup () {
              if (doFn.cleanup) doFn.cleanup();
              if (undoFn.cleanup) undoFn.cleanup();
            }
          };
          let act = this.#_past[index];
          this.#_past[index] = action;
          act?.cleanup();
        }
      }

      undo() {

        const action = this.#_past.pop();

        if (action) {

          action.undoWithData();
          this.#_future.unshift(action);
          pub(UndoStack.#_UNDO_STACK_CHANGE_EVENT_NAME, UndoStack.#_UNDO_STACK_CHANGE_EVENT_UNDO);
        }
      }

      removeLast() {

          const action = this.#_past.pop();

          if (action) {

            action.cleanup();
            pub(UndoStack.#_UNDO_STACK_CHANGE_EVENT_NAME, UndoStack.#_UNDO_STACK_CHANGE_EVENT_REMOVE_LAST);
          }
      }

      redo() {

        const action = this.#_future.shift();

        if (action) {

          action.doWithData();
          this.#_past.push(action);
          pub(UndoStack.#_UNDO_STACK_CHANGE_EVENT_NAME, UndoStack.#_UNDO_STACK_CHANGE_EVENT_REDO);
        }
      }
    }

    const UNDO_STACK = new UndoStack();
    UNDO_STACK.onChange(function (event) {

      if (UNDO_STACK.undoAvailable)
        document.getElementById("btnUndo").removeAttribute("disabled");
      else
        document.getElementById("btnUndo").setAttribute("disabled", "");

      if (UNDO_STACK.redoAvailable)
        document.getElementById("btnRedo").removeAttribute("disabled");
      else
        document.getElementById("btnRedo").setAttribute("disabled", "");
    });

    // LCS - Longest Common Subsequence
    function getLCS(a, b) {

      if (a === b) return a;
      if (!a || !b) return "";

      const la = a.length;
      const lb = b.length;
      let p = 0;

      while (p < la && p < lb) {
        if (a[p] !== b[p]) break;
        ++p;
      }

      if (p === la) return a;
      if (p === lb) return b;
      const S = la < lb ? la - 1 : lb - 1;
      let s = 0;

      while (s < la && s < lb) {
        if (a[la - s - 1] !== b[lb - s - 1]) break;
        ++s;
      }

      if (s === la) return a;
      if (s === lb) return b;

      const a2 = (p === 0 && s === 0) ? a : a.substring(p, la - s); // (p > la - s) should not happen
      const b2 = (p === 0 && s === 0) ? b : b.substring(p, lb - s); // (p > lb - s) should not happen
      let lcs = "";
      {
        const dp = Array.from({ length: a2.length + 1 }, () => Array(b2.length + 1).fill(''));

        for (let i = 1; i <= a2.length; i++) {
          for (let j = 1; j <= b2.length; j++) {
            if (a2[i - 1] === b2[j - 1]) {
              dp[i][j] = dp[i - 1][j - 1] + a2[i - 1];
            } else {
              dp[i][j] = dp[i - 1][j].length > dp[i][j - 1].length ? dp[i - 1][j] : dp[i][j - 1];
            }
          }
        }

        lcs = dp[a2.length][b2.length];
      }
      const prefix = (p === 0) ? "" : a.substring(0, p);
      const suffix = (s === 0) ? "" : a.substring(la - s);

      return prefix + lcs + suffix;
    }

    // Text transformation - get the minimum operations (deletions and insertions)
    // to transform the source text into the target text

    class TextOperationType {
      static #_DELETE = 0;
      static #_INSERT = 1;

      static get DELETE() { return this.#_DELETE; }
      static get INSERT() { return this.#_INSERT; }

      static invert(op) { return ((op + 1) & 1); };
    }

    function getTextTransformationSteps(source, target) {

      if (source === target) return [];

      if (!source) return [{ type: TextOperationType.INSERT, text: target, index: 0 }];

      if (!target) return [{ type: TextOperationType.DELETE, text: source, index: 0 }];

      const lcs = getLCS(source, target);
      let i = 0, j = 0, k = 0;
      const operations = [];
      let current = source;

      while (k < lcs.length) {

        let del = "", ins = "";
        let start = i;

        while (source[i] !== lcs[k]) {
          del += source[i++];
        }

        if (del) {

          operations.push({ type: TextOperationType.DELETE, text: del, index: start });
          current = current.slice(0, start) + current.slice(start + del.length);
        }

        start = j;

        while (target[j] !== lcs[k]) {
          ins += target[j++];
        }

        if (ins) {

          operations.push({ type: TextOperationType.INSERT, text: ins, index: start });
          current = current.slice(0, start) + ins + current.slice(start);
        }

        i++; j++; k++;
      }

      if (i < source.length) {

        operations.push({ type: TextOperationType.DELETE, text: source.slice(i), index: i });
        current = current.slice(0, i);
      }

      if (j < target.length) {

        operations.push({ type: TextOperationType.INSERT, text: target.slice(j), index: current.length });
        current = current + target.slice(j);
      }
      console.log(operations);

      return operations;
    }

    function applyTextTransformationSteps(text, steps, reversed = false) {

      function applyTextTransformationStep(text, step, inverted) {

        let op = inverted ? TextOperationType.invert(step.type) : step.type;

        switch (op) {
          case TextOperationType.DELETE:
            text = text.slice(0, step.index) + text.slice(step.index + step.text.length);
            break;

          case TextOperationType.INSERT:
            text = text.slice(0, step.index) + step.text + text.slice(step.index);
            break;

          default:
            break;
        }

        return text;
      }

      if (reversed) steps = steps?.toReversed();

      steps?.forEach((step) => text = applyTextTransformationStep(text, step, reversed));

      return text;
    }

    // Media Recording

    class MediaRecordingStatus {
      static #_CLOSED = 0;
      static #_INITIALIZING = 1;
      static #_RECORDING = 2;

      static get CLOSED() { return this.#_CLOSED; }
      static get INITIALIZING() { return this.#_INITIALIZING; }
      static get RECORDING() { return this.#_RECORDING; }
    }

    // Audio Recorder object
    const audioRecorder = {
      recordingState: MediaRecordingStatus.CLOSED, /** Stores the recording state*/
      /** Stores the recorded audio as Blob objects of audio data as the recording continues*/
      audioBlobs: [],/*of type Blob[]*/
      /** Stores the reference of the MediaRecorder instance that handles the MediaStream when recording starts*/
      mediaRecorder: null, /*of type MediaRecorder*/
      /** Stores the reference to the stream currently capturing the audio*/
      streamBeingCaptured: null, /*of type MediaStream*/
      /** Start recording the audio 
       * @returns {Promise} - returns a promise that resolves if audio recording successfully started
       */
      isMediaRecordingSupported: function () {
        return !!(navigator?.mediaDevices && navigator.mediaDevices.getUserMedia);
      },
      start: function () {

        audioRecorder.recordingState = MediaRecordingStatus.INITIALIZING;

        // Feature Detection
        if (!(navigator?.mediaDevices && navigator.mediaDevices.getUserMedia)) {
          // Feature is not supported in browser
          // return a custom error
          audioRecorder.recordingState = MediaRecordingStatus.CLOSED;
          return Promise.reject(new Error("mediaDevices API or getUserMedia method is not supported in this browser."));
        } else {
          // Feature is supported in browser

          // create an audio stream
          return navigator.mediaDevices.getUserMedia({ audio: true }/*of type MediaStreamConstraints*/)
            // returns a promise that resolves to the audio stream
            .then(stream /*of type MediaStream*/ => {

              // save the reference of the stream to be able to stop it when necessary
              audioRecorder.streamBeingCaptured = stream;

              // create a media recorder instance by passing that stream into the MediaRecorder constructor
              audioRecorder.mediaRecorder = new MediaRecorder(stream); /*the MediaRecorder interface of the MediaStream Recording
              API provides functionality to easily record media*/

              // clear previously saved audio Blobs, if any
              audioRecorder.audioBlobs = [];

              // add a dataavailable event listener in order to store the audio data Blobs when recording
              audioRecorder.mediaRecorder.addEventListener("dataavailable", event => {
                // store audio Blob object
                audioRecorder.audioBlobs.push(event.data);
              });

              // start the recording by calling the start method on the media recorder
              audioRecorder.mediaRecorder.start();
              audioRecorder.recordingState = MediaRecordingStatus.RECORDING;
            });

            /* errors are not handled in the API because if its handled and the promise is chained, the .then after the catch will be executed*/
        }
      },
      /** Stop the started audio recording
       * @returns {Promise} - returns a promise that resolves to the audio as a blob file
       */
      stop: function () {
        // return a promise that would return the blob or URL of the recording
        return new Promise(resolve => {

          // save audio type to pass to set the Blob type
          const mimeType = audioRecorder.mediaRecorder.mimeType;

          // listen to the stop event in order to create & return a single Blob object
          audioRecorder.mediaRecorder.addEventListener("stop", () => {
            // create a single blob object, as we might have gathered a few Blob objects that needs to be joined as one
            const audioBlob = new Blob(audioRecorder.audioBlobs, { type: mimeType });
            audioRecorder.recordingState = MediaRecordingStatus.CLOSED;
            
            // resolve promise with the single audio blob representing the recorded audio
            resolve(audioBlob);
            audioRecorder.cancel();
          });
          audioRecorder.cancel();
        });
      },
      /** Cancel audio recording*/
      cancel: function () {
        // stop the recording feature
        audioRecorder.mediaRecorder?.stop();

        // stop all the tracks on the active stream in order to stop the stream
        audioRecorder.stopStream();

        // reset API properties for next recording
        audioRecorder.resetRecordingProperties();
      },
      /** Stop all the tracks on the active stream in order to stop the stream and remove
       * the red flashing dot showing in the tab
       */
      stopStream: function () {
        // stopping the capturing request by stopping all the tracks on the active stream
        audioRecorder.streamBeingCaptured?.getTracks() //get all tracks from the stream
          ?.forEach(track /*of type MediaStreamTrack*/ => track.stop()); //stop each one
      },
      /** Reset all the recording properties including the media recorder and stream being captured*/
      resetRecordingProperties: function () {

        audioRecorder.mediaRecorder = null;
        audioRecorder.streamBeingCaptured = null;
        audioRecorder.recordingState = MediaRecordingStatus.CLOSED;
        audioRecorder.audioBlobs = [];

        /*No need to remove event listeners attached to mediaRecorder as
        If a DOM element which is removed is reference-free (no references pointing to it), the element itself is picked
        up by the garbage collector as well as any event handlers/listeners associated with it.
        getEventListeners(audioRecorder.mediaRecorder) will return an empty array of events.*/
      }
    }; // END OF Media Recording

    const editor = document.getElementById("editor");
    const filename = document.getElementById("filename");

    // Helper: Places the caret at a given node and offset.
    function setCaret(node, pos) {

      const selection = window.getSelection();
      const range = document.createRange();
      range.setStart(node, pos);
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);

      return range;
    }

    // Helper: Places the caret after a given node.
    function setCaretAfter(node) {

      const selection = window.getSelection();
      const range = document.createRange();
      range.setStartAfter(node);
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);

      return range;
    }

    function setCaretAtEnd(node) {

      const ldc = getLastDeepestChild(node.classList?.contains("code-block") ? node.querySelector("code"): node);
      const range = document.createRange();

      if (ldc.nodeName === "BR") range.setStartBefore(ldc);
      else range.setStartAfter(ldc);

      range.collapse(true);

      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);

      return range;
    }

    function editorInsertBefore(childNode, siblingNodeId) {

      if (childNode && !editor.contains(childNode)) {

        const siblingNode = siblingNodeId ? document.getElementById(siblingNodeId) : null;

        if (!siblingNode || editor.contains(siblingNode)) {

          editor.insertBefore(childNode, siblingNode);

          if (childNode.classList?.contains("text-block") ||
              childNode.classList?.contains("code-block")) {
            if (childNode.classList?.contains("text-block")) setCaret(childNode, 0);
            else setCaret(childNode.querySelector("code"), 0);
          }
        }
      }
    }

    function editorRemoveChild(childNode, siblingNodeId) {

      if (childNode && editor.contains(childNode)) {

        if (childNode.classList?.contains("text-block") ||
            childNode.classList?.contains("code-block")) {

          let p = childNode.previousElementSibling;

          while (p &&
                 !p.classList?.contains("text-block") &&
                 !p.classList?.contains("code-block")) {
            p = p.previousElementSibling;
          }
          editor.removeChild(childNode);

          if (p) {
            if (p.classList?.contains("text-block")) setCaret(p, 0);
            else setCaret(p.querySelector("code"), 0);
          }
          else {
            editor.focus();
          }
        } else {

          editor.removeChild(childNode);
          editor.focus();
        }
      }
    }

    editor.UNDO_STACK = UNDO_STACK;

    const STYLE_TAGS = ["span", "strong", "em", "u", "s", "a"];

    const STYLES = [
      { tagName: "span", style: { "color": "var(--note-text-color-1)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-2)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-3)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-4)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-5)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-6)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-7)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-8)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-1)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-2)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-3)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-4)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-5)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-6)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-7)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-8)" }, attributes: null },
      { tagName: "span", style: { "font-size": "25%" }, attributes: null },
      { tagName: "span", style: { "font-size": "33.33%" }, attributes: null },
      { tagName: "span", style: { "font-size": "50%" }, attributes: null },
      { tagName: "span", style: { "font-size": "66.66%" }, attributes: null },
      { tagName: "span", style: { "font-size": "75%" }, attributes: null },
      { tagName: "span", style: { "font-size": "125%" }, attributes: null },
      { tagName: "span", style: { "font-size": "150%" }, attributes: null },
      { tagName: "span", style: { "font-size": "175%" }, attributes: null },
      { tagName: "span", style: { "font-size": "200%" }, attributes: null },
      { tagName: "span", style: { "font-size": "250%" }, attributes: null },
      { tagName: "span", style: { "font-size": "300%" }, attributes: null },
      { tagName: "span", style: { "font-size": "350%" }, attributes: null },
      { tagName: "strong", style: null, attributes: null },
      { tagName: "em", style: null, attributes: null },
      { tagName: "u", style: null, attributes: null },
      { tagName: "s", style: null, attributes: null }
    ];

    const TEXT_COLORS_N = 8;
    const HIGHLIGHT_COLORS_N = 8;
    const FONT_SIZES_N = 12;

    const STYLE_TEXT_COLOR_BASE_INDEX = -1;
    const STYLE_HIGHLIGHT_COLOR_BASE_INDEX = STYLE_TEXT_COLOR_BASE_INDEX + TEXT_COLORS_N;
    const STYLE_FONT_BASE_INDEX = STYLE_HIGHLIGHT_COLOR_BASE_INDEX + HIGHLIGHT_COLORS_N;

    const STYLE_STRONG_INDEX = STYLE_FONT_BASE_INDEX + FONT_SIZES_N + 1;
    const STYLE_EM_INDEX = STYLE_STRONG_INDEX + 1;
    const STYLE_U_INDEX = STYLE_EM_INDEX + 1;
    const STYLE_S_INDEX = STYLE_U_INDEX + 1;

    const STYLE_LINK_BASE_INDEX = STYLE_S_INDEX;

    const STYLE_GROUPS = [[STYLE_TEXT_COLOR_BASE_INDEX + 1, STYLE_TEXT_COLOR_BASE_INDEX + TEXT_COLORS_N],
                          [STYLE_HIGHLIGHT_COLOR_BASE_INDEX + 1, STYLE_HIGHLIGHT_COLOR_BASE_INDEX + HIGHLIGHT_COLORS_N],
                          [STYLE_FONT_BASE_INDEX + 1, STYLE_FONT_BASE_INDEX + FONT_SIZES_N]];

    // Helper: gets all the distinct links in the text and indexes them as styles
    function updateLinkStyles(editor) {

      const links = new Set();
      editor.querySelectorAll("a").forEach((linkNode) => {
        if (linkNode.hasAttribute("href")) links.add(linkNode.getAttribute("href"));
      });

      while (STYLES[STYLES.length - 1].tagName === "a") {
        STYLES.pop();
      }

      for(let link of links) STYLES.push({tagName: "a", style: null, attributes: { "href": link }});
    }

    // Helper: generates a unique id
    function generateUId() {

      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }

      return s4() + s4() + s4() + s4() +
             s4() + s4() + s4() + s4();
    }

    // Blocks page interaction
    function blockPageInteraction() {

      const divNode = document.createElement("div");
      divNode.setAttribute("id", `blockingPage${generateUId()}`);
      document.body.appendChild(divNode);

      return function() {
        divNode.remove();
      }
    }

    function setEditMode(editMode) {

      const toolbar = document.getElementById("toolbar");

      if (editMode) {

        editor.contentEditable = "true";
        filename.contentEditable = "plaintext-only";
        toolbar.style.display = "flex";
      } else {

        editor.contentEditable = "false";
        filename.contentEditable = "false";
        toolbar.style.display = "none";
      }
    }

    function removeDocumentNodes(html, editMode) {

      const template = document.createElement("template");
      template.innerHTML = html;

      template.content.querySelectorAll(".embedded-local-epub").forEach(el => {
        el.replaceChildren();
        if (editMode === false) el.setAttribute("data-readonly", "true");
      });

      /*template.content.querySelectorAll(".embedded-local-pdf").forEach(el => {
        el.replaceChildren();
      });*/

      if (editMode === false) {

        template.content.querySelectorAll(".x-remover").forEach(el => {
          el.parentNode?.removeChild(el);
        });

        template.content.querySelectorAll("*[contenteditable]").forEach(el => {
          el.setAttribute("contenteditable", "false");
        });
      }

      return template.innerHTML;
    }

    class SaveType {
      static #_DOWNLOAD = 0;
      static #_FILE = 1;
      static #_SHARE = 2;

      static get DOWNLOAD() { return this.#_DOWNLOAD; }
      static get FILE() { return this.#_FILE; }
      static get SHARE() { return this.#_SHARE; }
    }

    function getNewFileHandle(suggestedName) {

      const opts = {
        suggestedName: suggestedName,
        types: [
          {
            description: "Html file",
            accept: { "text/html": [".html"] },
          },
        ],
      };

      return window.showSaveFilePicker ? window.showSaveFilePicker(opts) : null;
    }

    async function exportToFile(saveType, editMode) {

      let filename = document.getElementById("filename").innerText.trim();

      if (!filename) {
        alert("Title is empty!");
        return;
      }

      if (audioRecorder.recordingState !== MediaRecordingStatus.CLOSED) {
        alert("Stop recording before " + (saveType === SaveType.SHARE ? "sharing." : "saving."));
        return;
      }

      filename = filename.endsWith(".html") ? filename : filename + ".html";

      if (editMode === false) {
        setEditMode(false);
      }

      let content = removeDocumentNodes(document.documentElement.outerHTML, editMode);
      let blob = new Blob(["<!DOCTYPE html>\n" + content], { type: "text/html" });
      let file = new File([blob], filename, { type: "text/html" });

      if (editMode === false) {
        setEditMode(true);
      }

      switch (saveType) {

        case SaveType.DOWNLOAD:

          let a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = filename;
          a.click();
          URL.revokeObjectURL(a.href);
          break;

        case SaveType.FILE:

          let writable = null;

          try {

            const promise = getNewFileHandle(filename);

            if (!promise) {
              alert("Feature not supported in this browser.");
              return;
            }

            const fileHandle = await promise;
            writable = await fileHandle.createWritable();
            await writable.write(blob);
            await writable.close();
          } catch (error) {

            console.error("save to file failed:", error);

            if (writable) {

              try {
                await writable.close();
              } catch (err) {
                console.error("closing the file failed:", err);
              }
            }
          }
          break;

        case SaveType.SHARE:

          if (navigator.canShare && navigator.canShare({ files: [file] })) {

            try {
              await navigator.share({
                files: [file],
                title: filename,
                text: ""
              });
            } catch (error) {
              console.error("share failed:", error);
            }
          }
          break;
      }
    }

    // Gets the top parent node of the child node, parent that has root container as its direct parent
    // the root container argument is either the editor or a TR element (for a table's th or td cell)
    // we are working on this top parent node text to style it
    function getTopLevelNodeOf(childNode, rootContainer) {

      if (childNode !== rootContainer) {

        while (childNode && childNode.parentNode !== rootContainer) {
          childNode = childNode.parentNode;
        }
      }

      return (childNode?.parentNode === rootContainer) ? childNode : null;
    }

    function getTopLevelNodeOfCurrentPosition(useSelectionRange = null) {

      let range = useSelectionRange;

      if (!range) {

        let selection = window.getSelection();

        if (selection?.rangeCount) {
          range = selection.getRangeAt(0);
        }
      }

      return getTopLevelNodeOf(range?.startContainer, editor);
    }

    function createRemover(callback = null) {

      const divNode = document.createElement("div");
      divNode.innerText = "❌";

      if (callback) {
        divNode.addEventListener("click", function (e) {
          callback();
        }, false);
      } else {
        divNode.setAttribute("onclick", "handleXRemoveEvent(event)");
      }
      divNode.setAttribute("class", "x-remover non-selectable");
      divNode.setAttribute("contenteditable", "false");

      return divNode;
    }

    function showPrompt(message) {

      return new Promise((resolve, reject) => setTimeout(function() {
        resolve(prompt(message));
      }, 10));
    }

    function insertImage(event) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextElementSibling;
        reader.onload = function (e) {

          const divNode = document.createElement("div");
          const img = document.createElement("img");
          img.src = e.target.result;
          divNode.appendChild(img);
          divNode.appendChild(createRemover());
          divNode.setAttribute("id", `img${generateUId()}`);
          divNode.setAttribute("class", "embedded-local-image");
          divNode.setAttribute("contenteditable", "false");
          UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
        };
        reader.readAsDataURL(file);
      }
    }

    async function insertImageLink() {

      const url = (await showPrompt("Image URL"))?.trim();
      if (!url) return;

      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextElementSibling;
      const divNode = document.createElement("div");
      const img = document.createElement("img");
      img.src = `${url}`;
      divNode.appendChild(img);
      divNode.appendChild(createRemover());
      divNode.setAttribute("id", `img${generateUId()}`);
      divNode.setAttribute("class", "image-link");
      divNode.setAttribute("contenteditable", "false");
      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
    }

    function insertAudio(event) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextElementSibling;
        reader.onload = function (e) {

          const divNode = document.createElement("div");
          const audio = document.createElement("audio");
          audio.src = e.target.result;
          audio.setAttribute("controls", "");
          divNode.appendChild(audio);
          divNode.appendChild(createRemover());
          divNode.setAttribute("id", `audio${generateUId()}`);
          divNode.setAttribute("class", "embedded-local-audio");
          divNode.setAttribute("contenteditable", "false");
          UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
        };
        reader.readAsDataURL(file);
      }
    }

    async function insertAudioLink() {

      const url = (await showPrompt("Audio URL"))?.trim();
      if (!url) return;

      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextElementSibling;
      const divNode = document.createElement("div");
      const audio = document.createElement("audio");
      audio.src = `${url}`;
      audio.setAttribute("controls", "");
      divNode.appendChild(audio);
      divNode.appendChild(createRemover());
      divNode.setAttribute("id", `audio${generateUId()}`);
      divNode.setAttribute("class", "audio-link");
      divNode.setAttribute("contenteditable", "false");
      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
    }

    async function insertVideoLink() {

      const url = (await showPrompt("Video URL"))?.trim();
      if (!url) return;

      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextElementSibling;
      const divNode = document.createElement("div");
      const video = document.createElement("video");
      video.src = `${url}`;
      video.setAttribute("controls", "");
      divNode.appendChild(video);
      divNode.appendChild(createRemover());
      divNode.setAttribute("id", `video${generateUId()}`);
      divNode.setAttribute("class", "video-link");
      divNode.setAttribute("contenteditable", "false");
      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
    }

    const audioRecordingInserter = {

      /** Stores the audio recording node id*/
      strArId: null,

      /** Stores the audio recording node*/
      audioRecordingNode: null,

      /** Stores the audio recording node's next sibling present already in the DOM tree*/
      nextSibling: null,

      /** Stores the elapsed time node*/
      elapsedTimeTag: null,

      /** Stores the actual start time when an audio recording begins to take place to ensure elapsed time start time is accurate*/
      audioRecordStartTime: null,

      /** Stores the maximum recording time in hours to stop recording once maximum recording hour has been reached */
      maximumRecordingTimeInHours: 1,

      /** Stores the reference of the setInterval function that controls the timer in audio recording*/
      elapsedTimeTimer: null,

      undoStackIndex: -1,

      /** Resets all the audioRecordingInserter's data members*/
      reset: function () {

        audioRecordingInserter.strArId = null;
        audioRecordingInserter.audioRecordingNode = null;
        audioRecordingInserter.nextSibling = null;
        audioRecordingInserter.elapsedTimeTag = null;
        audioRecordingInserter.audioRecordStartTime = null;
        audioRecordingInserter.elapsedTimeTimer = null;
        audioRecordingInserter.undoStackIndex = -1;
      },

      /** Tries to start recording and insert the audio recording ui in the page*/
      insert: function (useSelectionRange) {

        if (!audioRecorder.isMediaRecordingSupported()) {
          console.log("Media recording is not supported in this browser.");
          alert("Media recording is not supported in this browser.");
          return;
        }

        if (audioRecorder.recordingState !== MediaRecordingStatus.CLOSED) {
          alert("A recording is already in progress.");
          return;
        }
        audioRecordingInserter.reset();

        audioRecordingInserter.nextSibling = getTopLevelNodeOfCurrentPosition(useSelectionRange)?.nextElementSibling;
        audioRecordingInserter.strArId = `ar${generateUId()}`;
        audioRecordingInserter.audioRecordingNode = document.createElement("div");
        audioRecordingInserter.audioRecordingNode.setAttribute("id", audioRecordingInserter.strArId);
        audioRecordingInserter.audioRecordingNode.setAttribute("class", "audio-recording");
        audioRecordingInserter.audioRecordingNode.setAttribute("contenteditable", "false");

        const audioRecordingControlsNode = document.createElement("div");
        audioRecordingControlsNode.setAttribute("class", "recording-control-buttons-container non-selectable");
        audioRecordingControlsNode.setAttribute("contenteditable", "false");
        audioRecordingControlsNode.innerHTML = `
            <button class="cancel-recording-button non-selectable" contenteditable="false" aria-hidden="true">✖</button>
            <div class="recording-elapsed-time non-selectable" contenteditable="false">
              <b class="red-recording-dot non-selectable" contenteditable="false" aria-hidden="true">🔴</b>
              <p class="elapsed-time non-selectable" style="font-size: 28px;" contenteditable="false">00:00</p>
            </div>
            <button class="stop-recording-button non-selectable" contenteditable="false" aria-hidden="true">✓</button>`;
        audioRecordingInserter.audioRecordingNode.appendChild(audioRecordingControlsNode);

        if (audioRecorder.recordingState === MediaRecordingStatus.CLOSED) {
          audioRecordingInserter.startAudioRecording();
        } else {
          audioRecordingInserter.reset();
        }
      },

      /** Starts recording using the audio recording API*/
      startAudioRecording: function () {

        console.log("Recording Audio...");

        const audioElements = document.querySelectorAll("audio");

        for (let audioElement of audioElements) {

          // If a previous audio recording is playing, pause it
          if (!audioElement.paused) {
            audioElement.pause();
          }
        }

        if (audioRecorder.recordingState !== MediaRecordingStatus.CLOSED) {
          audioRecordingInserter.reset();
          return;
        }

        // start recording using the audio recording API
        audioRecorder.start()
          .then(() => { //on success

            audioRecordingInserter.audioRecordStartTime = new Date(); // store the recording start time to display the elapsed time according to it
            const audioRecordingNode = audioRecordingInserter.audioRecordingNode;
            const nextSibling = audioRecordingInserter.nextSibling;
            audioRecordingInserter.undoStackIndex = UNDO_STACK.push(editorInsertBefore, function (_, _2) {
              audioRecordingInserter.onClickCancelAudioRecording();
            }, audioRecordingNode, nextSibling?.id);
            audioRecordingInserter.elapsedTimeTag = document.querySelectorAll(`#${audioRecordingInserter.strArId} .elapsed-time`)[0];
            const stopRecordingButton = document.querySelectorAll(`#${audioRecordingInserter.strArId} .stop-recording-button`)[0];
            const cancelRecordingButton = document.querySelectorAll(`#${audioRecordingInserter.strArId} .cancel-recording-button`)[0];
            stopRecordingButton.onclick = audioRecordingInserter.stopAudioRecording;
            cancelRecordingButton.onclick = audioRecordingInserter.onClickCancelAudioRecording;
            audioRecordingInserter.handleElapsedRecordingTime();
          })
          .catch(error => { // on error
            // No Browser Support Error
            if (error.message.includes("mediaDevices API or getUserMedia method is not supported in this browser.")) {
              console.log("To record audio, use browsers like Chrome and Firefox.");
              alert("To record audio, use browsers like Chrome and Firefox.");
            }

            // Error handling structure
            switch (error.name) {
              case "AbortError": // error from navigator.mediaDevices.getUserMedia
                console.log("An AbortError has occured.");
                break;
              case "NotAllowedError": // error from navigator.mediaDevices.getUserMedia
                console.log("A NotAllowedError has occured. User might have denied permission.");
                break;
              case "NotFoundError": // error from navigator.mediaDevices.getUserMedia
                console.log("A NotFoundError has occured.");
                break;
              case "NotReadableError": // error from navigator.mediaDevices.getUserMedia
                console.log("A NotReadableError has occured.");
                break;
              case "SecurityError": // error from navigator.mediaDevices.getUserMedia or from the MediaRecorder.start
                console.log("A SecurityError has occured.");
                break;
              case "TypeError": // error from navigator.mediaDevices.getUserMedia
                console.log("A TypeError has occured.");
                break;
              case "InvalidStateError": // error from the MediaRecorder.start
                console.log("An InvalidStateError has occured.");
                break;
              case "UnknownError": // error from the MediaRecorder.start
                console.log("An UnknownError has occured.");
                break;
              default:
                console.log("An error occured with the error name " + error.name);
            };
            audioRecordingInserter.cancelAudioRecording();
          });
      },

      /** Stops the currently started audio recording & sends it*/
      stopAudioRecording: function () {

        console.log("Stopping Audio Recording...");

        // stop the recording using the audio recording API
        audioRecorder.stop()
          .then(audioAsblob => {

            audioRecordingInserter.handleRecordingEnd();
            audioRecordingInserter.showAudioPlay(audioAsblob);
          })
          .catch(error => {
            // Error handling structure
            switch (error.name) {
              case "InvalidStateError": // error from the MediaRecorder.stop
                console.log("An InvalidStateError has occured.");
                break;
              default:
                console.log("An error occured with the error name " + error.name);
            };
            audioRecordingInserter.cancelAudioRecording();
          });
      },

      /** Cancels the currently started audio recording */
      cancelAudioRecording: function () {

        console.log("Canceling audio...");

        // cancel the recording using the audio recording API
        audioRecorder.cancel();
        audioRecordingInserter.handleRecordingEnd();

        const audioRecordingNode = audioRecordingInserter.audioRecordingNode;
        const nextSibling = audioRecordingInserter.nextSibling;
        audioRecordingNode.innerHTML = '<div class="recording-cancelled-container" contenteditable="false"><span style="margin: 0 10px">Cancelled audio recording</span></div>';
        audioRecordingNode.appendChild(createRemover());
        UNDO_STACK.replace(audioRecordingInserter.undoStackIndex, editorInsertBefore, editorRemoveChild, audioRecordingNode, nextSibling?.id);
        audioRecordingInserter.reset(); // audioRecordingInserter's job is finished here
      },

      onClickCancelAudioRecording: function () {

        if (confirm("Do you want to cancel audio recording? The cancellation cannot be undone.")) {
          audioRecordingInserter.cancelAudioRecording();
        }
      },

      /** Shows the audio play interface for playing the recorded audio using the audio element in the HTML document
       * @param {Blob} recorderAudioAsBlob - recorded audio as a Blob Object 
      */
      showAudioPlay: function (recorderAudioAsBlob) {

        // read content of files (Blobs) asynchronously
        let reader = new FileReader();

        // once content has been read
        reader.onload = (e) => {

          const audioRecordingNode = audioRecordingInserter.audioRecordingNode;
          const nextSibling = audioRecordingInserter.nextSibling;
          audioRecordingNode.innerHTML = `<audio controls src="${e.target.result}"></audio>`;
          audioRecordingNode.appendChild(createRemover());

          UNDO_STACK.replace(audioRecordingInserter.undoStackIndex, editorInsertBefore, editorRemoveChild, audioRecordingNode, nextSibling?.id);

          document.querySelectorAll(`#${audioRecordingInserter.strArId} audio`)[0].load();
          audioRecordingInserter.reset(); // audioRecordingInserter's job is finished here
        };

        // read content and convert it to a URL (base64)
        reader.readAsDataURL(recorderAudioAsBlob);
      },

      /** Hides the recording status bar*/
      hideRecordingStatusBar: function () {
        document.getElementById("editorContainer").classList.add("thin-line");
        document.getElementById("recordingBar").classList.add("hidden");
      },

      /** Checks if the recording animated dot is showing in the window viewport*/
      recordingDotShowingInViewport: function () {

        const dot = document.querySelectorAll(".audio-recording .red-recording-dot")[0];
        const toolbar = document.getElementById("toolbar");
        const dotRect = dot.getBoundingClientRect();
        const toolbarRect = toolbar.getBoundingClientRect();
        const wWidth = (window.innerWidth || document.documentElement.clientWidth);
        const wHeight = (window.innerHeight || document.documentElement.clientHeight);
        const dotTopOffset = 11;
        const dotBottomOffset = 6;

        return (dotRect.top + dotTopOffset < wHeight
            && dotRect.bottom - dotBottomOffset > toolbarRect.bottom
            && dotRect.left < wWidth
            && dotRect.left > -dotRect.width);
      },

      /** Displays the recording status bar if the recording animated dot is not showing in the window viewport, otherwise it hides the recording status bar*/
      showRecordingStatusBar: function () {

        if (!audioRecordingInserter.recordingDotShowingInViewport()) {
          document.getElementById("editorContainer").classList.remove("thin-line");
          document.getElementById("recordingBar").classList.remove("hidden");
        } else {
          audioRecordingInserter.hideRecordingStatusBar();
        }
      },

      /** Computes the elapsed recording time since the moment the function is called in the format h:m:s*/
      handleElapsedRecordingTime: function () {

        // display inital time when recording begins
        audioRecordingInserter.displayElapsedTimeDuringAudioRecording("00:00");
        audioRecordingInserter.showRecordingStatusBar();
        document.addEventListener("scroll", audioRecordingInserter.showRecordingStatusBar);

        // create an interval that compute & displays elapsed time, as well as, animate red dot - every second
        audioRecordingInserter.elapsedTimeTimer = setInterval(() => {
          // compute the elapsed time every second
          const elapsedTime = audioRecordingInserter.computeElapsedTime(audioRecordingInserter.audioRecordStartTime); // pass the actual record start time
          // display the elapsed time
          audioRecordingInserter.displayElapsedTimeDuringAudioRecording(elapsedTime);
        }, 1000); // every second
      },

      /** Displays elapsed time during audio recording
       * @param {String} elapsedTime - elapsed time in the format mm:ss or hh:mm:ss 
       */
      displayElapsedTimeDuringAudioRecording: function (elapsedTime) {

        // 1. display the passed elapsed time as the elapsed time in the elapsedTime HTML element
        audioRecordingInserter.elapsedTimeTag.innerHTML = elapsedTime;

        // 2. Stop the recording when the max number of hours is reached
        if (audioRecordingInserter.elapsedTimeReachedMaximumNumberOfHours(elapsedTime)) {
          audioRecordingInserter.stopAudioRecording();
        } else {
          audioRecordingInserter.showRecordingStatusBar();
        }
      },

      /**
       * @param {String} elapsedTime - elapsed time in the format mm:ss or hh:mm:ss  
       * @returns {Boolean} whether the elapsed time reached the maximum number of hours or not
       */
      elapsedTimeReachedMaximumNumberOfHours: function (elapsedTime) {

        // Split the elapsed time by the symbo :
        const elapsedTimeSplitted = elapsedTime.split(":");

        // Turn the maximum recording time in hours to a string and pad it with zero if less than 10
        const maximumRecordingTimeInHoursAsString = audioRecordingInserter.maximumRecordingTimeInHours < 10 ?
                                                      "0" + audioRecordingInserter.maximumRecordingTimeInHours :
                                                      audioRecordingInserter.maximumRecordingTimeInHours.toString();

        // if it the elapsed time reach hours and also reach the maximum recording time in hours return true
        if (elapsedTimeSplitted.length === 3 && elapsedTimeSplitted[0] === maximumRecordingTimeInHoursAsString)
          return true;
        else // otherwise, return false
          return false;
      },

      /** Computes the elapsedTime since the moment the function is called in the format mm:ss or hh:mm:ss
       * @param {String} startTime - start time to compute the elapsed time since
       * @returns {String} elapsed time in mm:ss format or hh:mm:ss format, if elapsed hours are 0.
       */
      computeElapsedTime: function (startTime) {

        // record end time
        const endTime = new Date();

        // time difference in ms
        let timeDiff = endTime - startTime;

        // convert time difference from ms to seconds
        timeDiff = timeDiff / 1000;

        // extract integer seconds that dont form a minute using %
        let seconds = Math.floor(timeDiff % 60); // ignoring uncomplete seconds (floor)

        // pad seconds with a zero if neccessary
        seconds = seconds < 10 ? "0" + seconds : seconds;

        // convert time difference from seconds to minutes using %
        timeDiff = Math.floor(timeDiff / 60);

        // extract integer minutes that don't form an hour using %
        let minutes = timeDiff % 60; // no need to floor possible incomplete minutes, becase they've been handled as seconds
        minutes = minutes < 10 ? "0" + minutes : minutes;

        // convert time difference from minutes to hours
        timeDiff = Math.floor(timeDiff / 60);

        // extract integer hours that don't form a day using %
        let hours = timeDiff % 24; // no need to floor possible incomplete hours, becase they've been handled as seconds

        // convert time difference from hours to days
        timeDiff = Math.floor(timeDiff / 24);

        // the rest of timeDiff is number of days
        let days = timeDiff; // add days to hours

        let totalHours = hours + (days * 24);
        totalHours = totalHours < 10 ? "0" + totalHours : totalHours;

        if (totalHours === "00") {
          return minutes + ":" + seconds;
        } else {
          return totalHours + ":" + minutes + ":" + seconds;
        }
      },

      /** Hides the displayed recording control buttons */
      handleRecordingEnd: function () {

        // stop interval that handles both time elapsed and the red dot
        if (audioRecordingInserter.elapsedTimeTimer) {
          clearInterval(audioRecordingInserter.elapsedTimeTimer);
          audioRecordingInserter.elapsedTimeTimer = null;
          console.log("Recording timer stopped.");
        }
        audioRecordingInserter.hideRecordingStatusBar();
        document.removeEventListener("scroll", audioRecordingInserter.showRecordingStatusBar);
      }
    };

    function insertAudioRecording() {
      audioRecordingInserter.insert(lastValidSelectionRange);
    }

    function setMathExpression(nodeId, expression) {

      const node = document.getElementById(nodeId);
      const mathNode = node?.querySelector("math");

      if (mathNode) {

        node.setAttribute("data-math", expression);
        mathup(expression, { bare: true }).updateDOM(mathNode);
      }
    }

    function doMathExpression(nodeId, _, newExpression) {

      setMathExpression(nodeId, newExpression);
    }

    function undoMathExpression(nodeId, oldExpression, _) {

      setMathExpression(nodeId, oldExpression);
    }

    function onMathClick(e) {

      let node = e.target;

      while (node && !node.classList?.contains("embedded-math")) {
        node = node.parentNode;
      }

      if (!node?.id) return false;

      const currentExpression = node.getAttribute("data-math");
      const newExpression = prompt("Introduce math expression (see https://mathup.xyz):", currentExpression)?.trim();

      if (!newExpression || currentExpression === newExpression) return false;

      UNDO_STACK.push(doMathExpression, undoMathExpression, node.id, currentExpression, newExpression);

      return true;
    }

    function insertMath() {

      const expression = prompt("Introduce math expression (see https://mathup.xyz):")?.trim();
      if (!expression) return;

      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextElementSibling;
      const divNode = document.createElement("div");

      const mathNode = mathup(expression, { bare: false, display: "inline" }).toDOM();
      mathNode.addEventListener("click", onMathClick);

      divNode.appendChild(mathNode);
      divNode.appendChild(createRemover());
      divNode.setAttribute("id", `math${generateUId()}`);
      divNode.setAttribute("class", "embedded-math");
      divNode.setAttribute("contenteditable", "false");
      divNode.setAttribute("data-math", expression);
      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
    }

    function loadAllReferencedDocuments() {

      document.querySelectorAll(".embedded-local-epub").forEach(async el => {
        const dataUrl = el.getAttribute("data-epub");
        await loadEpub(dataUrl, null, el);
      });

      /*document.querySelectorAll(".embedded-local-pdf").forEach(async el => {
        const dataUrl = el.getAttribute("data-pdf");
        await loadPdf(dataUrl, null, el);
      });*/
    }

    function insertEpub(event, element = null) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextElementSibling;
        reader.onload = async function (e) {
          loadEpub(e.target?.result, nextSibling);
        }
        reader.readAsDataURL(file);
      }
    }

    function loadEpub(epubData, nextSibling, element = null) {

      if (epubData) {

        let book = null;
        const epubId = generateUId();
        const strEpubId = `epub${epubId}`;
        element?.replaceChildren();
        const divNode = element || document.createElement("div");
        divNode.setAttribute("class", "embedded-local-epub epub-loading");
        divNode.setAttribute("contenteditable", "false");
        divNode.setAttribute("data-epub", epubData);
        const destroyBook = () => {
          if (!editor.contains(divNode) && book) {
            book.destroy();
            book = null;
            console.log("Epub book destroyed.");
          }
        }
        const removeEpubNode = (childNode, nextSiblingId) => { editorRemoveChild(childNode, nextSiblingId); };
        removeEpubNode.cleanup = destroyBook;
        if (!element) UNDO_STACK.push(editorInsertBefore, removeEpubNode, divNode, nextSibling?.id);

        setTimeout(async () => {

          const unblockPageInteraction = blockPageInteraction();

          try {
            //book = ePub(epubData, { openAs: "base64" }); // BUG: not working
            book = ePub(await (await window.fetch(epubData)).blob());
          } catch (error) { // we allow ePub loading only if epub library is available and the data could be loaded

            console.log(error);
            unblockPageInteraction();

            if (!element) UNDO_STACK.removeLast();
            if (editor.contains(divNode)) editor.removeChild(divNode);
            return;
          }
          unblockPageInteraction();
          const strTocId = `toc${epubId}`;

          const navButtons = document.createElement("div");
          navButtons.style = "float: top; display: flow-root;";
          navButtons.setAttribute("contenteditable", "false");
          const prev = document.createElement("div");
          const next = document.createElement("div");
          prev.setAttribute("id", `prev${epubId}`);
          next.setAttribute("id", `next${epubId}`);
          prev.setAttribute("class", "non-selectable");
          next.setAttribute("class", "non-selectable");
          prev.textContent = "<PREV";
          next.textContent = "NEXT>";
          prev.style = "float: left; left: 0; margin: 5px 5px; cursor: pointer;";
          next.style = "float: right; right: 0; margin: 5px 5px; cursor: pointer;";
          prev.setAttribute("contenteditable", "false");
          next.setAttribute("contenteditable", "false");
          navButtons.appendChild(prev);
          navButtons.appendChild(next);

          const selectToc = document.createElement("select");
          const divEbook = document.createElement("div");
          divEbook.style = "flex: top;";
          divEbook.setAttribute("class", "ebook-content");
          divEbook.setAttribute("id", strEpubId);
          selectToc.style = "float: top; left: 0; margin: 5px 5px; background: inherit; color: inherit;";
          selectToc.setAttribute("id", strTocId);
          divNode.appendChild(selectToc);

          divNode.appendChild(navButtons);

          divNode.appendChild(divEbook);
          divEbook.book = book;
          const readonly = divNode.getAttribute("data-readonly") ?? false;

          if (!readonly) {

            divNode.appendChild(createRemover(function () {

              editor.UNDO_STACK.push(removeEpubNode, editorInsertBefore,
                                     divNode, nextSibling?.id);
            }));
          }
          const rendition = book.renderTo(strEpubId, { flow: "scrolled",
                                                       width: "100%", height: 600, replacements: "base64" /*, allowScriptedContent: true*/ });

          const keyListener = function (e) {

            // Left Key
            if ((e.keyCode || e.which) === 37) {
              rendition?.prev();
            }

            // Right Key
            if ((e.keyCode || e.which) === 39) {
              rendition?.next();
            }
          };
          rendition?.on("keyup", keyListener);
          document.addEventListener("keyup", keyListener, false);

          prev.addEventListener("click", function (e) {
            rendition?.prev();
            e.preventDefault();
          }, false);

          next.addEventListener("click", function (e) {
            rendition?.next();
            e.preventDefault();
          }, false);

          const displayed = rendition?.display();
          book.loaded.navigation.then(function (toc) {

            divNode.classList.remove("epub-loading");
            const docFrag = document.createDocumentFragment();

            toc.forEach(function (chapter) {

              const option = document.createElement("option");
              option.textContent = chapter.label;
              option.setAttribute("ref", chapter.href);

              docFrag.appendChild(option);
            });
            selectToc.appendChild(docFrag);
            selectToc.onchange = function () {

              const index = selectToc.selectedIndex,
                    url = selectToc.options[index].getAttribute("ref");
              rendition?.display(url);

              return false;
            };
          });
          function navigatedTo(href) {

            let result = false;

            if (href) {

              const selectToc = document.getElementById(strTocId);
              const selectedOption = selectToc.querySelector("option[selected]");

              if (selectedOption) {
                selectedOption.removeAttribute("selected");
              }
              const allOptions = selectToc.querySelectorAll("option");

              for (let i = 0; i < allOptions.length; ++i) {

                let selected = allOptions[i].getAttribute("ref") === href;

                if (selected) {
                  allOptions[i].setAttribute("selected", "true");
                  selectToc.selectedIndex = i;
                  result = true;
                }
              }
            }

            return result;
          }
          rendition?.on("rendered", function (section) {

            const current = book.navigation && book.navigation.get(section.href);
            navigatedTo(current?.href);
          });
          rendition?.on("relocated", function (location) {

            let current = book.navigation.get(location.start?.href);

            while (current?.parent) {
              current = book.navigation.get(current.parent);
            }
            navigatedTo(current?.href);
          });
        }, 0);
      };
    }

    function insertPdf(event, element = null) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextElementSibling;
        reader.onload = async function (e) {
          await loadPdf(e.target?.result, nextSibling);
        }
        reader.readAsDataURL(file);
      }
    }

    async function loadPdf(pdfData, nextSibling, element = null) {

      if (pdfData) {

        element?.replaceChildren();
        const divNode = element || document.createElement("div");
        const strPdfId = divNode.getAttribute("id");

        if (!strPdfId) {
          divNode.setAttribute("id", `pdf${generateUId()}`);
        }
        divNode.setAttribute("class", "embedded-local-pdf pdf-loading");
        divNode.setAttribute("contenteditable", "false");
        //divNode.setAttribute("data-pdf", pdfData);

        if (!element) UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);

        const pdfContainer = PDFObject.embed(pdfData, divNode, {
          height: "800px",
          pdfOpenParams: {
            navpanes: 1,
            view: "FitH",
            pagemode: "thumbs"
          }
        });
        function pdfLoad(event) {
          divNode.classList.remove("pdf-loading");
          pdfContainer.removeEventListener("load", pdfLoad);
        }
        pdfContainer.addEventListener("load", pdfLoad);
        divNode.appendChild(createRemover());
      }
    }

    async function insertPdfLink() {

      const url = (await showPrompt("PDF URL"))?.trim();
      if (!url) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextElementSibling;
      const divNode = document.createElement("div");
      divNode.setAttribute("id", `pdf${generateUId()}`);
      divNode.setAttribute("class", "pdf-link pdf-loading");
      divNode.setAttribute("contenteditable", "false");

      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);

      const pdfContainer = PDFObject.embed(url, divNode, {
        height: "800px",
        pdfOpenParams: {
          navpanes: 1,
          view: "FitH",
          pagemode: "thumbs"
        }
      });
      function pdfLoad(event) {
        divNode.classList.remove("pdf-loading");
        pdfContainer.removeEventListener("load", pdfLoad);
      }
      pdfContainer.addEventListener("load", pdfLoad);
      divNode.appendChild(createRemover());
    }

    async function insertTable(headless) {

      const dims = (await showPrompt((headless ? "Headless table" : "Table") + " rows and columns"))?.trim();
      if (!dims) return;
      // Split the input into the number of rows and columns
      let r1 = -1, r2 = -1, c1 = -1, c2 = -1, i = 0, l = dims.length;
      
      while (i < l) {

        if (dims[i] >= "0" && dims[i] <= "9") {
          if (r1 < 0) {
            r1 = i++;
            continue;
          }

          if (r2 > -1) {
            if (c1 < 0) {
              c1 = i++;
              continue;
            }
          }
        } else {
          if (r1 > -1) {
            if (r2 < 0) {
              r2 = i++;
              continue;
            }

            if (c1 > -1) {
              if (c2 < 0) {
                c2 = i++;
                break;
              }
            }
          }
        }
        ++i;
      }

      if (r1 < 0 || r2 < 0 || r1 === r2 || c1 < 0 || c1 === c2) {
        alert("Invalid input.");
        return;
      }

      if (c2 < 0) {
        c2 = l;
      }
      let rows = parseInt(dims.substring(r1, r2));
      const cols = parseInt(dims.substring(c1, c2));

      if (rows < 1 || cols < 1) {
        alert("Invalid input.");
        return;
      }
      let thead = "";

      if (!headless) {
        --rows;

        for (let i = 0; i < cols; ++i) {
          thead += `\n<th scope="col" contenteditable="true">Column&nbsp;${i + 1}</th>`;
        }
        thead = "<thead>\n<tr>" + thead + "\n</tr>\n</thead>";
      }
      let tbody = "";

      for (let i = 0; i < rows; ++i) {
        let tr = "";

        for (let j = 0; j < cols; ++j) {
          tr += '\n<td contenteditable="true"><br/></td>';
        }
        tr = "<tr>" + tr + "\n</tr>";
        tbody += `\n${tr}`;
      }
      tbody = "<tbody>" + tbody + "\n</tbody>";

      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextElementSibling;
      const divNode = document.createElement("div");
      divNode.setAttribute("id", `table${generateUId()}`);
      divNode.setAttribute("class", "embedded-table");
      divNode.setAttribute("contenteditable", "false");
      divNode.innerHTML = ['<table contenteditable="false">', thead, tbody, "</table>"].join("\n");

      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
      divNode.appendChild(createRemover());
    }

    function insertText() {

      const topNode = getTopLevelNodeOfCurrentPosition();
      const p = document.createElement("p");
      p.setAttribute("id", `text${generateUId()}`);
      p.setAttribute("class", "text-block");
      p.appendChild(document.createElement("br"));
      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, p, topNode?.nextElementSibling?.id);
      setCaret(p, 0);
    }

    function insertCode() {

      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextElementSibling;
      const divNode = document.createElement("div");
      const pre = document.createElement("pre");
      const code = document.createElement("code");
      code.setAttribute("contenteditable", "plaintext-only");
      code.appendChild(document.createElement("br"));
      pre.appendChild(code);
      divNode.appendChild(pre);
      divNode.setAttribute("id", `code${generateUId()}`);
      divNode.setAttribute("class", "code-block");
      divNode.setAttribute("contenteditable", "true");
      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
      setCaret(code, 0);
    }

    async function insertEmbeddedContent() {

      const iframeHtml = (await showPrompt("Embedded Page (iframe or URL)"))?.trim();
      if (!iframeHtml) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextElementSibling;
      const divNode = document.createElement("div");

      if (iframeHtml.length < "<IFRAME".length || !iframeHtml.toUpperCase().startsWith("<IFRAME")) {
        divNode.innerHTML = `<iframe src="${iframeHtml}" allow="fullscreen" width="100%" height="400"></iframe>`;
      } else {
        divNode.innerHTML = `${iframeHtml}`;
      }
      divNode.setAttribute("id", `embed${generateUId()}`);
      divNode.setAttribute("class", "embedded-content");
      divNode.setAttribute("contenteditable", "false");
      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
      divNode.appendChild(createRemover());
    }

    class AlignType {
      static #_LEFT = 0;
      static #_CENTER = 1;
      static #_RIGHT = 2;
      static #_JUSTIFY = 3;

      static get LEFT() { return this.#_LEFT; }
      static get CENTER() { return this.#_CENTER; }
      static get RIGHT() { return this.#_RIGHT; }
      static get JUSTIFY() { return this.#_JUSTIFY; }
    }

    const ALIGN_CLASSES = [["left-text", "left-align"], ["center-text", "center-align"], ["right-text", "right-align"], ["justify-text", "left-align"]];
    const ALIGN_CLASSES_FLAT = ALIGN_CLASSES.flat();

    function doAlign(alignType) {

      const selection = window.getSelection();

      if (!selection.rangeCount) return;
      const range = selection.getRangeAt(0);
      const nodeIds = [];
      const ALIGNABLE_NODE_CLASSES = ["text-block", "embedded-table", "embedded-content", "embedded-math", "embedded-local-image", "image-link"];

      function getNodeAlignmentClasses(node) {

        const alignmentClasses = [];

        for (let alignmentClass of ALIGN_CLASSES_FLAT) {
          if (node.classList?.contains(alignmentClass)) {
            alignmentClasses.push(alignmentClass);
          }
        }

        return alignmentClasses;
      }

      function applyNodeAlignmentClasses(node, alignClasses) {

        node.classList?.remove(...ALIGN_CLASSES_FLAT);

        for (let alignmentClass of alignClasses) {
          if (node.classList) node.classList.add(alignmentClass);
          else node.setAttribute("class", alignmentClass);
        }
      }

      function applyAlignment(node, alignmentClass) {

        node.classList?.remove(...ALIGN_CLASSES_FLAT);

        if (node.classList) node.classList.add(alignmentClass);
        else node.setAttribute("class", alignmentClass);
      }

      function getNodesAlignments(nodeIds) {

        nodeIds.forEach((nd) => {

          const node = document.getElementById(nd.id);

          if (!node) return;

          if (node.classList?.contains("text-block")) {
            nd.alignments = getNodeAlignmentClasses(node);
          } else if (node.classList?.contains("embedded-table")) {

            nd.alignments = new Map();

            for (let columnIndex of nd.idx) {

              const alignments = [];

              node.querySelectorAll(`tr th:nth-child(${columnIndex}), tr td:nth-child(${columnIndex})`)?.forEach((el) => {
                alignments.push(getNodeAlignmentClasses(el));
              });
              nd.alignments.set(columnIndex, alignments);
            }
          } else if (node.firstElementChild) {
            nd.alignments = getNodeAlignmentClasses(node);
          }
        });
      }

      function getSelectedTableColumnIndices(node, range) {

        if (node.classList?.contains("embedded-table")) {

          const columnIdxSet = new Set();
          const alignmentClass = ALIGN_CLASSES[alignType][0];
          node.querySelectorAll("th, td").forEach((child) => {

            if (range.intersectsNode(child)) {

              let columnIndex = 1;
              const nodeName = child.nodeName;

              while (child.previousSibling) {
                child = child.previousSibling;
                if (child.nodeName === nodeName) ++columnIndex;
              };
              columnIdxSet.add(columnIndex);
            }
          });

          return [...columnIdxSet];
        }

        return [];
      }

      function alignNodes(nodeIds, alignType) {

        nodeIds.forEach((nd) => {

          const node = document.getElementById(nd.id);

          if (!node) return;

          if (node.classList?.contains("text-block")) {
            applyAlignment(node, ALIGN_CLASSES[alignType][0]);
          } else if (node.classList?.contains("embedded-table")) {

            for (let columnIndex of nd.idx) {

              node.querySelectorAll(`tr th:nth-child(${columnIndex}), tr td:nth-child(${columnIndex})`)?.forEach((el) => {
                applyAlignment(el, ALIGN_CLASSES[alignType][0]);
              });
            }
          } else if (node.firstElementChild) {
            applyAlignment(node, ALIGN_CLASSES[alignType][1]);
          }
        });
      }

      function undoAlignNodes(nodeIds, _) {

        nodeIds.forEach((nd) => {

          const node = document.getElementById(nd.id);

          if (!node) return;

          if (node.classList?.contains("text-block")) {
            applyNodeAlignmentClasses(node, nd.alignments);
          } else if (node.classList?.contains("embedded-table")) {

            for (let columnIndex of nd.idx) {

              const alignments = nd.alignments.get(columnIndex);
              let i = 0;

              node.querySelectorAll(`tr th:nth-child(${columnIndex}), tr td:nth-child(${columnIndex})`)?.forEach((el) => {
                applyNodeAlignmentClasses(el, alignments[i++]);
              });
            }
          } else if (node.firstElementChild) {
            applyNodeAlignmentClasses(node, nd.alignments);
          }
        });
      }

      if (range) {

        if (range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {

          const node = getTopLevelNodeOf(range.startContainer, editor);

          if (node?.classList && [...node.classList].some(c => ALIGNABLE_NODE_CLASSES.indexOf(c) > -1))
            nodeIds.push({id: node.id, idx: getSelectedTableColumnIndices(node, range)});
        } else {

          let nodeStart = getTopLevelNodeOf(range.startContainer, editor);
          let nodeEnd = getTopLevelNodeOf(range.endContainer, editor);

          while (nodeStart) {

            if (nodeStart.classList && [...nodeStart.classList].some(c => ALIGNABLE_NODE_CLASSES.indexOf(c) > -1))
              nodeIds.push({id: nodeStart.id, idx: getSelectedTableColumnIndices(nodeStart, range)});
            
            if (nodeStart === nodeEnd) {

              nodeEnd = null;
              break;
            }

            nodeStart = nodeStart.nextElementSibling;
          }

          while (nodeEnd) {

            if (nodeEnd.classList && [...nodeEnd.classList].some(c => ALIGNABLE_NODE_CLASSES.indexOf(c) > -1))
              nodeIds.push({id: nodeEnd.id, idx: getSelectedTableColumnIndices(nodeEnd, range)});
            
            if (nodeStart === nodeEnd) break;

            nodeEnd = nodeEnd.previousElementSibling;
          }
        }
        getNodesAlignments(nodeIds);

        if (nodeIds.length > 0) UNDO_STACK.push(alignNodes, undoAlignNodes, nodeIds, alignType);
      }
    }

    // Toggles dropdown visibility
    function toggleDropdown(id) {

      const dropdown = document.getElementById(id);

      if (dropdown.classList.contains("show")) {
        dropdown.classList.remove("show");
      } else {
        // Close any open dropdowns first
        document.querySelectorAll(".dropdown-content, .text-dropdown-content, .page-dropdown").forEach(el => el.classList.remove("show"));
        dropdown.classList.add("show");
      }
    }

    // Closes dropdowns if clicking outside
    document.addEventListener("click", function (e) {

      if (!e.target.closest(".dropdown")) {
        document.querySelectorAll(".dropdown-content").forEach(el => el.classList.remove("show"));
      }

      if (!e.target.closest(".text-dropdown")) {
        document.querySelectorAll(".text-dropdown-content").forEach(el => el.classList.remove("show"));
      }

      if (!e.target.closest(".page-dropdown-toolbar-item") && !e.target.closest(".page-dropdown-header")) {
        document.querySelectorAll(".page-dropdown").forEach(el => el.classList.remove("show"));
      }
    });

    class BitArray {

      #_bitCount = 0;
      #_a;

      constructor(bitCount) {
        this.#_bitCount = bitCount;
        this.#_a = new Uint32Array(Math.ceil(bitCount / 32)).fill(0);
      }

      get length() {
        return this.#_bitCount;
      }

      get isZero() {

        const n = this.#_a.length;

        for (let i = 0; i < n; ++i) {
          if (this.#_a[i] !== 0) return false;
        }

        return true;
      }

      identical(ba) {

        if (this.#_a.length === ba.#_a.length) {

          const n = this.#_a.length;

          for (let i = 0; i < n; ++i) {
            if (this.#_a[i] !== ba.#_a[i]) return false;
          }
          return true;
        }
        
        return false;
      }

      clone() {

        const ba = new BitArray(this.#_bitCount);
        ba.#_a = Uint32Array.from(this.#_a);

        return ba;
      }

      // Set the i-th bit to 1
      set(i) {

        const bigIndex = Math.floor(i / 32);
        const smallIndex = i % 32;

        this.#_a[bigIndex] = this.#_a[bigIndex] | (1 << smallIndex);
      }

      // Clear the i-th bit
      clear(i) {

        const bigIndex = Math.floor(i / 32);
        const smallIndex = i % 32;

        this.#_a[bigIndex] = this.#_a[bigIndex] & (~(1 << smallIndex));
      }

      setValue(i, value) {

        if (value) set(i);
        else clear(i);
      }

      // Return the value of the i-th bit
      get(i) {

        const bigIndex = Math.floor(i / 32);
        const smallIndex = i % 32;

        const value = this.#_a[bigIndex] & (1 << smallIndex);
        // we convert to boolean to make sure the result is always 0 or 1,
        // instead of what is returned by the mask
        return value != 0;
      }

      bitOrAssign(ba) {

        const n = Math.min(this.#_a.length, ba.#_a.length);

        for (let i = 0; i < n; ++i) {
          this.#_a[i] |= ba.#_a[i];
        }

        return this;
      }

      bitOr(ba) {
        return this.clone().bitOrAssign(ba);
      }

      bitAndAssign(ba) {

        const n = Math.min(this.#_a.length, ba.#_a.length);

        for (let i = 0; i < n; ++i) {
          this.#_a[i] &= ba.#_a[i];
        }

        return this;
      }

      bitAnd(ba) {
        return this.clone().bitAndAssign(ba);
      }

      invertAssign() {

        const n = this.#_a.length;

        for (let i = 0; i < n; ++i) {
          this.#_a[i] = ~this.#_a[i];
        }

        return this;
      }

      invert() {
        return this.clone().invertAssign();
      }
    }

    // Helper: gets the node's text
    function getNodeText(node) {

      if (node) {
        return ((node.nodeType === Node.TEXT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
            ? (node.textContent ?? "") : ((node.nodeName === "BR") ? "\n" : (node.innerText ?? "")));
      }

      return "";
    }

    // For each node in the node tree returns the start and end positions in the text of the root node (specified as the argument)
    function getNodePositions(node) {

      const positions = new Map();
      let text = getNodeText(node);
      positions.set(node, {
        start: 0,
        end: text.length
      });
      const elements = [];
      node = node.hasChildNodes ? node.firstChild : null;

      while (node) {

        if (node.nodeType === Node.ELEMENT_NODE && node.hasChildNodes) {
          elements.push(...node.childNodes);
        }

        if (node.nodeType === Node.ELEMENT_NODE ||
            node.nodeType === Node.TEXT_NODE) {

          let prevSibling = node.previousSibling;

          while (prevSibling && !positions.has(prevSibling))
            prevSibling = prevSibling.previousSibling;

          text = getNodeText(node);
          const start = prevSibling ? positions.get(prevSibling).end : positions.get(node.parentNode).start;
          const end = start + text.length;

          positions.set(node, {
            start: start,
            end: end
          });

          while (node.nextSibling &&
                 node.nextSibling.nodeType !== Node.TEXT_NODE &&
                 node.nextSibling.nodeType !== Node.ELEMENT_NODE)
            node = node.nextSibling;
        }
        node = node.nextSibling ?? (elements.length > 0 ? elements.shift() : null);
      }

      return positions;
    }

    // Creates HTML text elements and BR elements from the specified text
    function createHtmlElementsFromText(text, start, end, callback) {

      const elements = text.split("\n");

      for (let i = 0; i < elements.length; i++) {
        elements[i] = document.createTextNode(elements[i]);
      }

      for (let i = elements.length - 1; i > 0; i--) {
        elements.splice(i, 0, document.createElement("br"));
      }

      if (start > -1 || end > -1) {

        let length = 0;
        let startNode = null, endNode = null, offsetStart = 0, offsetEnd = 0;

        for (let i = 0; i < elements.length; i++) {

          const currElementLength = ((elements[i].nodeName === "BR") ? 1 : elements[i].textContent.length);

          if (length <= start && start < length + currElementLength) {
            startNode = elements[i];
            offsetStart = start - length;
          }

          if (length < end && end <= length + currElementLength) {
            endNode = elements[i];
            offsetEnd = end - length;
          }

          length += currElementLength;
        }
        callback(startNode, endNode, offsetStart, offsetEnd);
      }
      
      return elements;
    }

    // The core function that does the styling
    // using binary indexed trees
    function wrapRangeText(range, styleIndex) {

      // Checks if the node has the specified tag, style properties and attributes
      function nodeHasSameStyle(node, tagName, style, attributes) {

        if (node?.nodeName === tagName) {

          let styleOk = true;

          if (style) {
            for (let property in style) {
              if (node.style[property] !== style[property]) {
                styleOk = false;
                break;
              }
            }
          }
          let attributesOk = true;

          if (attributes) {
            for (let attribute in attributes) {
              if (((!node.hasAttribute(attribute) || !node.getAttribute(attribute)) && attributes[attribute]) ||
                  node.getAttribute(attribute) !== attributes[attribute]) {
                attributesOk = false;
                break;
              }
            }
          }

          if (styleOk && attributesOk) return true;
        }

        return false;
      }

      // For each character in the root node text (having maxTextLength) gets the styles applied to it as a bit pattern
      // (the binary indexed tree implementation)
      function getStyledPositions(positions, styles, maxTextLength) {

        const styledPositions = new Array(maxTextLength + 1);

        for (let i = 0; i < maxTextLength + 1; i++)
          styledPositions[i] = new BitArray(styles.length);

        const a = new Int32Array(maxTextLength + 1);
        let styleIndex = 0;

        for (const style of styles) {

          const styleBitPattern = new BitArray(styles.length);
          styleBitPattern.set(styleIndex++);
          const entries = positions.entries().filter(([node, value]) => nodeHasSameStyle(node, style.tagName.toUpperCase(), style.style, style.attributes));
          a.fill(0);

          for (const [_, value] of entries) {
            a[value.start] += 1;
            a[value.end] -= 1;
          }

          for (let i = 0; i < a.length - 1; ++i) {

            a[i + 1] += a[i];

            if (a[i]) styledPositions[i].bitOrAssign(styleBitPattern);
          }
        }

        return styledPositions;
      }

      // determines which type of nodes are stylable (P or any direct child of TH or TD)
      function isSelectableNodeForStyling(node) {
        return node && (node.nodeName === "P" || isTableCell(node.parentNode));
      }

      // Gets the list of text positions of all the nodes within the root container and within the specified range
      function getSelectionPositions(rootContainer, range) {

        const selPositions = [];

        if (range) {

          if (range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {

            const node = getTopLevelNodeOf(range.startContainer, rootContainer);

            if (node) {

              const positions = getNodePositions(node);
              const start = positions.get(range.startContainer).start + range.startOffset;
              const end = start + range.endOffset - range.startOffset;
              selPositions.push({ node: node, start: start, end: end, positions: positions });
            }
          } else {

            let nodeStart = getTopLevelNodeOf(range.startContainer, rootContainer);
            let nodeEnd = getTopLevelNodeOf(range.endContainer, rootContainer);

            while (nodeStart &&
                   nodeStart !== nodeEnd &&
                   !isSelectableNodeForStyling(nodeStart))
              nodeStart = nodeStart.nextSibling;

            while (nodeEnd &&
                   nodeStart !== nodeEnd &&
                   !isSelectableNodeForStyling(nodeEnd))
              nodeEnd = nodeEnd.previousSibling;

            if (nodeStart && nodeEnd) {

              if (nodeStart === nodeEnd) {

                const positions = getNodePositions(nodeStart);
                const start = positions.get(range.startContainer).start + range.startOffset;
                const end = positions.get(range.endContainer).start + range.endOffset;
                selPositions.push({ node: nodeStart, start: start, end: end, positions: positions });
              } else {

                let positions = getNodePositions(nodeStart);
                let start = positions.get(range.startContainer).start + range.startOffset;
                let end = positions.get(nodeStart).end;
                selPositions.push({ node: nodeStart, start: start, end: end, positions: positions });

                let node = nodeStart.nextSibling;

                while (node && node !== nodeEnd) {

                  if (node.parentNode === rootContainer && isSelectableNodeForStyling(node)) {

                    positions = getNodePositions(node);
                    start = positions.get(node).start;
                    end = positions.get(node).end;
                    selPositions.push({ node: node, start: start, end: end, positions: positions });
                  }
                  node = node.nextSibling;
                }

                positions = getNodePositions(nodeEnd);
                start = positions.get(nodeEnd).start;
                end = positions.get(range.endContainer).start + range.endOffset;
                selPositions.push({ node: nodeEnd, start: start, end: end, positions: positions });
              }
            }
          }
        }

        return selPositions;
      }

      // Applies CSS style to the element
      function applyCss(element, style) {

        for (let property in style) {
          element.style[property] = style[property];
        }
      }

      // Creates the HTML node with the specified text and styles, having the specified parent
      function createHtmlNode(parentNode, text, styleBitPattern, start, end) {

        text = text.replace(/[\t ]/g, "\u00A0"); // "&emsp;" "&ensp;"
        let nodeStart = null, nodeEnd = null, startOffset = 0, endOffset = 0;

        function callback(startNode, endNode, offsetStart, offsetEnd) {

          if (!nodeStart) {
            nodeStart = startNode;
            startOffset = offsetStart;
          }

          if (!nodeEnd) {
            nodeEnd = endNode;
            endOffset = offsetEnd;
          }
        }

        if (styleBitPattern.isZero) {
          parentNode.append(...createHtmlElementsFromText(text, start, end, callback));
        } else {

          for (let i = 0; i < styleBitPattern.length; ++i) {

            if (styleBitPattern.get(i)) {

              const child = document.createElement(STYLES[i].tagName);
              
              if (STYLES[i].style) {
                applyCss(child, STYLES[i].style);
              }

              if (STYLES[i].attributes) {
                for (let attribute in STYLES[i].attributes) {
                  child.setAttribute(attribute, STYLES[i].attributes[attribute]);
                }
              }
              parentNode.appendChild(child);
              parentNode = child;
            }
          }
          parentNode.append(...createHtmlElementsFromText(text, start, end, callback));
        }

        return [nodeStart, nodeEnd, startOffset, endOffset];
      }

      // Rebuilds the HTML tree rooted at node and with the specified styles (specified as an array of style bit patterns, one style bit pattern for each character)
      function buildHtmlTree(node, styledPositions, start, end) {

        const text = getNodeText(node);
        const length = text.length;
        let p = 0;
        const frag = document.createDocumentFragment();
        let nodeStart = null, nodeEnd = null, startOffset = 0, endOffset = 0;

        for (let i = 1; i < length; ++i) {

          if (!styledPositions[i].identical(styledPositions[p])) {

            const s = (p <= start && start < i) ? start - p : -1;
            const e = (p < end && end <= i) ? end - p : -1;
            const [nodeStartTmp, nodeEndTmp, startOffsetTmp, endOffsetTmp] = createHtmlNode(frag, text.substring(p, i), styledPositions[p], s, e);
            p = i;

            if (!nodeStart) {
              nodeStart = nodeStartTmp;
              startOffset = startOffsetTmp;
            }

            if (!nodeEnd) {
              nodeEnd = nodeEndTmp;
              endOffset = endOffsetTmp;
            }
          }
        }

        if (p < length) {

          const s = (p <= start && start < length) ? start - p : -1;
          const e = (p < end && end <= length) ? end - p : -1;
          const [nodeStartTmp, nodeEndTmp, startOffsetTmp, endOffsetTmp] = createHtmlNode(frag, text.substring(p), styledPositions[p], s, e);

          if (!nodeStart) {
            nodeStart = nodeStartTmp;
            startOffset = startOffsetTmp;
          }

          if (!nodeEnd) {
            nodeEnd = nodeEndTmp;
            endOffset = endOffsetTmp;
          }
        }

        if (node.nodeType === Node.ELEMENT_NODE) {
          node.replaceChildren(frag);
        } else if (node.nodeType === Node.TEXT_NODE) {
          node.replaceWith(frag);
        }

        return [nodeStart, nodeEnd, startOffset, endOffset];
      }

      // gets the current range
      if (!range) {

        const selection = window.getSelection();

        if (selection?.rangeCount) {
          range = selection.getRangeAt(0);
        }
      }

      if (!range) return;

      // finds the current root container to work on
      let rootNode = range.commonAncestorContainer;
      let rootContainer = editor;

      while (rootNode && rootNode !== rootContainer) {

        if (isTableCell(rootNode)) {
          rootContainer = rootNode.parentNode;
          break;
        }
        rootNode = rootNode.parentNode;
      }
      // gets all the selected nodes within the root container as a list of start and end positions within each root container's direct child text
      const selPositions = getSelectionPositions(rootContainer, range);
      const styledPositions = [];
      let removeStyle = true;

      const styleBitPattern = new BitArray(STYLES.length);
      styleBitPattern.set(styleIndex); // the bit pattern of the style we want to apply over the selected text

      // for each root container's direct selected child we get the current styling (getStyledPositions)
      for (let p of selPositions) {

        const styled = getStyledPositions(p.positions, STYLES, p.positions.get(p.node).end);
        delete p.positions; // reclaiming some memory by discarding the positions array property

        for (let i = p.start; i < p.end; ++i) { // we compare with the current style pattern, if all the selected text contains the style completely it means we want to remove the styling
          if (styled[i].bitAnd(styleBitPattern).isZero) removeStyle = false; // if there area characters that don't have the style then we must apply the new style
        }                                                                    // otherwise we remove the style on all the characters in the range
        styledPositions.push(styled);
      }

      function cloneStyledPositions(styledPositions) {

        const clonedStyledPositions = new Array(styledPositions.length);

        for (let i = 0; i < styledPositions.length; i++) {

          clonedStyledPositions[i] = new Array(styledPositions[i].length);

          for (let j = 0; j < styledPositions[i].length; j++)
            clonedStyledPositions[i][j] = styledPositions[i][j].clone();
        }

        return clonedStyledPositions;
      }

      function applyStylePattern(selPositions, styledPositions, styleBitPattern, removeStyle) {

        const rangeNodes = [];
        styledPositions = cloneStyledPositions(styledPositions);

        if (removeStyle) { // if we want to remove the styling

          styleBitPattern = styleBitPattern.invert(); // we invert the current style bit pattern

          for (let i = 0; i < selPositions.length; ++i) { // for each root container's direct selected child text

            const styled = styledPositions[i];

            for (let j = selPositions[i].start; j < selPositions[i].end; ++j) {
              styled[j].bitAndAssign(styleBitPattern);      // we remove the style by applying the inverted bit pattern
            }                                               // to each of the characters' style pattern in the range
            const start = (i == 0) ? selPositions[i].start : -1;
            const end = (i == selPositions.length - 1) ? selPositions[i].end : -1;
            const [nodeStart, nodeEnd, startOffset, endOffset] = buildHtmlTree(selPositions[i].node, styled, start, end); // we rebuild the HTML tree rooted at node
            if (nodeStart || nodeEnd) rangeNodes.push([nodeStart, nodeEnd, startOffset, endOffset]);
          }
        } else {

          let styleGroupClearBitPattern = null; // if the current style is part of a style group, we create a clear styles bit pattern
                                                // to remove the other styles in the group applied to the selected text
                                                // (for example the text color styles, we don't want to apply multiple text colors over the same text)
          for (let styleGroup of STYLE_GROUPS) {

            if (styleIndex >= styleGroup[0] && styleIndex <= styleGroup[1]) {

              styleGroupClearBitPattern = new BitArray(STYLES.length);

              for (let i = styleGroup[0]; i <= styleGroup[1]; i++) {
                styleGroupClearBitPattern.set(i);
              }
              styleGroupClearBitPattern.invertAssign();  // we invert the bit pattern for all the styles in the group
              styleGroupClearBitPattern.set(styleIndex); // we let the current style bit pattern on
              break;
            }
          }

          for (let i = 0; i < selPositions.length; ++i) { // for each root container's direct selected child text

            const styled = styledPositions[i];

            for (let j = selPositions[i].start; j < selPositions[i].end; ++j) {
              if (styleGroupClearBitPattern) styled[j].bitAndAssign(styleGroupClearBitPattern); // we remove other style(s) in the same group with the current style, for each selected character
              styled[j].bitOrAssign(styleBitPattern);     // we apply the style by applying the style bit pattern
            }                                             // to each of the characters' style pattern in the range
            const start = (i == 0) ? selPositions[i].start : -1;
            const end = (i == selPositions.length - 1) ? selPositions[i].end : -1;
            const [nodeStart, nodeEnd, startOffset, endOffset] = buildHtmlTree(selPositions[i].node, styled, start, end); // we rebuild the HTML tree rooted at node
            if (nodeStart || nodeEnd) rangeNodes.push([nodeStart, nodeEnd, startOffset, endOffset]);
          }
        }
        window.getSelection().removeAllRanges(); // we remove all selection's ranges after HTML tree rebuild

        if (rangeNodes.length) {

          const range = document.createRange();
          range.setStart(rangeNodes[0][0], rangeNodes[0][2]);
          const i = (rangeNodes.length > 1) ? 1 : 0;
          range.setEnd(rangeNodes[i][1], rangeNodes[i][3]);
          window.getSelection().addRange(range);
        }
      }

      function doApply(selPositions, styledPositions, styleBitPattern, removeStyle) {
        applyStylePattern(selPositions, styledPositions, styleBitPattern, removeStyle);
      }

      function undoApply(selPositions, styledPositions, styleBitPattern, removeStyle) {
        applyStylePattern(selPositions, styledPositions, styleBitPattern, !removeStyle);
      }

      if (selPositions.length > 0) {
        UNDO_STACK.push(doApply, undoApply, selPositions, styledPositions, styleBitPattern, removeStyle);
      }
    }

    // Basic inline formatting: wraps the selection in the specified tag.
    function applyFormat(styleIndex) {

      const selection = window.getSelection();

      if (!selection.rangeCount || selection.isCollapsed) return;
      const range = selection.getRangeAt(0);

      if (!editor.contains(range.commonAncestorContainer)) return;
      updateLinkStyles(editor);
      wrapRangeText(range, styleIndex);
    }

    // Applies inline style (e.g., font-size, text color, background color) by wrapping the selection in a <span>.
    function applyStyle(styleIndex) {

      const selection = window.getSelection();

      if (!selection.rangeCount || selection.isCollapsed) return;
      const range = selection.getRangeAt(0);

      if (!editor.contains(range.commonAncestorContainer)) return;
      updateLinkStyles(editor);
      wrapRangeText(range, styleIndex);
    }

    // Applies inline url
    async function applyURL() {

      const selection = window.getSelection();

      if (!selection.rangeCount || selection.isCollapsed) return;
      const range = selection.getRangeAt(0);

      if (!editor.contains(range.commonAncestorContainer)) return;
      const url = (await showPrompt("URL"))?.trim();

      if (!url) return;
      updateLinkStyles(editor);
      let linkStyleIndex = STYLES.length - 1;

      for ( ; linkStyleIndex > STYLE_LINK_BASE_INDEX; linkStyleIndex--) {
        if (STYLES[linkStyleIndex].tagName === "a" &&
            STYLES[linkStyleIndex].attributes &&
            STYLES[linkStyleIndex].attributes["href"] === url) {
          break;
        }
      }

      if (linkStyleIndex <= STYLE_LINK_BASE_INDEX) {
        STYLES.push({tagName: "a", style: null, attributes: { "href": url }});
        linkStyleIndex = STYLES.length - 1;
      }

      wrapRangeText(range, linkStyleIndex);
    }

    // Called by the text scale dropdown.
    function applyFontScale(scale) {

      if (!scale) return;
      applyStyle(STYLE_FONT_BASE_INDEX + scale);
    }

    // Called when a text color swatch is clicked.
    function applyTextColor(color) {

      if (!color) return;
      applyStyle(STYLE_TEXT_COLOR_BASE_INDEX + color);
    }

    // Called when a highlight (background color) swatch is clicked.
    function applyHighlightColor(color) {

      if (!color) return;
      applyStyle(STYLE_HIGHLIGHT_COLOR_BASE_INDEX + color);
    }

    // Changes the nodes specified by their ids into the specified text level.
    // Used by the undo stack.
    function changeTextLevels(nodeIds, nodeTextLevelClasses, textLevelClass) {

      for (let i = 0; i < nodeIds.length; ++i) {

        const nodeId = nodeIds[i];
        const node = document.getElementById(nodeId);

        if (node) {

          const nodeTextLevelClass = nodeTextLevelClasses[i];

          if (node.classList?.contains(nodeTextLevelClass)) node.classList.remove(nodeTextLevelClass);

          if (textLevelClass !== "medium-text") {
            node.classList?.add(textLevelClass);
          }
        }
      }
    }

    // Changes the nodes specified by their ids back into the specified text levels.
    // Used by the undo stack.
    function undoChangeTextLevels(nodeIds, nodeTextLevelClasses, textLevelClass) {

      for (let i = 0; i < nodeIds.length; ++i) {

        const nodeId = nodeIds[i];
        const node = document.getElementById(nodeId);

        if (node) {

          if (node.classList?.contains(textLevelClass)) node.classList.remove(textLevelClass);

          const nodeTextLevelClass = nodeTextLevelClasses[i];

          if (nodeTextLevelClass !== "medium-text") {
            node.classList?.add(nodeTextLevelClass);
          }
        }
      }
    }

    const TEXT_LEVEL_CLASSES = ["xlarge-text", "large-text", "medium-text", "small-text"];

    // Converts the currently selected text blocks (direct children of #editor) to the chosen text level.
    function changeBlock(textLevelClass) {

      const selection = window.getSelection();

      if (!selection.rangeCount) return;
      const range = selection.getRangeAt(0);
      const nodeIds = [];

      function isSelectableNode(node) {

        const textLevelClasses = ["xlarge-text", "large-text", "small-text"];
        return node?.classList?.contains("text-block") &&
              (textLevelClass === "medium-text" ? [...node.classList].some(c => textLevelClasses.indexOf(c) > -1) :
                                                  !node.classList.contains(textLevelClass));
      }

      function getCurrentTextLevel(node) {

        for (let textLevelClass of TEXT_LEVEL_CLASSES) {
          if (node.classList.contains(textLevelClass)) return textLevelClass;
        }

        return "medium-text";
      }

      if (range) {

        if (range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {

          const node = getTopLevelNodeOf(range.startContainer, editor);

          if (isSelectableNode(node)) nodeIds.push(node.id);
        } else {

          let nodeStart = getTopLevelNodeOf(range.startContainer, editor);
          let nodeEnd = getTopLevelNodeOf(range.endContainer, editor);

          while (nodeStart) {

            if (isSelectableNode(nodeStart))
              nodeIds.push(nodeStart.id);
            
            if (nodeStart === nodeEnd) {

              nodeEnd = null;
              break;
            }

            nodeStart = nodeStart.nextElementSibling;
          }

          while (nodeEnd) {

            if (isSelectableNode(nodeEnd))
              nodeIds.push(nodeEnd.id);
            
            if (nodeStart === nodeEnd) break;

            nodeEnd = nodeEnd.previousElementSibling;
          }
        }
        const startContainer = range.startContainer;
        const endContainer = range.endContainer;
        const startContainerId = startContainer.id;
        const endContainerId = endContainer.id;
        const startOffset = range.startOffset;
        const endOffset = range.endOffset;
        const nodeTextLevelClasses = nodeIds.map((nodeId) => getCurrentTextLevel(document.getElementById(nodeId))) ?? [];

        if (nodeIds.length > 0) UNDO_STACK.push(changeTextLevels, undoChangeTextLevels, nodeIds, nodeTextLevelClasses, textLevelClass);

        range.setStart(startContainerId ? document.getElementById(startContainerId) : startContainer, startOffset);
        range.setEnd(endContainerId ? document.getElementById(endContainerId) : endContainer, endOffset);

        selection.removeAllRanges();
        selection.addRange(range);
      }
    }

    // Helper: Gets the last deepest child of the specified node
    function getLastDeepestChild(node) {

      if (!node) return node;

      while (node.lastChild) {

        node = node.lastChild;

        while (node.previousSibling &&
               node.nodeType === Node.TEXT_NODE &&
               !node.textContent.length)
          node = node.previousSibling;

        if (node.nodeName === "BR") break;
      }

      return node;
    }

    // Helper: Gets the specified node index in the parent's child nodes list
    function getChildNodeIndex(node) {

      if (!node) return -1;

      let index = 0;

      while (node.previousSibling) {

        ++index;
        node = node.previousSibling;
      }

      return index;
    }

    // Helper: Gets the specified element index in the parent's same type elements list
    function getSameTypeElementIndex(element) {

      if (!element) return -1;

      let index = 0;
      let elType = element.nodeName;

      while (element.previousElementSibling) {

        if (element.previousElementSibling.nodeName === elType) ++index;
        element = element.previousElementSibling;
      }

      return index;
    }

    function getNodeLimitOffset(node, offset, positions) {

      if (node.nodeType === Node.TEXT_NODE) {
        return (positions.has(node) ? positions.get(node).start : 0) + offset;
      } else if (node.nodeType === Node.ELEMENT_NODE) {

        let child = node.firstChild;
        let i = 0;
        let pos = (positions.has(node) ? positions.get(node).start : 0);

        while (child && i < offset) {

          if (positions.has(child)) pos = positions.get(child).end;

          child = child.nextSibling;
          ++i;
        }

        return pos;
      }

      return 0;
    }

    // Helper: Gets the range's absolute limits within the node's text
    function getRangeLimits(node, range) {

      const positions = getNodePositions(node);
      const start = getNodeLimitOffset(range.startContainer, range.startOffset, positions);
      const end = getNodeLimitOffset(range.endContainer, range.endOffset, positions);

      return {
        start: start,
        end: end
      };
    }

    function setRange(node, rangeLimits) {

      if (node.classList?.contains("code-block")) node = node.querySelector("code");

      const positions = getNodePositions(node);
      let startContainer = null;
      let startOffset = -1;
      let endContainer = null;
      let endOffset = -1;

      const nodes = [{node: node, visit: 0}];

      while (nodes.length > 0) {

        const nodeInfo = nodes.pop();

        if (nodeInfo.visit < 1 && nodeInfo.node.hasChildNodes) {

          nodeInfo.visit++;
          nodes.push(nodeInfo);
          nodes.push(...[...nodeInfo.node.childNodes].map((node) => { return { node: node, visit: 0 }; }));
        } else {

          if (positions.has(nodeInfo.node)) {
  
            const pos = positions.get(nodeInfo.node);

            if ((nodeInfo.node.nodeType === Node.TEXT_NODE && getNodeText(nodeInfo.node)) || nodeInfo.node.nodeName === "BR") {
            
              if (pos.start === rangeLimits.start ||
                  (pos.start < rangeLimits.start &&
                  rangeLimits.start < pos.end)) {

                if (nodeInfo.node.nodeName === "BR") {

                  startContainer = nodeInfo.node.parentNode;
                  startOffset = getChildNodeIndex(nodeInfo.node);
                } else {

                  startContainer = nodeInfo.node;
                  startOffset = rangeLimits.start - pos.start;
                }
              }

              if ((pos.start === rangeLimits.end &&
                  rangeLimits.start === rangeLimits.end) ||
                  (pos.start < rangeLimits.end &&
                  rangeLimits.end <= pos.end)) {

                if (nodeInfo.node.nodeName === "BR") {

                  endContainer = nodeInfo.node.parentNode;
                  endOffset = getChildNodeIndex(nodeInfo.node) + (pos.start === rangeLimits.end ? 0 : 1);
                } else {

                  endContainer = nodeInfo.node;
                  endOffset = rangeLimits.end - pos.start;
                }
              }
            }
          }
        }
      }

      if (startContainer || endContainer) {

        const range = document.createRange();
        if (startContainer) range.setStart(startContainer, startOffset);
        if (endContainer) range.setEnd(endContainer, endOffset);
        if (!startContainer) range.setStart(endContainer, endOffset);
        if (!endContainer) range.setEnd(startContainer, startOffset);
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);

        return range;
      }

      return null;
    }

    function doSplitBlock(newBlock, blockId, textTransformationSteps, _) {

      const block = document.getElementById(blockId);

      if (!block) return;

      const afterBlockContents = applyTextTransformationSteps(block.innerHTML, textTransformationSteps);

      if (block.innerHTML !== afterBlockContents) {
        block.innerHTML = afterBlockContents;
      }

      editorInsertBefore(newBlock, block.nextElementSibling?.id);
    }

    function undoSplitBlock(newBlock, blockId, textTransformationSteps, savedRangeLimits) {

      const block = document.getElementById(blockId);

      if (!block) return;

      editorRemoveChild(newBlock, null);

      const savedBlockContents = applyTextTransformationSteps(block.innerHTML, textTransformationSteps, true);

      if (block.innerHTML !== savedBlockContents) {
        block.innerHTML = savedBlockContents;
      }
      setRange(block, savedRangeLimits);
    }

    // Splits the current block at the caret.
    function splitBlock(range) {

      if (!range || !window.getSelection().isCollapsed) return;
      let block = range.startContainer;

      while (block && block.parentNode !== editor) {
        block = block.parentNode;
      }

      if (!block) { // adds a new empty text block (paragraph) at the end of the document

        const p = document.createElement("p");
        p.setAttribute("id", `text${generateUId()}`);
        p.setAttribute("class", "text-block");
        p.innerHTML = "<br/>";
        UNDO_STACK.push(editorInsertBefore, editorRemoveChild, p, null);
        return;
      }
      const savedBlockContents = block.innerHTML;
      const savedRangeLimits = getRangeLimits(block, range);

      const isTextBlock = block.classList?.contains("text-block");
      const newBlock = document.createElement(isTextBlock ? block.nodeName.toLowerCase() : "p");
      newBlock.setAttribute("id", `text${generateUId()}`);
      newBlock.setAttribute("class", isTextBlock ? block.getAttribute("class") : "text-block");

      const startContainer = range.startContainer;
      const extractRange = range.cloneRange();
      extractRange.setEndAfter(block.lastChild || block);
      const extracted = extractRange.extractContents(); // selects all content from start of caret to end of current block

      if (!extracted.childNodes.length) { // this should not happen: this means the caret is at the end of current block
        newBlock.innerHTML = "<br/>";
      } else {

        newBlock.appendChild(extracted);
        const ldc = getLastDeepestChild(newBlock);

        if (ldc?.nodeName !== "BR") {

          if (ldc.nodeType === Node.ELEMENT_NODE) {
            ldc.appendChild(document.createElement("br"));
          } else if (ldc.nodeType === Node.TEXT_NODE) {
            if (ldc.parentNode.nodeName !== "BR") ldc.parentNode.appendChild(document.createElement("br"));
            else ldc.parentNode.parentNode.appendChild(document.createElement("br"));
          } else {
            newBlock.appendChild(document.createElement("br"));
          }
        }
      }
      const ldc = getLastDeepestChild(block);

      if (ldc.nodeName !== "BR" || ldc !== startContainer) {

        if (ldc.nodeType === Node.TEXT_NODE || ldc.nodeName === "BR") {
          if (ldc.parentNode.nodeName !== "BR") ldc.parentNode.appendChild(document.createElement("br"));
          else ldc.parentNode.parentNode.appendChild(document.createElement("br"));
        } else if (ldc.nodeType === Node.ELEMENT_NODE) {
          ldc.appendChild(document.createElement("br"));
        } else {
          block.appendChild(document.createElement("br"));
        }
      }
      const afterBlockContents = block.innerHTML;

      if (savedBlockContents !== block.innerHTML) block.innerHTML = savedBlockContents;

      if (savedBlockContents !== afterBlockContents)
        UNDO_STACK.push(doSplitBlock, undoSplitBlock, newBlock, block.id, getTextTransformationSteps(savedBlockContents, afterBlockContents), savedRangeLimits);
    }

    // Normalizes stray text nodes and nested blocks.
    function normalizeEditor() {

      Array.from(editor.childNodes).forEach(node => {

        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {

          const p = document.createElement("p");
          p.setAttribute("id", `text${generateUId()}`);
          p.setAttribute("class", "text-block");
          p.textContent = node.textContent;
          editor.replaceChild(p, node);
        }
      });
      editor.querySelectorAll("p p, h1 p, h2 p, h3 p, h4 p, h5 p, h6 p, p font, small p").forEach(nested => {

        const parent = nested.parentNode;

        if (!parent.id && nested.childElementCount === 1) {

          parent.insertBefore(nested.firstChild, nested);
          parent.removeChild(nested);
          parent.id = nested.id;
          return ;
        }

        while (nested.firstChild) {
          parent.insertBefore(nested.firstChild, nested);
        }
        parent.removeChild(nested);
      });
    }

    // Normalize stray text nodes and nested blocks.
    function cleanEditor() {

      if (editor.firstChild && editor.firstChild.nodeName === "P") {
        return;
      }
      const htmlText = editor.innerHTML.trim();

      if (htmlText === "" || htmlText === "<br>" || htmlText === "<br/>") {
        editor.innerHTML = `<p class="text-block" id="text${generateUId()}"><br/></p>`;
      }
    }

    function updateTitle() {

      if (filename.innerHTML === "<br>" || filename.innerHTML === "<br/>") {
        filename.innerHTML = "";
      }

      document.title = filename.innerHTML.trim() || "Nash Note";
    }

    function handleEnterKey(range, validParentNodeCallback) {

      let block = range?.startContainer;

      while (block && block !== editor) {

        if (block.nodeType === Node.ELEMENT_NODE && validParentNodeCallback(block)) {

          const savedContents = block.innerHTML;
          const savedRangeLimits = getRangeLimits(block, range);
          let newRange = null;

          const textNode = range.startContainer;
          const parentNode = textNode.parentNode;

          if (textNode.nodeName === "BR") {

            const brNode = document.createElement("br");
            parentNode.insertBefore(brNode, textNode.nextSibling);
            newRange = setCaretAfter(brNode);
          } else if (validParentNodeCallback(textNode) || textNode.nodeType === Node.ELEMENT_NODE) {

            const brNode = document.createElement("br");

            if (textNode.childNodes.length > range.startOffset) {
              textNode.insertBefore(brNode, textNode.childNodes[range.startOffset]);
            } else {
              textNode.appendChild(brNode);
            }
            newRange = setCaretAfter(brNode);
          } else if (textNode.nodeType === Node.TEXT_NODE) {

            const text1 = textNode.textContent.substring(0, range.startOffset);
            const text2 = textNode.textContent.substring(range.startOffset);
            const newTextNode = text2?.length ? document.createTextNode(text2) : null;
            const nextSibling = textNode.nextSibling;
            const brNode = document.createElement("br");
            parentNode.insertBefore(brNode, nextSibling);

            if (text1?.length) {

              if (textNode.textContent !== text1) {
                textNode.textContent = text1;
              }
            } else {
              parentNode.removeChild(textNode);
            }

            if (newTextNode) {

              parentNode.insertBefore(newTextNode, nextSibling);
              newRange = setCaret(newTextNode, 0);
            } else if (text1?.length) {

              if (!nextSibling) {

                if (validParentNodeCallback(parentNode)) {

                  const brNode2 = document.createElement("br");
                  parentNode.insertBefore(brNode2, nextSibling);
                  newRange = setCaretAfter(brNode2);
                } else {
                  let p = parentNode;
                  while (p && !p.nextSibling) p = p.parentNode;
                  if (p?.nextSibling) newRange = setCaret(p.nextSibling, 0);
                }
              } else {
                newRange = setCaret(parentNode, getChildNodeIndex(nextSibling));
              }
            } else {

              const brNode2 = document.createElement("br");
              parentNode.insertBefore(brNode2, nextSibling);
              newRange = setCaretAfter(brNode2);
            }
          }

          if (!newRange && window.getSelection().rangeCount) {
            newRange = window.getSelection().getRangeAt(0);
          }
          const afterContents = block.innerHTML;
          const afterRangeLimits = newRange ? getRangeLimits(block, newRange) : savedRangeLimits;
          
          if (savedContents !== block.innerHTML) block.innerHTML = savedContents;

          if (savedContents !== afterContents) UNDO_STACK.push(doChangeText, undoChangeText, block, getTextTransformationSteps(savedContents, afterContents), savedRangeLimits, afterRangeLimits);

          return true;
        }
        block = block.parentNode;
      }

      return false;
    }

    function removeTextBlock(node, _, previousSiblingId) {

      const selection = window.getSelection(); // remove all selections
      selection.removeAllRanges();
      node.remove();
      const sibling = previousSiblingId ? document.getElementById(previousSiblingId) : null;

      if (sibling) {

        let lastChild = null; // get the last deepest child of the text or code block

        if (sibling.classList?.contains("code-block")) {
          lastChild = getLastDeepestChild(sibling.querySelector("code"));
        } else {
          lastChild = getLastDeepestChild(sibling);
        }

        if (lastChild) setCaret(lastChild, lastChild.textContent?.length ?? 0); // and set the caret at the end of it
      } else {
        editor.focus();
      }
    }

    function cancelEvent(e) {

      e.stopImmediatePropagation();
      e.preventDefault();
    }

    function handleBackspaceInEmptyTextContent(topNode, e) {

      let shouldHandle = topNode.classList?.contains("code-block") &&
                         topNode.firstChild.nodeName === "PRE" &&
                         (!topNode.textContent?.length || topNode.textContent === "\n" || topNode.innerText === "\n");
      shouldHandle = shouldHandle || (topNode.classList?.contains("text-block") && (!topNode.innerText?.length || topNode.innerText === "\n"));

      if (shouldHandle) { // if the node is empty

        cancelEvent(e);  // cancel the event
        let sibling = topNode.previousElementSibling; // find a previous text or code sibling node to move the focus to (the cursor caret)

        while (sibling &&
              !sibling.classList?.contains("text-block") &&
              !sibling.classList?.contains("code-block")) {
          sibling = sibling.previousElementSibling;
        }

        if (sibling) {   // if a sibling was found
          UNDO_STACK.push(removeTextBlock, editorInsertBefore, topNode, topNode.nextElementSibling?.id, sibling.id);
        }

        return true; // node with empty text was handled
      }

      return false;
    }

    function removeLastBr(node) {

      let lastChild = node.lastChild;

      while (lastChild) { // search for a last BR child, if any

        while (lastChild &&
               (lastChild.nodeType !== Node.ELEMENT_NODE || !lastChild.lastChild) && // skip last empty text or element nodes
               !getNodeText(lastChild).length) {
          lastChild = lastChild.previousSibling;
        }

        if (lastChild &&
            lastChild.nodeName !== "BR" && // if last child found is not BR and has a last child subnode (and also non-empty text contents)
            lastChild.lastChild) {
          lastChild = lastChild.lastChild; // then search for a last BR subchild in this last child subnode
        } else {
          break;
        }
      }

      if (lastChild?.nodeName === "BR") lastChild.remove();
    }

    function joinAdjacentTextBlocks(textBlockNode, _, _2, textBlockPreviousNodeId) {

      const previousElementSibling = textBlockPreviousNodeId ? document.getElementById(textBlockPreviousNodeId) : null;

      if (!previousElementSibling) return;

      const innerHtml = textBlockNode.innerHTML;
      removeLastBr(previousElementSibling);
      const focusChild = textBlockNode.firstChild;
      previousElementSibling.append(...textBlockNode.childNodes);
      textBlockNode.remove();
      textBlockNode.innerHTML = innerHtml;
      
      if (focusChild) setCaret(focusChild, 0);
    }

    function undoJoinAdjacentTextBlocks(textBlockNode, nextSiblingId, textBlockPreviousSavedContents, textBlockPreviousNodeId) {

      const previousElementSibling = textBlockPreviousNodeId ? document.getElementById(textBlockPreviousNodeId) : null;

      if (!previousElementSibling) return;

      previousElementSibling.innerHTML = textBlockPreviousSavedContents;
      editorInsertBefore(textBlockNode, nextSiblingId);
    }

    function isCaretAtStart(node, range) {

      if (range.startContainer === range.endContainer &&
          range.startOffset === range.endOffset) {

        if (range.startOffset === 0) {
          return true;
        } else if (range.startContainer === node) {

          const childNodes = [...node.childNodes];

          for (let i = 0; i < range.startOffset && i < childNodes.length; i++) {

            if (childNodes[i].nodeType !== Node.TEXT_NODE || childNodes[i].textContent.length > 0) {
              return false;
            }
          }

          return true;
        }
      }

      return false;
    }

    function isCaretAtEnd(node, range) {

      if (range.startContainer === range.endContainer &&
          range.startOffset === range.endOffset) {

        if (range.endContainer === node) {

          const childNodes = [...node.childNodes];

          if (childNodes.length > 0 && range.endOffset > -1) {

            let brCount = 0;

            for (let i = range.endOffset; i < childNodes.length; i++) {

              const child = childNodes[i];

              if (child.nodeName === "BR") {

                ++brCount;

                if (brCount > 1) return false;
              } else if (getNodeText(child).length > 0) {
                return false;
              }
            }
          }
        } else {

          if (range.endContainer.nodeType === Node.TEXT_NODE) {

            const textLength = getNodeText(range.endContainer).length;

            if (textLength > 0 && range.endOffset < textLength) {
              return false;
            }
          }
          let p = range.endContainer;

          while (p !== node) {

            let brCount = (p.nodeName === "BR") ? 1 : 0;

            while (p.nextSibling) {

              if (p.nextSibling.nodeName === "BR") {

                ++brCount;

                if (brCount > 1) return false;
              } else if (getNodeText(p.nextSibling).length > 0) {
                return false;
              }
              p = p.nextSibling;
            }
            p = p.parentNode;
          }
        }
      } else {
        return false;
      }

      return true;
    }

    function isTableCell(node) {
      return node && (node.nodeName === "TH" || node.nodeName === "TD");
    }

    // Determines if the node is a node that contains text that can be edited
    function isEditableTextNode(node) {
      return node && (node.classList?.contains("text-block") || node.classList?.contains("code-block") || isTableCell(node));
    }

    function isTableNode(node) {
      return node && node.classList?.contains("embedded-table");
    }

    function getTableCell(node) {

      while (node) {

        if (isTableCell(node)) return node;
        if (node.parentNode === editor) return null;
        node = node.parentNode;
      }

      return null;
    }

    // Gets the list of all nodes and text positions of the start and end nodes within the root container and within the specified range
    function getSelectionNodesAndPositions(rootContainer, range) {

      const selPositions = [];

      if (range) {

        if (range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {

          const node = getTopLevelNodeOf(range.startContainer, rootContainer);

          if (node) {

            const positions = getNodePositions(node);
            const start = positions.get(range.startContainer).start + range.startOffset;
            const end = start + range.endOffset - range.startOffset;
            selPositions.push({ node: node, start: start, end: end, positions: positions });
          }
        } else {

          let nodeStart = getTopLevelNodeOf(range.startContainer, rootContainer);
          let nodeEnd = getTopLevelNodeOf(range.endContainer, rootContainer);

          if (nodeStart && nodeEnd) {

            if (nodeStart === nodeEnd) {

              if (isEditableTextNode(nodeStart)) {

                const positions = getNodePositions(nodeStart);
                const start = positions.get(range.startContainer).start + range.startOffset;
                const end = positions.get(range.endContainer).start + range.endOffset;
                selPositions.push({ node: nodeStart, start: start, end: end, positions: positions });
              } else {
                selPositions.push({ node: nodeStart });
              }
            } else {

              if (isEditableTextNode(nodeStart)) {

                const positions = getNodePositions(nodeStart);
                const start = positions.get(range.startContainer).start + range.startOffset;
                const end = positions.get(nodeStart).end;
                selPositions.push({ node: nodeStart, start: start, end: end, positions: positions });
              } else {
                selPositions.push({ node: nodeStart });
              }

              let node = nodeStart.nextElementSibling;

              while (node && node !== nodeEnd) {

                if (node.parentNode === rootContainer) {

                  if (isEditableTextNode(node)) {

                    const positions = getNodePositions(node);
                    const start = positions.get(node).start;
                    const end = positions.get(node).end;
                    selPositions.push({ node: node, start: start, end: end, positions: positions });
                  } else {
                    selPositions.push({ node: node });
                  }
                }
                node = node.nextElementSibling;
              }

              if (isEditableTextNode(nodeEnd)) {

                const positions = getNodePositions(nodeEnd);
                const start = positions.get(nodeEnd).start;
                const end = positions.get(range.endContainer).start + range.endOffset;
                selPositions.push({ node: nodeEnd, start: start, end: end, positions: positions });
              } else {
                selPositions.push({ node: nodeEnd });
              }
            }
          }
        }
      }

      return selPositions;
    }

    function makeNodeId(node) {

      if (isTableCell(node)) {

        if (node.cellId) return node.cellId;

        let child = node;
        let tr = null;

        while (child && !isTableNode(child.parentNode)) {

          child = child.parentNode;

          if (child.nodeName === "TR") tr = child;
        }

        if (child?.parentNode) {

          const table = child.parentNode;
          const tid = table.id;
          const trIdx = tr ? (getSameTypeElementIndex(tr) + 1) : null;

          if (trIdx) {

            const cellIdx = getSameTypeElementIndex(node) + 1;
            node.cellId = `#${tid} tr:nth-of-type(${trIdx}) ${node.nodeName.toLowerCase()}:nth-of-type(${cellIdx})`;

            return node.cellId;
          }
        }

        return null;
      }

      return node?.id;
    }

    function getNodeFromId(nodeId) {

      return nodeId ? (nodeId.includes(" ") ? document.querySelector(nodeId) : document.getElementById(nodeId)) : null;
    }

    function replaceSelectedContent(firstNodeId, removeNodes, nextElementSiblingId, textTransformationSteps, newTextBlock, _2, newRangeLimits) {

      for (let node of removeNodes) {
        editorRemoveChild(node);
      }
      const firstNode = getNodeFromId(firstNodeId);

      if (firstNode) {

        const afterContents = applyTextTransformationSteps(firstNode.innerHTML, textTransformationSteps);

        if (firstNode.innerHTML !== afterContents) firstNode.innerHTML = afterContents;
        setRange(firstNode, newRangeLimits);
      }

      if (newTextBlock) {

        editorInsertBefore(newTextBlock, nextElementSiblingId);
        setRange(newTextBlock, newRangeLimits);
      }
    }

    function undoReplaceSelectedContent(firstNodeId, removeNodes, nextElementSiblingId, textTransformationSteps, newTextBlock, oldRangeLimits, _2) {

      if (newTextBlock) {
        editorRemoveChild(newTextBlock);
      }
      const firstNode = getNodeFromId(firstNodeId);

      if (firstNode) {

        const savedContents = applyTextTransformationSteps(firstNode.innerHTML, textTransformationSteps, true);

        if (firstNode.innerHTML !== savedContents) firstNode.innerHTML = savedContents;
      }
      let nextSiblingId = nextElementSiblingId;

      for (let i = removeNodes.length - 1; i > -1; i--) {

        editorInsertBefore(removeNodes[i], nextSiblingId);
        nextSiblingId = removeNodes[i].id;
      }

      // set the selection range

      let startContainer = null;
      let startOffset = 0;
      let endOffset = 0;

      if (isEditableTextNode(firstNode)) {

        startContainer = firstNode.classList?.contains("code-block") ? firstNode.querySelector("code") : firstNode;
        const range = setRange(startContainer, { start: oldRangeLimits.start, end: (removeNodes.length > 0 ? oldRangeLimits.start : oldRangeLimits.end) });

        if (range) {

          startContainer = range.startContainer;
          startOffset = range.startOffset;
          endOffset = range.endOffset;
        }
      } else {

        startContainer = firstNode.parentNode;
        startOffset = getChildNodeIndex(firstNode);
      }
      let endContainer = startContainer;

      if (removeNodes.length > 0) {

        const lastNode = removeNodes[removeNodes.length - 1];

        if (lastNode && lastNode !== firstNode) {

          if (isEditableTextNode(lastNode)) {

            endContainer = lastNode.classList?.contains("code-block") ? lastNode.querySelector("code") : lastNode;
            const range = setRange(endContainer, { start: oldRangeLimits.end, end: oldRangeLimits.end });

            if (range) {
              endContainer = range.endContainer;
              endOffset = range.endOffset;
            }
          } else if (lastNode) {

            endContainer = lastNode.parentNode;
            endOffset = getChildNodeIndex(lastNode) + 1;
          }
        }
      }

      if (startContainer && endContainer) {

        const range = document.createRange();
        range.setStart(startContainer, startOffset);
        range.setEnd(endContainer, endOffset);
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);
      }
    }

    function htmlTextToChildNodesArray(text) {

      const template = document.createElement("template");
      template.innerHTML = text.trim();
      return [...template.content.childNodes].filter((node) => node.nodeName !== "META");
    }

    function htmlTextToPlainText(html) {

      const divNode = document.createElement("div");
      divNode.innerHTML = html;

      return getNodeText(divNode);
    }

    function insertTextInRange(text, range, isHtml = false) {

      let htmlNodes = null;

      if (isHtml) {

        let transformToPlainText = false;
        let p = range.startContainer;

        while (p && p !== editor) {

          if (p.nodeName === "CODE") { // inserting html in code blocks is not allowed
            transformToPlainText = true;
            break;
          }
          p = p.parentNode;
        }

        if (transformToPlainText) {

          text = htmlTextToPlainText(text);
          isHtml = false;
        } else {

          htmlNodes = htmlTextToChildNodesArray(text);
          text = "";
        }
      } else {
        text = text.replace(/[\t ]/g, "\u00A0");
      }

      function getOffsetAtEnd(node) {

        if (node.nodeType === Node.TEXT_NODE) {

          return getNodeText(node).length;
        } else if (node.nodeType === Node.ELEMENT_NODE) {

          if (node.nodeName === "BR") return 1;

          return node.childNodes.length;
        }

        return 0;
      }

      if (range.startContainer.nodeType === Node.TEXT_NODE) {

        const nodes = htmlNodes ?? createHtmlElementsFromText(text, -1, -1, null);
        let textContent = range.startContainer.textContent;

        if (nodes.length === 1) {

          if (nodes[0].nodeType === Node.TEXT_NODE) {

            text = getNodeText(nodes[0]);
            const endRangeOffset = range.startOffset + text.length;
            textContent = textContent.substring(0, range.startOffset) + text + textContent.substring(range.startOffset);
            if (textContent !== range.startContainer.textContent) range.startContainer.textContent = textContent;

            return { node: range.startContainer, offset: endRangeOffset };
          } else if (nodes[0].nodeType === Node.ELEMENT_NODE) {

            const parentNode = range.startContainer.parentNode;
            const startContent = textContent.substring(0, range.startOffset);
            const endContent = textContent.substring(range.startOffset);
            const nextSibling = range.startContainer.nextSibling;

            if (startContent !== range.startContainer.textContent) range.startContainer.textContent = startContent;
            parentNode.insertBefore(nodes[0], nextSibling);

            if (endContent) {
              parentNode.insertBefore(document.createTextNode(endContent), nextSibling);
            }

            return { node: nodes[0], offset: getOffsetAtEnd(nodes[0]) };
          }
        } else if (nodes.length > 1) {

          const parentNode = range.startContainer.parentNode;
          const startContent = textContent.substring(0, range.startOffset);
          const endContent = textContent.substring(range.startOffset);
          const nextSibling = range.startContainer.nextSibling;

          textContent = startContent;
          let i = 0;

          while (i < nodes.length && nodes[i].nodeType === Node.TEXT_NODE) {

            textContent += getNodeText(nodes[i]);
            ++i;
          }

          for (let j = i; j < nodes.length; ++j) {
            parentNode.insertBefore(nodes[j], nextSibling);
          }

          if (i < nodes.length) {

            if (textContent !== range.startContainer.textContent) range.startContainer.textContent = textContent;

            const lastNode = nodes[nodes.length - 1];

            if (lastNode.nodeType === Node.TEXT_NODE) {

              let lastText = getNodeText(lastNode);
              const offset = lastText.length;
              lastText += endContent;

              if (lastText !== lastNode.textContent) lastNode.textContent = lastText;

              return { node: lastNode, offset: offset };
            } else if (endContent) {

              parentNode.insertBefore(document.createTextNode(endContent), nextSibling);
            }

            return { node: lastNode, offset: getOffsetAtEnd(lastNode) };
          } else {

            const offset = textContent.length;
            textContent += endContent;

            if (textContent !== range.startContainer.textContent) range.startContainer.textContent = textContent;

            return { node: range.startContainer, offset: offset };
          }
        }
      } else if (range.startContainer.nodeType === Node.ELEMENT_NODE) {

        const nodes = htmlNodes ?? createHtmlElementsFromText(text, -1, -1, null);

        if (nodes.length > 0) {

          nodes.reverse();
          nodes.forEach((node) => range.insertNode(node));
          const lastNode = nodes[0];

          return { node: lastNode, offset: getOffsetAtEnd(lastNode) };
        }
      }

      return null;
    }

    function doChangeText(node, textTransformationSteps, _, afterRangeLimits) {

      if (node) {

        const afterContents = applyTextTransformationSteps(node.innerHTML, textTransformationSteps);

        if (node.innerHTML !== afterContents) node.innerHTML = afterContents;
        setRange(node, afterRangeLimits);
      }
    }

    function undoChangeText(node, textTransformationSteps, savedRangeLimits, _,) {

      if (node) {

        const savedContents = applyTextTransformationSteps(node.innerHTML, textTransformationSteps, true);

        if (node.innerHTML !== savedContents) node.innerHTML = savedContents;
        setRange(node, savedRangeLimits);
      }
    }

    function sanitizeEditableTextNode(node) {

      const contentNode = node.classList?.contains("code-block") ? node.querySelector("code") : node;

      if (getNodeText(contentNode)) {

        const emptyChildren = [];
        let child = contentNode.firstChild;

        while (child) {

          if (!getNodeText(child)) emptyChildren.push(child);
          child = child.nextSibling;
        }
        emptyChildren.forEach((node) => node.remove());
      } else {
        contentNode.innerHTML = "<br/>";
      }
    }

    function handleTextInsertion(text, range, topNode, isHtml = false) {

      if (isTableNode(topNode)) {

        topNode = getTableCell(range.startContainer);
        if (!topNode) return;
      }
      const savedContents = topNode.innerHTML;
      const savedRangeLimits = getRangeLimits(topNode, range);
      const insertion = insertTextInRange(text, range, isHtml);

      if (insertion) {

        range.setStart(insertion.node, insertion.offset);
        range.setEnd(insertion.node, insertion.offset);
        window.getSelection().collapseToEnd();
      } else {
        return;
      }
      sanitizeEditableTextNode(topNode);
      const afterContents = topNode.innerHTML;
      const afterRangeLimits = getRangeLimits(topNode, range);

      if (savedContents !== topNode.innerHTML) topNode.innerHTML = savedContents;

      if (savedContents !== afterContents) UNDO_STACK.push(doChangeText, undoChangeText, topNode, getTextTransformationSteps(savedContents, afterContents), savedRangeLimits, afterRangeLimits);
    }

    function handleTextDeletion(range, topNode, usingBackspace) {

      if (isTableNode(topNode)) {

        topNode = getTableCell(range.startContainer);
        if (!topNode) return;
      }
      const savedContents = topNode.innerHTML;
      const savedRangeLimits = getRangeLimits(topNode, range);
      const delRangeLimits = { start: savedRangeLimits.start + (usingBackspace ?  - 1 : 0), end: savedRangeLimits.end + (usingBackspace ? 0 : 1) };
      const delRange = setRange(topNode, delRangeLimits);

      if (delRange) {

        delRange.deleteContents();
        window.getSelection().collapseToStart();

        sanitizeEditableTextNode(topNode);
        const afterContents = topNode.innerHTML;
        const afterRangeLimits = getRangeLimits(topNode, delRange);

        if (savedContents !== topNode.innerHTML) topNode.innerHTML = savedContents;

        if (savedContents !== afterContents) UNDO_STACK.push(doChangeText, undoChangeText, topNode, getTextTransformationSteps(savedContents, afterContents), savedRangeLimits, afterRangeLimits);
      }
    }

    function handleMultiSelection(text, isHtml = false) {

      let range = null;
      const selection = window.getSelection();

      if (selection.rangeCount) {
        range = selection.getRangeAt(0);
      }

      if (range && !selection.isCollapsed) {

        // finds the current root container to work on
        let rootNode = range.commonAncestorContainer;
        let rootContainer = editor;

        while (rootNode && rootNode !== rootContainer) {

          if (isTableCell(rootNode)) {
            rootContainer = rootNode.parentNode;
            break;
          }
          rootNode = rootNode.parentNode;
        }
        // gets all the selected nodes within the root container as a list of start and end positions within each root container's direct child text
        const selections = getSelectionNodesAndPositions(rootContainer, range);

        if (selections.length) {

          let removeNodes = [];
          let savedContents = null;
          let firstNodeId = null;
          let lastContent = null;
          let newCaretPosition = selections[0].start;
          const oldRangeLimits = { start: selections[0].start, end: selections[selections.length - 1].end };
          const firstNode = selections[0].node;


          if (selections.length === 1) {

            if (isEditableTextNode(firstNode)) {

              savedContents = firstNode.innerHTML;
              firstNodeId = makeNodeId(firstNode);
              selection.deleteFromDocument();

              if (text) {

                const insertion = insertTextInRange(text, range, isHtml);

                if (insertion) {

                  range.setStart(insertion.node, insertion.offset);
                  range.setEnd(insertion.node, insertion.offset);
                } else {
                  return true;
                }
              }
              selection.collapseToEnd();
              sanitizeEditableTextNode(firstNode);
              const afterRangeLimits = getRangeLimits(firstNode, range);
              newCaretPosition = afterRangeLimits.end;
            } else if (editor.firstChild !== firstNode) {
              removeNodes = [firstNode];
            }
          } else {

            removeNodes = selections.map((e) => e.node);

            const lastNode = selections[selections.length - 1].node;

            if (isEditableTextNode(lastNode)) {

              const extractRange = range.cloneRange();
              extractRange.setStart(range.endContainer, range.endOffset);
              extractRange.setEndAfter(lastNode.lastChild || lastNode);
              lastContent = extractRange.cloneContents();

              if (lastNode.classList?.contains("code-block")) {

                const childNodes = lastContent.querySelector("code").childNodes;

                if (childNodes?.length) {

                  lastContent = document.createDocumentFragment();
                  childNodes.forEach((childNode) => lastContent.appendChild(childNode));
                } else {
                  lastContent = null;
                }
              }
            }

            if (isEditableTextNode(firstNode)) {

              savedContents = firstNode.innerHTML;
              firstNodeId = makeNodeId(firstNode);
              const insertionNode = firstNode.classList?.contains("code-block") ? firstNode.querySelector("code"): firstNode;

              range.setEndAfter(insertionNode.lastChild || insertionNode);
              range.deleteContents();

              if (text) {

                const insertion = insertTextInRange(text, range, isHtml);

                if (insertion) {

                  range.setStart(insertion.node, insertion.offset);
                  range.setEnd(insertion.node, insertion.offset);
                } else {
                  return true;
                }
              }
              selection.collapseToEnd();
              sanitizeEditableTextNode(firstNode);
              const afterRangeLimits = getRangeLimits(firstNode, range);
              newCaretPosition = afterRangeLimits.end;

              if (lastContent) {

                insertionNode.append(lastContent);
                sanitizeEditableTextNode(firstNode);
              }

              removeNodes.shift();
            } else if (editor.firstChild === firstNode) {
              removeNodes.shift();
            }
          }

          if (!firstNodeId) sanitizeEditableTextNode(firstNode);
          const afterContents = firstNodeId ? firstNode.innerHTML : null;
          const newTextBlock = firstNodeId ? null : document.createElement("p");

          if (newTextBlock) {

            newTextBlock.setAttribute("id", `text${generateUId()}`);
            newTextBlock.setAttribute("class", "text-block");
            newTextBlock.append(...(isHtml ? htmlTextToChildNodesArray(text) : createHtmlElementsFromText(text, -1, -1, null)));
            const txt = getNodeText(newTextBlock);
            newCaretPosition = txt.length;
            if (lastContent) newTextBlock.append(lastContent);

            if (!getNodeText(newTextBlock)) newTextBlock.appendChild(document.createElement("br"));
          }
          const newRangeLimits = { start: newCaretPosition, end: newCaretPosition };

          if (savedContents !== afterContents || newTextBlock)

            if (!newTextBlock) firstNode.innerHTML = savedContents;
            UNDO_STACK.push(replaceSelectedContent, undoReplaceSelectedContent, firstNodeId, removeNodes,
                            selections[selections.length - 1].node.nextElementSibling?.id,
                            newTextBlock ? [] : getTextTransformationSteps(savedContents, afterContents), newTextBlock, oldRangeLimits, newRangeLimits);
        }

        return true;
      }

      return false;
    }

    function isCopyCutOrPasteEvent(e) {

      const KEY = e.key.toUpperCase();
      return KEY === "COPY" || KEY === "CUT" || KEY === "PASTE" || ((KEY === "C" || KEY === "X" || KEY === "V") && (e.ctrlKey || e.metaKey));
    }

    function isUndoEvent(e) {

      const KEY = e.key.toUpperCase();

      if (KEY === "UNDO") {
        return true;
      }

      if ((e.ctrlKey || e.metaKey) && !e.shiftKey && KEY === "Z") {
        return true;
      }

      return false;
    }

    function isRedoEvent(e) {

      const KEY = e.key.toUpperCase();

      if (KEY === "REDO") {
        return true;
      }

      if (e.ctrlKey && KEY === "Y") {
        return true;
      }

      if (e.shiftKey && e.metaKey && KEY === "Z") {
        return true;
      }

      return false;
    }

    function isDelEvent(e) {
      return (e.key === "Delete" || e.key === "Del" || (e.key.toUpperCase() === "D" && e.ctrlKey));
    }

    function isBackspaceEvent(e) {
      return e.key === "Backspace";
    }

    const KEY2EMPTY_STR = ["UNIDENTIFIED", "ALT", "ALTGRAPH", "CAPSLOCK", "CONTROL", "FN", "FNLOCK", "HYPER", "META", "OS", "NUMLOCK", "SCROLLLOCK",
                           "SHIFT", "SUPER", "SYMBOL", "SYMBOLLOCK", "TAB", "ARROWDOWN", "ARROWLEFT", "ARROWRIGHT", "ARROWUP", "DOWN", "LEFT", "RIGHT", "UP",
                           "END", "HOME", "PAGEDOWN", "PAGEUP", "BACKSPACE", "CLEAR", "COPY", "CRSEL", "CUT", "DEL", "DELETE", "ERASEEOF", "EXSEL", "INSERT",
                           "PASTE", "REDO", "UNDO", "ACCEPT", "AGAIN", "ATTN", "CANCEL", "CONTEXTMENU", "APPS", "ESCAPE", "ESC", "EXECUTE", "FIND", "FINISH",
                           "HELP", "PAUSE", "PLAY", "PROPS", "SELECT", "ZOOMIN", "ZOOMOUT", "BRIGHTNESSDOWN", "BRIGHTNESSUP", "EJECT", "LOGOFF", "POWER",
                           "POWEROFF", "PRINTSCREEN", "HIBERNATE", "STANDBY", "WAKEUP", "ALLCANDIDATES", "ALPHANUMERIC", "CODEINPUT", "COMPOSE", "CONVERT",
                           "DEAD", "FINALMODE", "GROUPFIRST", "GROUPLAST", "GROUPNEXT", "GROUPPREVIOUS", "MODECHANGE", "NEXTCANDIDATE", "NONCONVERT",
                           "PREVIOUSCANDIDATE", "PROCESS", "SINGLECANDIDATE", "HANGULMODE", "HANJAMODE", "JUNJAMODE", "EISU", "HANKAKU", "HIRAGANA",
                           "HIRAGANAKATAKANA", "KANAMODE", "KANJIMODE", "KATAKANA", "ROMAJI", "ZENKAKU", "ZENKAKUHANKAKU", "F1", "F2", "F3", "F4", "F5", "F6",
                           "F7", "F8", "F9", "F10", "F11", "F12", "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "SOFT1", "SOFT2", "SOFT3", "SOFT4",
                           "APPSWITCH", "CALL", "CAMERA", "CAMERAFOCUS", "ENDCALL", "GOBACK", "GOHOME", "MOZHOMESCREEN", "HEADSETHOOK", "LASTNUMBERREDIAL",
                           "NOTIFICATION", "MANNERMODE", "VOICEDIAL", "CHANNELDOWN", "CHANNELUP", "MEDIAFASTFORWARD", "MEDIAPAUSE", "MEDIAPLAY", "MEDIAPLAYPAUSE",
                           "MEDIARECORD", "MEDIAREWIND", "MEDIASTOP", "MEDIATRACKNEXT", "MEDIATRACKPREVIOUS", "AUDIOBALANCELEFT", "AUDIOBALANCERIGHT",
                           "AUDIOBASSDOWN", "AUDIOBASSBOOSTDOWN", "AUDIOBASSBOOSTTOGGLE", "AUDIOBASSBOOSTUP", "AUDIOBASSUP", "AUDIOFADERFRONT", "AUDIOFADERREAR",
                           "AUDIOSURROUNDMODENEXT", "AUDIOTREBLEDOWN", "AUDIOTREBLEUP", "AUDIOVOLUMEDOWN", "AUDIOVOLUMEMUTE", "AUDIOVOLUMEUP", "MICROPHONETOGGLE",
                           "MICROPHONEVOLUMEDOWN", "MICROPHONEVOLUMEMUTE", "MICROPHONEVOLUMEUP", "CLOSE", "NEW", "OPEN", "PRINT", "SAVE", "SPELLCHECK", "MAILFORWARD",
                           "MAILREPLY", "MAILSEND", "BROWSERBACK", "BROWSERFAVORITES", "BROWSERFORWARD", "BROWSERHOME", "BROWSERREFRESH", "BROWSERSEARCH", "BROWSERSTOP",
                           "KEY11", "KEY12"];

    function key2Str(e) {

      const KEY = e.key.toUpperCase();
      return KEY2EMPTY_STR.includes(KEY) ?
             "" : (KEY === "ENTER" ?
                  "\n" : ((KEY === "SPACEBAR" || KEY === " ") ?
                          " " : ((e.ctrlKey || e.metaKey) ? "" : e.key)));
    }

    function keydownHandler(e) {

      if (isUndoEvent(e)) {

        UNDO_STACK.undo();
        cancelEvent(e);
        return;
      }

      if (isRedoEvent(e)) {

        UNDO_STACK.redo();
        cancelEvent(e);
        return;
      }

      if (isCopyCutOrPasteEvent(e)) {
        return;
      }
      const keyText = key2Str(e);
      const isDeleteKey = isDelEvent(e);
      const isBackspaceKey = isBackspaceEvent(e);

      if (!keyText && !isDeleteKey && !isBackspaceKey) {
        return;
      }
      let range = null;
      const selection = window.getSelection();

      if (selection.rangeCount) {
        range = selection.getRangeAt(0);
      }

      if (!range) {

        cancelEvent(e);
        return;
      }

      if (handleMultiSelection(keyText)) {

        cancelEvent(e);
        return;
      }
      let block = range.startContainer;

      if (block) {

        const BLOCKED_NODE_CLASSES = [
          "embedded-local-epub",
          "embedded-local-pdf",
          "embedded-local-image",
          "embedded-local-audio",
          "embedded-table",
          "image-link",
          "audio-link",
          "video-link",
          "pdf-link",
          "audio-recording",
          "recording-control-buttons-container"
        ];

        if (block.parentNode &&
            [...block.parentNode.classList].some(c => BLOCKED_NODE_CLASSES.indexOf(c) > -1)) {
            cancelEvent(e);
            return;
        }
      } else {

        cancelEvent(e);
        return;
      }

      if (e.key === "Enter" && e.shiftKey) {

        if (handleEnterKey(range, (parentNode) => parentNode.classList?.contains("text-block"))) {

          cancelEvent(e);
          return;
        }
      }

      if (e.key === "Enter" && !e.shiftKey) {

        if (handleEnterKey(range, (parentNode) => ["CODE", "TD", "TH"].includes(parentNode.nodeName))) {

          cancelEvent(e);
          return;
        }
        e.preventDefault();
        splitBlock(range);
        return;
      }
      let topNode = getTopLevelNodeOfCurrentPosition(range);

      if (!topNode) {

        cancelEvent(e);
        return;
      }
      let handleDeleteAtBoundaries = false;

      if (isDeleteKey && isCaretAtEnd(topNode, range)) {

        const nextSibling = topNode.nextElementSibling;

        if (nextSibling) {

          const topNodeIsText = topNode.classList?.contains("text-block");
          const topNodeIsCode = !topNodeIsText && topNode.classList?.contains("code-block");

          if (topNodeIsText || topNodeIsCode) {

            const nextSiblingIsText = nextSibling.classList?.contains("text-block");
            const nextSiblingIsCode = !nextSiblingIsText && nextSibling.classList?.contains("code-block");

            if (nextSiblingIsText || nextSiblingIsCode) {

              handleDeleteAtBoundaries = topNodeIsText && nextSiblingIsText;

              if (!handleDeleteAtBoundaries) {

                const nextText = getNodeText(nextSibling);
                handleDeleteAtBoundaries = nextText === "\n" || nextText.length === 0;
              }

              if (handleDeleteAtBoundaries) {

                topNode = nextSibling;
                range = setCaret(nextSiblingIsCode ? nextSibling.querySelector("code") : nextSibling, 0);
                block = range.startContainer;
              } else {

                cancelEvent(e);
                return;
              }
            } else {

              cancelEvent(e);
              return;
            }
          }
        }
      } else {
        handleDeleteAtBoundaries = (isBackspaceKey && isCaretAtStart(topNode, range));
      }

      if (handleDeleteAtBoundaries) {

        // blocks moving of the current line in the code block into the previous sibling p node
        if (topNode.classList?.contains("code-block") && !(block?.previousSibling)) {

          if (handleBackspaceInEmptyTextContent(topNode, e)) return;

          cancelEvent(e);
          return;
        }

        if (topNode.classList?.contains("text-block")) {

          if (handleBackspaceInEmptyTextContent(topNode, e)) return;

          const previousElementSibling = topNode.previousElementSibling;

          if (topNode === block &&
              (!previousElementSibling ||
              !previousElementSibling.classList?.contains("text-block"))) {

            cancelEvent(e);
            return;
          }

          while (block !== topNode) {

            while (block.previousSibling) {

              block = block.previousSibling;

              if (block.nodeName === "BR") {
                return;
              }

              if (block.nodeType === Node.TEXT_NODE) {

                if (getNodeText(block).length) {
                  return;
                }
              } else if (block.nodeType === Node.ELEMENT_NODE) {

                if (getNodeText(block).length || block.querySelector("br")) {
                  return;
                }
              }
            }

            block = block.parentNode;
          }

          if (!previousElementSibling ||
              !previousElementSibling.classList?.contains("text-block")) {

            cancelEvent(e);
            return;
          }

          // combining current text block with the previous text block
          UNDO_STACK.push(joinAdjacentTextBlocks, undoJoinAdjacentTextBlocks, topNode, topNode.nextElementSibling?.id, previousElementSibling.innerHTML, previousElementSibling.id);

          cancelEvent(e);
          return;
        }
      }

      if (isDeleteKey) {

        handleTextDeletion(range, topNode, false);
        cancelEvent(e);
        return;
      } else if (isBackspaceKey) {

        handleTextDeletion(range, topNode, true);
        cancelEvent(e);
        return;
      } else if (keyText) {

        handleTextInsertion(keyText, range, topNode);
        cancelEvent(e);
        return;
      }
    }

    function getStyledContent(selectedFragment) {

      const docFrag = document.createDocumentFragment();
      const childNodes = [...selectedFragment.childNodes];

      for (let child of childNodes) {

        if (child.nodeName === "BR") {
          docFrag.append(child);
        } else if (child.nodeType === Node.TEXT_NODE) {

          if (child.textContent) {

            if (child.textContent === "\n") {
              docFrag.append(document.createElement("br"));
            } else {
              docFrag.append(child);
            }
          }
        } else if (isEditableTextNode(child)) {

          const ch = (child.classList?.contains("code-block") ? child.querySelector("code") : child).childNodes;
          docFrag.append(...ch);
        } else {
          return null;
        }
      }

      return docFrag.querySelector(STYLE_TAGS.join(", ")) ? docFrag : null; // return only contents that have style nodes
    }

    function getSingleNodeStyledContent(range) {

      let node = range.commonAncestorContainer;
      let retNode = null;
      let leafNode = null;

      function cloneNode(node, range) {

        const clonedNode = node.nodeType === Node.TEXT_NODE ? document.createTextNode(node.textContent.substring(range.startOffset, range.endOffset)) : document.createElement(node.nodeName.toLowerCase());

        if (node.nodeType === Node.ELEMENT_NODE) {

          // Copy attributes
          for (let attr of node.attributes) {
            clonedNode.setAttribute(attr.name, attr.value);
          }

          // Copy inline styles
          if (node.style?.cssText) clonedNode.style.cssText = node.style.cssText;

          // Copy classes
          if (node.className) clonedNode.className = node.className;
        }

        return clonedNode;
      }

      while (node && node !== editor) {

        if (node.nodeName === "CODE") return null; // code contents is considered unstyled

        if (isEditableTextNode(node)) { // all editable text nodes, except code blocks

          const docFrag = document.createDocumentFragment();
          retNode = retNode || docFrag;
          leafNode = leafNode || retNode;

          if (leafNode.nodeType !== Node.TEXT_NODE) {

            const extractRange = range.cloneRange();
            const contents = extractRange.cloneContents();
            leafNode.append(...contents.childNodes);
          }

          if (retNode !== docFrag) docFrag.append(retNode);

          return docFrag.querySelector(STYLE_TAGS.join(", ")) ? docFrag : null; // return only contents that have style nodes
        } else if (!node.id && node.parentNode && node.parentNode !== editor && node.parentNode.nodeName !== "CODE") {

          const clonedNode = cloneNode(node, range);

          if (retNode) clonedNode.append(retNode);

          retNode = clonedNode;
          leafNode = leafNode || retNode;
        }
        node = node.parentNode;
      }

      return null;
    }

    function fragmentToInnerHtml(fragment) { // destroys the fragment

      if (!(fragment instanceof DocumentFragment)) {
        throw new TypeError("Expected a DocumentFragment.");
      }

      const container = document.createElement("div");
      container.appendChild(fragment);

      return container.innerHTML;
    }

    function handleCutCopy(e, cut) {

      let range = null;
      const selection = window.getSelection();

      if (selection.rangeCount) {
        range = selection.getRangeAt(0);
      }

      if (!range?.startContainer || !range.endContainer ||
          range.startContainer === editor || range.endContainer === editor ||
          selection.isCollapsed) {

        cancelEvent(e);
        return;
      }
      let styledContentFrag = getSingleNodeStyledContent(range);

      if (!styledContentFrag) {

        const extractRange = range.cloneRange();
        const contents = extractRange.cloneContents();
        styledContentFrag = getStyledContent(contents);
      }

      if (styledContentFrag) {

        const html = fragmentToInnerHtml(styledContentFrag);
        (e.clipboardData || window.clipboardData)?.setData("text/html", html);
      } else {
        (e.clipboardData || window.clipboardData)?.setData("text/plain", selection.toString());
      }
      if (cut) handleMultiSelection("");
      e.preventDefault();
    }

    function handleCut(e) {
      handleCutCopy(e, true);
    }

    function handleCopy(e) {
      handleCutCopy(e, false);
    }

    function handlePaste(e) {

      let range = null;
      const selection = window.getSelection();

      if (selection.rangeCount) {
        range = selection.getRangeAt(0);
      }

      if (!range?.startContainer || !range.endContainer ||
          range.startContainer === editor || range.endContainer === editor) {

        cancelEvent(e);
        return;
      }
      const cbData = e.clipboardData || window.clipboardData;

      if (!cbData) return;

      if (selection.isCollapsed) {

        const topNode = getTopLevelNodeOfCurrentPosition(range);

        if (isEditableTextNode(topNode) || isTableNode(topNode)) {

          const pasteText = cbData.getData("text") || cbData.getData("text/plain");

          if (pasteText) {
            handleTextInsertion(pasteText, range, topNode);
          } else {

            const pasteHtml = cbData.getData("html") || cbData.getData("text/html");
            if (pasteHtml) handleTextInsertion(pasteHtml, range, topNode, true);
          }
        }
      } else {

        const pasteText = cbData.getData("text") || cbData.getData("text/plain");

        if (pasteText) {
          handleMultiSelection(pasteText);
        } else {

          const pasteHtml = cbData.getData("html") || cbData.getData("text/html");
          if (pasteHtml) handleMultiSelection(pasteHtml, true);
        }
      }
      cancelEvent(e);
    }

    function clickHandler(e) {

      const target = e.target.closest("a");
      if (!target || !document.getElementById("editorContainer").contains(target)) return;

      e.preventDefault();

      const userConfirmed = confirm(`"${target.href}" open this url?`);

      if (userConfirmed) {
        window.open(target.href, "_blank");
      }
    }

    function unloadHandler(e) {

      if (editor.contentEditable !== "true") {
        return;
      }
      e.preventDefault()
      e.returnValue = "";
    }

    function closeAllPageDropdownSections() {

      document.querySelectorAll(".page-dropdown-content").forEach((item) => {

        item.style.maxHeight = null;
        item.classList?.remove("open");
      });
    }

    let lastValidSelectionRange = null;

    document.onselectionchange = () => {

      const selection = document.getSelection();

      if (selection?.rangeCount) {

        const range = selection.getRangeAt(0);

        if (editor.contains(range.commonAncestorContainer)) {

          lastValidSelectionRange = range;
        }
      }

      if (lastValidSelectionRange &&
          (lastValidSelectionRange.startContainer !== lastValidSelectionRange.endContainer ||
          lastValidSelectionRange.startOffset !== lastValidSelectionRange.endOffset) &&
          editor.contains(lastValidSelectionRange.commonAncestorContainer)) {

        document.getElementById("btnLinkText").removeAttribute("disabled");
        document.getElementById("btnLinkText").setAttribute("title", "Make text link");

        document.getElementById("btnB").removeAttribute("disabled");
        document.getElementById("btnB").setAttribute("title", "Bold text");

        document.getElementById("btnI").removeAttribute("disabled");
        document.getElementById("btnI").setAttribute("title", "Italic text");

        document.getElementById("btnU").removeAttribute("disabled");
        document.getElementById("btnU").setAttribute("title", "Underline text");

        document.getElementById("btnStrikethrough").removeAttribute("disabled");
        document.getElementById("btnStrikethrough").setAttribute("title", "Strikethrough text");

        document.getElementById("btnTextColorMenu").removeAttribute("disabled");
        document.getElementById("btnTextColorMenu").setAttribute("title", "Colorize text");

        document.getElementById("btnTextHighlightMenu").removeAttribute("disabled");
        document.getElementById("btnTextHighlightMenu").setAttribute("title", "Highlight text");

        document.getElementById("btnFontScaleMenu").removeAttribute("disabled");
        document.getElementById("btnFontScaleMenu").setAttribute("title", "Change text scale");

        // mobile ui items

        document.getElementById("mbtnLinkText").removeAttribute("disabled");
        document.getElementById("mbtnLinkText").setAttribute("title", "Make text link");

        document.getElementById("mbtnTextColorMenu").removeAttribute("disabled");
        document.getElementById("mbtnTextColorMenu").setAttribute("title", "Colorize text");

        document.getElementById("mbtnTextHighlightMenu").removeAttribute("disabled");
        document.getElementById("mbtnTextHighlightMenu").setAttribute("title", "Highlight text");

        document.getElementById("mbtnFontScaleMenu").removeAttribute("disabled");
        document.getElementById("mbtnFontScaleMenu").setAttribute("title", "Change text scale");
      } else {

        document.getElementById("btnLinkText").setAttribute("disabled", " ");
        document.getElementById("btnLinkText").setAttribute("title", "Select a text to make link");

        document.getElementById("btnB").setAttribute("disabled", " ");
        document.getElementById("btnB").setAttribute("title", "Select a text to make bold");

        document.getElementById("btnI").setAttribute("disabled", " ");
        document.getElementById("btnI").setAttribute("title", "Select a text to make italic");

        document.getElementById("btnU").setAttribute("disabled", " ");
        document.getElementById("btnU").setAttribute("title", "Select a text to underline");

        document.getElementById("btnStrikethrough").setAttribute("disabled", " ");
        document.getElementById("btnStrikethrough").setAttribute("title", "Select a text to strikethrough");

        document.getElementById("btnTextColorMenu").setAttribute("disabled", " ");
        document.getElementById("btnTextColorMenu").setAttribute("title", "Select a text to colorize");

        document.getElementById("btnTextHighlightMenu").setAttribute("disabled", " ");
        document.getElementById("btnTextHighlightMenu").setAttribute("title", "Select a text to highlight");

        document.getElementById("btnFontScaleMenu").setAttribute("disabled", " ");
        document.getElementById("btnFontScaleMenu").setAttribute("title", "Select a text to change scale");

        // mobile ui items

        document.getElementById("mbtnLinkText").setAttribute("disabled", " ");
        document.getElementById("mbtnLinkText").setAttribute("title", "Select a text to make link");

        document.getElementById("mbtnTextColorMenu").setAttribute("disabled", " ");
        document.getElementById("mbtnTextColorMenu").setAttribute("title", "Select a text to colorize");

        document.getElementById("mbtnTextHighlightMenu").setAttribute("disabled", " ");
        document.getElementById("mbtnTextHighlightMenu").setAttribute("title", "Select a text to highlight");

        document.getElementById("mbtnFontScaleMenu").setAttribute("disabled", " ");
        document.getElementById("mbtnFontScaleMenu").setAttribute("title", "Select a text to change scale");
      }
    };

    editor.addEventListener("keydown", keydownHandler);
    editor.addEventListener("click", clickHandler);
    editor.addEventListener("blur", normalizeEditor);
    editor.addEventListener("input", cleanEditor);
    editor.addEventListener("focus", cleanEditor);
    editor.addEventListener("cut", handleCut);
    editor.addEventListener("copy", handleCopy);
    editor.addEventListener("paste", handlePaste);

    filename.addEventListener("input", updateTitle);

    window.addEventListener("beforeunload", unloadHandler);

    loadAllReferencedDocuments();

    document.querySelectorAll(".text-block").forEach(el => {
      if (!el.getAttribute("id")) el.setAttribute("id", `text${generateUId()}`);
    });

    updateTitle();

    /* Event handlers */

    document.querySelectorAll(".embedded-math math").forEach(mathNode => mathNode.addEventListener("click", onMathClick));

    document.getElementById("btnH1").addEventListener("click", (e) => changeBlock("xlarge-text"));
    document.getElementById("btnH2").addEventListener("click", (e) => changeBlock("large-text"));
    document.getElementById("btnM").addEventListener("click", (e) => changeBlock("medium-text"));
    document.getElementById("btnS").addEventListener("click", (e) => changeBlock("small-text"));

    document.getElementById("mbtnH1").addEventListener("click", (e) => {
      toggleDropdown("styleDropdown");
      changeBlock("xlarge-text");
    });
    document.getElementById("mbtnH2").addEventListener("click", (e) => {
      toggleDropdown("styleDropdown");
      changeBlock("large-text");
    });
    document.getElementById("mbtnM").addEventListener("click", (e) => {
      toggleDropdown("styleDropdown");
      changeBlock("medium-text");
    });
    document.getElementById("mbtnS").addEventListener("click", (e) => {
      toggleDropdown("styleDropdown");
      changeBlock("small-text");
    });

    document.getElementById("btnB").addEventListener("click", (e) => applyFormat(STYLE_STRONG_INDEX));
    document.getElementById("btnI").addEventListener("click", (e) => applyFormat(STYLE_EM_INDEX));
    document.getElementById("btnU").addEventListener("click", (e) => applyFormat(STYLE_U_INDEX));
    document.getElementById("btnStrikethrough").addEventListener("click", (e) => applyFormat(STYLE_S_INDEX));

    document.getElementById("btnTextColorMenu").addEventListener("click", (e) => toggleDropdown("textColorDropdown"));

    for (let i = 1; i < TEXT_COLORS_N + 1; ++i) {
      document.getElementById(`btnTextColor${i}`).addEventListener("click", (e) => {
        applyTextColor(i);
        toggleDropdown("textColorDropdown");
      });
      document.getElementById(`mbtnTextColor${i}`).addEventListener("click", (e) => {
        applyTextColor(i);
        toggleDropdown("styleDropdown");
      });
    }

    document.getElementById("btnTextHighlightMenu").addEventListener("click", (e) => toggleDropdown("highlightDropdown"));

    for (let i = 1; i < HIGHLIGHT_COLORS_N + 1; ++i) {
      document.getElementById(`btnTextHighlight${i}`).addEventListener("click", (e) => {
        applyHighlightColor(i);
        toggleDropdown("highlightDropdown");
      });
      document.getElementById(`mbtnTextHighlight${i}`).addEventListener("click", (e) => {
        applyHighlightColor(i);
        toggleDropdown("styleDropdown");
      });
    }

    document.getElementById("btnFontScaleMenu").addEventListener("click", (e) => toggleDropdown("fontScaleDropdown"));

    for (let i = 1; i < FONT_SIZES_N + 1; ++i) {
      document.getElementById(`btnFontScale${i}`).addEventListener("click", (e) => {
        applyFontScale(i);
        toggleDropdown("fontScaleDropdown");
      });
      document.getElementById(`mbtnFontScale${i}`).addEventListener("click", (e) => {
        applyFontScale(i);
        toggleDropdown("styleDropdown");
      });
    }

    document.getElementById("btnAlign").addEventListener("click", (e) => toggleDropdown("alignDropdown"));
    document.getElementById("btnLeftTextAlign").addEventListener("click", (e) => {
      toggleDropdown("alignDropdown");
      doAlign(AlignType.LEFT);
    });
    document.getElementById("btnCenterTextAlign").addEventListener("click", (e) => {
      toggleDropdown("alignDropdown");
      doAlign(AlignType.CENTER);
    });
    document.getElementById("btnRightTextAlign").addEventListener("click", (e) => {
      toggleDropdown("alignDropdown");
      doAlign(AlignType.RIGHT);
    });
    document.getElementById("btnJustifyTextAlign").addEventListener("click", (e) => {
      toggleDropdown("alignDropdown");
      doAlign(AlignType.JUSTIFY);
    });

    document.getElementById("mbtnLeftTextAlign").addEventListener("click", (e) => {
      toggleDropdown("styleDropdown");
      doAlign(AlignType.LEFT);
    });
    document.getElementById("mbtnCenterTextAlign").addEventListener("click", (e) => {
      toggleDropdown("styleDropdown");
      doAlign(AlignType.CENTER);
    });
    document.getElementById("mbtnRightTextAlign").addEventListener("click", (e) => {
      toggleDropdown("styleDropdown");
      doAlign(AlignType.RIGHT);
    });
    document.getElementById("mbtnJustifyTextAlign").addEventListener("click", (e) => {
      toggleDropdown("styleDropdown");
      doAlign(AlignType.JUSTIFY);
    });

    document.getElementById("btnText").addEventListener("click", (e) => insertText());
    document.getElementById("btnCode").addEventListener("click", (e) => insertCode());

    document.getElementById("btnLinks").addEventListener("click", (e) => toggleDropdown("linksDropdown"));
    document.getElementById("btnLinkText").addEventListener("click", (e) => {
      toggleDropdown("linksDropdown");
      applyURL();
    });
    document.getElementById("btnLinkImage").addEventListener("click", (e) => {
      toggleDropdown("linksDropdown");
      insertImageLink();
    });
    document.getElementById("btnLinkAudio").addEventListener("click", (e) => {
      toggleDropdown("linksDropdown");
      insertAudioLink();
    });
    document.getElementById("btnLinkVideo").addEventListener("click", (e) => {
      toggleDropdown("linksDropdown");
      insertVideoLink();
    });
    document.getElementById("btnLinkPdf").addEventListener("click", (e) => {
      toggleDropdown("linksDropdown");
      insertPdfLink();
    });

    document.getElementById("mbtnLinkText").addEventListener("click", (e) => {
      toggleDropdown("insertDropdown");
      applyURL();
    });
    document.getElementById("mbtnLinkImage").addEventListener("click", (e) => {
      toggleDropdown("insertDropdown");
      insertImageLink();
    });
    document.getElementById("mbtnLinkAudio").addEventListener("click", (e) => {
      toggleDropdown("insertDropdown");
      insertAudioLink();
    });
    document.getElementById("mbtnLinkVideo").addEventListener("click", (e) => {
      toggleDropdown("insertDropdown");
      insertVideoLink();
    });
    document.getElementById("mbtnLinkPdf").addEventListener("click", (e) => {
      toggleDropdown("insertDropdown");
      insertPdfLink();
    });

    document.getElementById("btnEmbed").addEventListener("click", (e) => toggleDropdown("embedDropdown"));
    document.getElementById("btnEmbedWeb").addEventListener("click", (e) => {
      toggleDropdown("embedDropdown");
      insertEmbeddedContent();
    });
    document.getElementById("imageUpload").addEventListener("change", (e) => {
      toggleDropdown("embedDropdown");
      insertImage(e);
    });
    document.getElementById("audioUpload").addEventListener("change", (e) => {
      toggleDropdown("embedDropdown");
      insertAudio(event);
    });
    document.getElementById("pdfUpload").addEventListener("change", (e) => {
      toggleDropdown("embedDropdown");
      insertPdf(e);
    });
    document.getElementById("epubUpload").addEventListener("change", (e) => {
      toggleDropdown("embedDropdown");
      insertEpub(e);
    });

    document.getElementById("mbtnEmbedWeb").addEventListener("click", (e) => {
      toggleDropdown("insertDropdown");
      insertEmbeddedContent();
    });
    document.getElementById("mimageUpload").addEventListener("change", (e) => {
      toggleDropdown("insertDropdown");
      insertImage(e);
    });
    document.getElementById("maudioUpload").addEventListener("change", (e) => {
      toggleDropdown("insertDropdown");
      insertAudio(event);
    });
    document.getElementById("mpdfUpload").addEventListener("change", (e) => {
      toggleDropdown("insertDropdown");
      insertPdf(e);
    });
    document.getElementById("mepubUpload").addEventListener("change", (e) => {
      toggleDropdown("insertDropdown");
      insertEpub(e);
    });

    document.getElementById("btnRecordAudio").addEventListener("click", (e) => insertAudioRecording());

    document.getElementById("btnEmbedMath").addEventListener("click", (e) => insertMath());
    document.getElementById("mbtnEmbedMath").addEventListener("click", (e) => {
      toggleDropdown("insertDropdown");
      insertMath();
    });

    document.getElementById("btnTable").addEventListener("click", (e) => toggleDropdown("tableDropdown"));
    document.getElementById("btnSimpleTable").addEventListener("click", (e) => {
      toggleDropdown("tableDropdown");
      insertTable(false);
    });
    document.getElementById("btnHeadlessTable").addEventListener("click", (e) => {
      toggleDropdown("tableDropdown");
      insertTable(true);
    });

    document.getElementById("mbtnSimpleTable").addEventListener("click", (e) => {
      toggleDropdown("insertDropdown");
      insertTable(false);
    });
    document.getElementById("mbtnHeadlessTable").addEventListener("click", (e) => {
      toggleDropdown("insertDropdown");
      insertTable(true);
    });

    document.getElementById("btnUndo").addEventListener("click", (e) => UNDO_STACK.undo());
    document.getElementById("btnRedo").addEventListener("click", (e) => UNDO_STACK.redo());

    document.getElementById("btnSaveMenu").addEventListener("click", (e) => toggleDropdown("saveDropdown"));
    document.getElementById("mbtnSaveMenu").addEventListener("click", (e) => toggleDropdown("msaveDropdown"));

    document.getElementById("btnSave").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(SaveType.DOWNLOAD, true);
    });
    document.getElementById("btnSaveTo").addEventListener("click", async (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(SaveType.FILE, true);
    });
    document.getElementById("btnShare").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(SaveType.SHARE, true);
    });
    document.getElementById("btnSaveReadOnly").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(SaveType.DOWNLOAD, false);
    });
    document.getElementById("btnSaveToReadOnly").addEventListener("click", async (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(SaveType.FILE, false);
    });
    document.getElementById("btnShareReadOnly").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(SaveType.SHARE, false);
    });

    document.getElementById("mbtnSave").addEventListener("click", (e) => {
      toggleDropdown("msaveDropdown");
      exportToFile(SaveType.DOWNLOAD, true);
    });
    document.getElementById("mbtnSaveTo").addEventListener("click", async (e) => {
      toggleDropdown("msaveDropdown");
      exportToFile(SaveType.FILE, true);
    });
    document.getElementById("mbtnShare").addEventListener("click", (e) => {
      toggleDropdown("msaveDropdown");
      exportToFile(SaveType.SHARE, true);
    });
    document.getElementById("mbtnSaveReadOnly").addEventListener("click", (e) => {
      toggleDropdown("msaveDropdown");
      exportToFile(SaveType.DOWNLOAD, false);
    });
    document.getElementById("mbtnSaveToReadOnly").addEventListener("click", async (e) => {
      toggleDropdown("msaveDropdown");
      exportToFile(SaveType.FILE, false);
    });
    document.getElementById("mbtnShareReadOnly").addEventListener("click", (e) => {
      toggleDropdown("msaveDropdown");
      exportToFile(SaveType.SHARE, false);
    });

    document.getElementById("mbtnStyle").addEventListener("click", (e) => {

      closeAllPageDropdownSections();
      toggleDropdown("styleDropdown");
    });
    document.getElementById("mbtnInsert").addEventListener("click", (e) => {

      closeAllPageDropdownSections();
      toggleDropdown("insertDropdown");
    });

    document.getElementById("mbtnCancelStyle").addEventListener("click", (e) => toggleDropdown("styleDropdown"));
    document.getElementById("mbtnCancelInsert").addEventListener("click", (e) => toggleDropdown("insertDropdown"));
    document.getElementById("mbtnCancelSave").addEventListener("click", (e) => toggleDropdown("msaveDropdown"));

    document.querySelectorAll(".page-dropdown-header").forEach(header => {

      header.addEventListener("click", () => {

        const content = header.nextElementSibling;

        // Close others if you want only one open at a time
        document.querySelectorAll(".page-dropdown-content").forEach(item => {

          if (item !== content) {

            item.style.maxHeight = null;
            item.classList?.remove("open");
          }
        });

        // Toggle current
        if (content.style.maxHeight) {

          content.style.maxHeight = null;
          content.classList?.remove("open");
        } else {

          content.style.maxHeight = content.scrollHeight + "px";
          content.classList?.add("open");
        }
      });
    });

    editor.focus();
  </script>

  <script>
    const editor = document.getElementById("editor");

    // Helper: Places the caret at a given element and offset.
    function setCaret(el, pos) {

      const selection = window.getSelection();
      const range = document.createRange();
      range.setStart(el, pos);
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    function editorInsertBefore(childNode, siblingNodeId) {

      if (childNode && !editor.contains(childNode)) {

        const siblingNode = siblingNodeId ? document.getElementById(siblingNodeId) : null;

        if (!siblingNode || editor.contains(siblingNode)) {

          editor.insertBefore(childNode, siblingNode);

          if (childNode.classList?.contains("text-block") ||
              childNode.classList?.contains("code-block")) {
            if (childNode.classList?.contains("text-block")) setCaret(childNode, 0);
            else setCaret(childNode.querySelector("code"), 0);
          }
        }
      }
    }

    function editorRemoveChild(childNode, siblingNodeId) {

      if (childNode && editor.contains(childNode)) {

        if (childNode.classList?.contains("text-block") ||
            childNode.classList?.contains("code-block")) {

          let p = childNode.previousElementSibling;

          while (p &&
                 !p.classList?.contains("text-block") &&
                 !p.classList?.contains("code-block")) {
            p = p.previousElementSibling;
          }
          editor.removeChild(childNode);

          if (p) {
            if (p.classList?.contains("text-block")) setCaret(p, 0);
            else setCaret(p.querySelector("code"), 0);
          }
          else {
            editor.focus();
          }
        } else {

          editor.removeChild(childNode);
          editor.focus();
        }
      }
    }

    function handleXRemoveEvent(event) {

      const parentNode = event.target?.parentNode?.parentNode;

      if (parentNode === editor) {

        const childNode = event.target?.parentNode;
        const childSibling = childNode?.nextElementSibling;
        editor.UNDO_STACK.push(editorRemoveChild, editorInsertBefore,
                               childNode, childSibling?.id);
      }
    }
  </script>

</body>

</html>