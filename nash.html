<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nash Note</title>
  <link rel="icon" type="image/svg+xml"
    href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%20100%20100%22%3E%0A%20%20%3Crect%20width%3D%22100%22%20height%3D%22100%22%20rx%3D%2220%22%20fill%3D%22black%22%2F%3E%0A%20%20%3Ctext%20x%3D%2250%25%22%20y%3D%2250%25%22%20font-size%3D%2260%22%20font-weight%3D%22bold%22%20text-anchor%3D%22middle%22%20fill%3D%22white%22%20font-family%3D%22Arial%2C%20sans-serif%22%20dominant-baseline%3D%22central%22%3EN.%3C%2Ftext%3E%0A%3C%2Fsvg%3E" />
  <style>
    :root {
      --page-bg-color: #f8f9fa;
      --page-text-color: #333;

      --control-bg-color: #f8f9fa;
      --control-text-color: buttontext;
      --control-hover-bg-color: #f0f0f0;
      --control-hover-text-color: #bbb;

      --note-bg-color: #fff;
      --note-placeholer-color: #bbb;
      --note-link-color: #616161;

      --attribution-color: #bbb;

      --code-bg-color: #e5e4e2;
      --code-text-color: #333;

      --audio-recording-controls-bg-color: #e5e4e2;
      --audio-recording-controls-text-color: #333;

      --table-border-color: #000;

      /* text background colors */
      --note-text-color-1: #000000;
      /* black */
      --note-text-color-2: #FF3B30;
      /* red */
      --note-text-color-3: #FF9500;
      /* orange */
      --note-text-color-4: #FFCC00;
      /* yellow */
      --note-text-color-5: #4CD964;
      /* green */
      --note-text-color-6: #5AC8FA;
      /* light-blue */
      --note-text-color-7: #007AFF;
      /* dark-blue */
      --note-text-color-8: #5856D6;
      /* violet */

      /* highlight background colors */
      --note-highlight-color-1: #FCECEC;
      /* red */
      --note-highlight-color-2: #FFECEB;
      /* orange */
      --note-highlight-color-3: #FFF8E1;
      /* yellow */
      --note-highlight-color-4: #F1FAE5;
      /* green */
      --note-highlight-color-5: #E6F9F0;
      /* light-blue */
      --note-highlight-color-6: #E8F0FE;
      /* violet */
      --note-highlight-color-7: #E7F0FF;
      /* dark-blue */
      --note-highlight-color-8: #F3E8FF;
      /* purple */
    }

    /* dark mode */
    @media (prefers-color-scheme: dark) {
      :root {
        --page-bg-color: #3a3a3a;
        --page-text-color: #ddd;

        --control-bg-color: #444;
        --control-text-color: #aaa;
        --control-hover-bg-color: #666;
        --control-hover-text-color: #eee;

        --note-bg-color: #333;
        --note-placeholder-color: #555;

        --code-bg-color: #36454f;
        --code-text-color: #fff;

        --audio-recording-controls-bg-color: #36454f;
        --audio-recording-controls-text-color: #fff;

        --table-border-color: #fff;

        /*
               TODO: choose nicer colors :-)
            */

        /* text background colors */
        --note-text-color-1: #FAFAFA;
        /* black / white */
        --note-text-color-2: #FF3B30;
        /* red */
        --note-text-color-3: #FF9500;
        /* orange */
        --note-text-color-4: #FFCC00;
        /* yellow */
        --note-text-color-5: #4CD964;
        /* green */
        --note-text-color-6: #5AC8FA;
        /* light-blue */
        --note-text-color-7: #007AFF;
        /* dark-blue */
        --note-text-color-8: #5856D6;
        /* violet */

        /* highlight background colors */
        --note-highlight-color-1: hsl(0 50% 30%);
        /* red */
        --note-highlight-color-2: hsl(30 50% 30%);
        /* orange */
        --note-highlight-color-3: hsl(45 50% 30%);
        /* yellow */
        --note-highlight-color-4: hsl(120 50% 30%);
        /* green */
        --note-highlight-color-5: hsl(240 70% 40%);
        /* light-blue */
        --note-highlight-color-6: hsl(300 70% 40%);
        /* violet */
        --note-highlight-color-7: hsl(240 50% 30%);
        /* dark-blue */
        --note-highlight-color-8: hsl(330 50% 30%);
        /* purple */
      }
    }

    body {
      font-family: 'Arial', sans-serif;
      background-color: var(--page-bg-color);
      color: var(--page-text-color);
      margin: 0;
      padding: 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .editor-container {
      width: 100%;
      max-width: 90%;
      background: var(--note-bg-color);
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0px 5px 15px rgba(0, 0, 0, 0.1);
    }

    .file-title {
      font-size: 28px;
      font-weight: bold;
      margin-bottom: 15px;
      padding: 0px 15px;
      outline: none;
      border: none;
      width: 100%;
      background: transparent;
    }

    .file-title:empty::before {
      content: "Write your title here...";
      color: var(--note-placeholder-color);
      display: block;
    }

    .top-container {
      position: sticky;
      position: -webkit-sticky;
      top: 5px;
      padding: 0 10px;
      z-index: 9999;
    }

    #toolbar {
      gap: 8px;
      background-color: var(--control-bg-color);
      border-radius: 12px;
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      align-items: center;
    }

    #toolbar #splitbar {
      margin-left: auto;
      font-size: 24px;
    }

    #toolbar input[type="file"] {
      display: none;
    }

    #toolbar button,
    #toolbar label,
    #toolbar select {
      padding: 8px;
      border: none;
      background: none;
      color: var(--control-text-color);
      font-size: 24px;
      cursor: pointer;
      transition: opacity 0.2s
    }

    #toolbar button:hover,
    #toolbar label:hover,
    #toolbar select:hover {
      background: var(--control-hover-bg-color);
      border-color: var(--control-hover-text-color);
      color: var(--control-hover-text-color);
    }

    /* Dropdown container */
    .dropdown {
      position: relative;
      display: inline-block;
    }

    /* Dropdown button style */
    .dropdown>button {
      padding: 6px 10px;
    }

    /* Dropdown content (hidden by default) */
    .dropdown-content {
      display: none;
      position: absolute;
      top: 110%;
      right: 0;
      background: var(--control-bg-color);
      border: 1px solid var(--control-bg-color);
      color: var(--control-text-color);
      padding: 8px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      z-index: 10;
    }

    /* Show dropdown when .show is added */
    .dropdown-content.show {
      display: block;
    }

    /* Grid of swatches */
    .swatch-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, 24px);
      gap: 6px;
    }

    .color-swatch {
      width: 24px;
      height: 24px;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .color-swatch:hover {
      transform: scale(1.1);
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);
    }

    #saveDropdown {
      width: 250px;
    }

    #saveDropdown button {
      width: 100%;
      text-align: left;
    }

    #tableDropdown {
      width: 200px;
    }

    #tableDropdown button {
      width: 100%;
      text-align: left;
    }

    #editor {
      border-radius: 12px;
      padding: 15px;
      min-height: 250px;
      outline: none;
      font-size: 16px;
      line-height: 1.6;
      /* background: #f4f4f4; */
    }

    #editor p {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
    }

    #editor a {
      color: var(--note-link-color);
      text-decoration: none;
      font-weight: 800;
      transition: all 0.2s ease-in-out;
      border-bottom: 2px solid transparent;
    }

    #editor a:hover {
      border-bottom: 2px solid var(--note-link-color);
      color: var(--note-link-color);
    }

    #editor pre code {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
      background: var(--code-bg-color);
      color: var(--code-text-color);
      display: block;
      margin: 0;
      padding: 8px;
      border-radius: 6px;
    }

    #footer {
      text-align: center;
      margin-top: 20px;
      color: var(--attribution-color);
    }

    #footer a {
      text-decoration: none;
      color: var(--attribution-color);
    }

    .non-selectable {
      user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      -webkit-touch-callout: none;
      -o-user-select: none;
      -moz-user-select: none;
    }

    img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 10px 0;
      border-radius: 12px;
    }

    audio {
      width: 100%;
      display: block;
      margin: 10px 0;
    }

    video {
      width: 100%;
      height: auto;
      display: block;
      margin: 10px 0;
      border-radius: 12px;
    }

    .embedded-content {
      width: 100%;
      height: auto;
      display: block;
      margin: 10px 0;
    }

    .embedded-local-epub {
      width: 100%;
      height: auto;
      display: block;
      margin: 20px 0;
    }

    .embedded-local-pdf {
      width: 100%;
      height: auto;
      display: block;
      margin: 20px 0;
    }

    .link-pdf {
      width: 100%;
      height: auto;
      display: block;
      margin: 20px 0;
    }

    .embedded-table {
      width: 100%;
      height: auto;
      display: block;
      margin: 10px 0;
    }

    .embedded-table table {
      width: 100%;
      height: auto;
      padding: 0 0;
      margin: 0 0;
      text-align: left;
      table-layout:fixed;
      border: 1px solid var(--table-border-color);
      border-collapse: collapse;
      border-spacing: 0;
    }

    .embedded-table table th,
    .embedded-table table td {
      overflow: hidden;
      border: 1px solid var(--table-border-color);
      margin: 0 0;
      padding: 0 8px;
    }

    .epub-loading::before {
      content: "ePUB document is loading...";
      display: block;
      color: var(--note-placeholer-color);
      margin: 0;
    }

    .pdf-loading::before {
      content: "PDF document is loading...";
      display: block;
      color: var(--note-placeholer-color);
      margin: 0;
    }

    .thin-line::before {
      content: "";
      display: block;
      width: 100%;
      height: 1px;
      background-color: var(--control-bg-color);
      color: var(--control-text-color);
      margin: 10px 0;
    }

    #recordingBar {
      content: "";
      display: block;
      height: 4px;
      border-radius: 2px;
      background-color: red;
      color: red;
      margin: 10px 0;
      /*transitions with Firefox, IE and Opera Support browser support*/
      animation-name: flashing-recording-dot;
      -webkit-animation-name: flashing-recording-dot;
      -moz-animation-name: flashing-recording-dot;
      -o-animation-name: flashing-recording-dot;
      animation-duration: 2s;
      -webkit-animation-duration: 2s;
      -moz-animation-duration: 2s;
      -o-animation-duration: 2s;
      animation-iteration-count: infinite;
      -webkit-animation-iteration-count: infinite;
      -moz-animation-iteration-count: infinite;
      -o-animation-iteration-count: infinite;
    }

    #recordingBar.hidden {
      display: none;
    }

    .audio-recording {
      width: 100%;
      height: auto;
      margin: 20px 0;
    }

    .embedded-local-epub,
    .embedded-local-pdf,
    .embedded-local-image,
    .embedded-local-audio,
    .embedded-table,
    .image-link,
    .audio-link,
    .video-link,
    .pdf-link,
    .audio-recording {
      display: block;
      position: relative;
    }

    .x-remover {
      background-color: #aaa;
      padding: 6.5px 6.7px 3.8px 6.5px;
      color: #ff3b30;
      display: none;
      position: absolute;
      top: 0;
      right: 0;
      margin-top: -10px;
      margin-right: -10px;
      font-weight: 700;
      border-radius: 50%;
      border: 1px solid #333;
      text-align: center;
      line-height: 20px;
      font-family: sans-serif;
      cursor: pointer;
    }

    .embedded-local-epub:hover .x-remover,
    .embedded-local-pdf:hover .x-remover,
    .embedded-local-image:hover .x-remover,
    .embedded-local-audio:hover .x-remover,
    .embedded-table:hover .x-remover,
    .image-link:hover .x-remover,
    .audio-link:hover .x-remover,
    .video-link:hover .x-remover,
    .pdf-link:hover .x-remover,
    .audio-recording:hover .x-remover {
      display: block;
    }

    /* Audio Recording UI */

    .recording-control-buttons-container {
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      justify-content: space-evenly;
      /*horizontal centering*/
      align-items: center;
      width: 100%;
      height: auto;
      margin: 0;
      border-radius: 12px;
      background-color: white;
      background: var(--audio-recording-controls-bg-color);
      color: var(--audio-recording-controls-text-color);
    }

    .cancel-recording-button,
    .stop-recording-button {
      font-size: 32px;
      cursor: pointer;
    }

    .cancel-recording-button {
      color: red;
      opacity: 0.7;
    }

    .cancel-recording-button:hover {
      color: rgb(206, 4, 4);
    }

    .stop-recording-button {
      color: #33cc33;
      opacity: 0.7;
    }

    .stop-recording-button:hover {
      color: #27a527;
    }

    .recording-elapsed-time {
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      justify-content: center;
      /*horizontal centering*/
      align-items: center;
    }

    .red-recording-dot {
      font-size: 24px;
      color: red;
      margin-right: 12px;
      /*transitions with Firefox, IE and Opera Support browser support*/
      animation-name: flashing-recording-dot;
      -webkit-animation-name: flashing-recording-dot;
      -moz-animation-name: flashing-recording-dot;
      -o-animation-name: flashing-recording-dot;
      animation-duration: 2s;
      -webkit-animation-duration: 2s;
      -moz-animation-duration: 2s;
      -o-animation-duration: 2s;
      animation-iteration-count: infinite;
      -webkit-animation-iteration-count: infinite;
      -moz-animation-iteration-count: infinite;
      -o-animation-iteration-count: infinite;
    }

    /* The animation code */
    @keyframes flashing-recording-dot {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0;
      }
      100% {
        opacity: 1;
      }
    }

    @-webkit-keyframes flashing-recording-dot {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0;
      }
      100% {
        opacity: 1;
      }
    }

    @-moz-keyframes flashing-recording-dot {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0;
      }
      100% {
        opacity: 1;
      }
    }

    @-o-keyframes flashing-recording-dot {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0;
      }
      100% {
        opacity: 1;
      }
    }
    /* END OF Audio Recording UI */

    small {
      display: block;
    }

    .left-text {
      text-align: left;
    }

    .center-text {
      text-align: center;
    }

    .right-text {
      text-align: right;
    }

    .justify-text {
      text-align: justify;
    }

    @media print {
      .no-print {
        display: none !important;
      }

      .editor-container {
        width: 100%;
        max-width: 100%;
        box-shadow: none;
      }
    }
  </style>
</head>

<body>

  <div class="editor-container">
    <div id="filename" contenteditable="plaintext-only" class="file-title"></div>

    <div class="top-container">
      <div id="toolbar" class="no-print">
        <button id="btnH1" title="Extra large text">XL</button>
        <button id="btnH2" title="Large text">L</button>
        <button id="btnM" title="Medium text">M</button>
        <button id="btnS" title="Small text">S</button>

        <button id="btnB" title="Bold text"><b>B</b></button>
        <button id="btnI" title="Italic text"><i>I</i></button>
        <button id="btnU" title="Underline text"><u>U</u></button>
        <button id="btnLink" title="Make text link">🔗</button>

        <label for="imageUpload" title="Embed image">📷</label>
        <input type="file" id="imageUpload" accept="image/*" onclick="this.value = null">

        <button id="btnImageLink" title="Insert image link">🔗📷</button>

        <div class="dropdown">
          <button id="btnTextColorMenu" title="Colorize text">Color</button>
          <div id="textColorDropdown" class="dropdown-content">
            <div class="swatch-grid">
              <button id="btnTextColor1" class="color-swatch" style="background: var(--note-text-color-1);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor2" class="color-swatch" style="background: var(--note-text-color-2);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor3" class="color-swatch" style="background: var(--note-text-color-3);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor4" class="color-swatch" style="background: var(--note-text-color-4);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor5" class="color-swatch" style="background: var(--note-text-color-5);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor6" class="color-swatch" style="background: var(--note-text-color-6);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor7" class="color-swatch" style="background: var(--note-text-color-7);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor8" class="color-swatch" style="background: var(--note-text-color-8);"
                onmousedown="event.preventDefault();"></button>
            </div>
          </div>
        </div>

        <!-- Highlight Color Dropdown -->
        <div class="dropdown">
          <button id="btnTextHighlightMenu" title="Highlight text">Highlight</button>
          <div id="highlightDropdown" class="dropdown-content">
            <div class="swatch-grid">
              <button id="btnTextHighlight1" class="color-swatch" style="background: var(--note-highlight-color-1);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight2" class="color-swatch" style="background: var(--note-highlight-color-2);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight3" class="color-swatch" style="background: var(--note-highlight-color-3);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight4" class="color-swatch" style="background: var(--note-highlight-color-4);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight5" class="color-swatch" style="background: var(--note-highlight-color-5);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight6" class="color-swatch" style="background: var(--note-highlight-color-6);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight7" class="color-swatch" style="background: var(--note-highlight-color-7);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight8" class="color-swatch" style="background: var(--note-highlight-color-8);"
                onmousedown="event.preventDefault();"></button>
            </div>
          </div>
        </div>
        <button id="btnText" title="Add text"><b>T</b></button>
        <button id="btnCode" title="Add source code text">🖥</button>
        <button id="btnEmbedContent" title="Embed HTML">🗂</button>

        <label for="audioUpload" title="Embed audio file">🔈</label>
        <input type="file" id="audioUpload" accept="audio/*" onclick="this.value = null">

        <button id="btnAudioLink" title="Insert audio link">🔗🔈</button>
        <button id="btnRecordAudio" title="Record audio">🎤</button>
        <button id="btnVideoLink" title="Insert video link">🔗📽</button>

        <label for="epubUpload" title="Embed ePUB file">📖</label>
        <input type="file" id="epubUpload" accept=".epub" onclick="this.value = null">

        <label for="pdfUpload" title="Embed PDF file"><b>PDF</b></label>
        <input type="file" id="pdfUpload" accept=".pdf" onclick="this.value = null">

        <button id="btnPdfLink" title="Insert PDF link">🔗<b>PDF</b></button>
        <div class="dropdown">
          <button id="btnTable" title="Add table"><b>Table</b></button>
          <div id="tableDropdown" class="dropdown-content">
            <button id="btnSimpleTable" title="Add simple table">Simple Table</button>
            <button id="btnHeadlessTable" title="Add headless table">Headless Table</button>
          </div>
        </div>

        <div class="dropdown">
          <button id="btnAlign" title="Align text"><b>Align</b></button>
          <div id="alignDropdown" class="dropdown-content">
            <button id="btnLeftTextAlign" title="Align text to the left">Left</button>
            <button id="btnCenterTextAlign" title="Align text to the center">Center</button>
            <button id="btnRightTextAlign" title="Align text to the right">Right</button>
            <button id="btnJustifyTextAlign" title="Justify text">Justify</button>
          </div>
        </div>

        <div id="splitbar">|</div>
        <!-- Block conversion -->
        <div class="dropdown">
          <button id="btnSaveMenu" title="Save or Share">💾</button>
          <div id="saveDropdown" class="dropdown-content">
            <button id="btnSave">Save</button>
            <button id="btnShare">Share</button>
            <button id="btnSaveReadOnly">Save as Read-Only</button>
            <button id="btnShareReadOnly">Share as Read-Only</button>
          </div>
        </div>

      </div>
      <div id="recordingBar" class="hidden" aria-hidden="true"></div>
    </div>

    <div id="editorContainer" class="thin-line">
      <div id="editor" contenteditable="true">
        <p class="text-block"><br/></p>
      </div>
    </div>

    <div id="footer">
      <small><a href="https://github.com/flaviup">flaviup@github.com</a></small>
      <br/>
      <small>Nash 0.1</small>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script -->
  <script src="https://github.com/futurepress/epub.js/releases/download/v0.3.88/epub.min.js"></script> <!-- check newer versions like 0.3.93 -->

  <script type="module">
    /**
     *  PDFObject v2.3.1
     *  https://github.com/pipwerks/PDFObject
     *  @license
     *  Copyright (c) 2008-2025 Philip Hutchison
     *  MIT-style license: http://pipwerks.mit-license.org/
     *  UMD module pattern from https://github.com/umdjs/umd/blob/master/templates/returnExports.js
     */

    (function (root, factory) {
        if (typeof define === "function" && define.amd) {
            // AMD. Register as an anonymous module.
            define([], factory);
        } else if (typeof module === "object" && module.exports) {
            // Node. Does not work with strict CommonJS, but
            // only CommonJS-like environments that support module.exports,
            // like Node.
            module.exports = factory();
        } else {
            // Browser globals (root is window)
            root.PDFObject = factory();
        }
    }(globalThis, function () {

        "use strict";

        //PDFObject is designed for client-side (browsers), not server-side (node)
        //Will choke on undefined navigator and window vars when run on server
        //Return boolean false and exit function when running server-side

        if(typeof window === "undefined" || window.navigator === undefined || window.navigator.userAgent === undefined){ return false; }

        let pdfobjectversion = "2.3.1";
        let win = window;
        let nav = win.navigator;
        let ua = nav.userAgent;
        let suppressConsole = false;

        //Fallback validation when navigator.pdfViewerEnabled is not supported
        let isModernBrowser = function (){

            /*
              userAgent sniffing is not the ideal path, but most browsers revoked the ability to check navigator.mimeTypes
              for security purposes. As of 2023, browsers have begun implementing navigator.pdfViewerEnabled, but older versions
              do not have navigator.pdfViewerEnabled or the ability to check navigator.mimeTypes. We're left with basic browser
              sniffing and assumptions of PDF support based on browser vendor.
            */

            //Chromium has provided native PDF support since 2011.
            //Most modern browsers use Chromium under the hood: Google Chrome, Microsoft Edge, Opera, Brave, Vivaldi, Arc, and more.
            //Chromium uses the PDFium rendering engine, which is based on Foxit's PDF rendering engine.
            //Note that MS Edge opts to use a different PDF rendering engine. As of 2024, Edge uses a version of Adobe's Reader
            let isChromium = (win.chrome !== undefined);

            //Safari on macOS has provided native PDF support since 2009.
            //This code snippet also detects the DuckDuckGo browser, which uses Safari/Webkit under the hood.
            let isSafari = (win.safari !== undefined || (nav.vendor !== undefined && /Apple/.test(nav.vendor) && /Safari/.test(ua)));

            //Firefox has provided PDF support via PDFJS since 2013.
            let isFirefox = (win.Mozilla !== undefined || /irefox/.test(ua));

            return isChromium || isSafari || isFirefox;

        };

        /*
          Special handling for Internet Explorer 11.
          Check for ActiveX support, then whether "AcroPDF.PDF" or "PDF.PdfCtrl" are valid.
          IE11 uses ActiveX for Adobe Reader and other PDF plugins, but window.ActiveXObject will evaluate to false.
          ("ActiveXObject" in window) evaluates to true.
          MS Edge does not support ActiveX so this test will evaluate false for MS Edge.
        */
        let validateAX = function (type){
            var ax = null;
            try {
                ax = new ActiveXObject(type);
            } catch (e) {
                //ensure ax remains null when ActiveXObject attempt fails
                ax = null;
            }
            return !!ax; //convert resulting object to boolean
        };

        let hasActiveXPDFPlugin = function (){ return ("ActiveXObject" in win) && (validateAX("AcroPDF.PDF") || validateAX("PDF.PdfCtrl")) };

        let checkSupport = function (){

            //Safari on iPadOS doesn't report as 'mobile' when requesting desktop site, yet still fails to embed PDFs
            let isSafariIOSDesktopMode = (nav.platform !== undefined && nav.platform === "MacIntel" && nav.maxTouchPoints !== undefined && nav.maxTouchPoints > 1);

            let isMobileDevice = (isSafariIOSDesktopMode || /Mobi|Tablet|Android|iPad|iPhone/.test(ua));

            //As of June 2023, no mobile browsers properly support inline PDFs. If mobile, just say no.
            if(isMobileDevice){ return false; }

            //Modern browsers began supporting navigator.pdfViewerEnabled in late 2022 and early 2023.
            let supportsPDFVE = (typeof nav.pdfViewerEnabled === "boolean");

            //If browser supports nav.pdfViewerEnabled and is explicitly saying PDFs are NOT supported (e.g. PDFJS disabled by user in Firefox), respect it.
            if(supportsPDFVE && !nav.pdfViewerEnabled){ return false; }

            return (supportsPDFVE && nav.pdfViewerEnabled) || isModernBrowser() || hasActiveXPDFPlugin();

        };

        //Determines whether PDF support is available
        let supportsPDFs = checkSupport();

        //Create a fragment identifier for using PDF Open parameters when embedding PDF
        let buildURLFragmentString = function(pdfParams){

            let string = "";
            let prop;
            let paramArray = [];
            let fdf = "";

            //The comment, viewrect, and highlight parameters require page to be set first.

            //Check to ensure page is used if comment, viewrect, or highlight are specified
            if(pdfParams.comment || pdfParams.viewrect || pdfParams.highlight){

                if(!pdfParams.page){

                    //If page is not set, use the first page
                    pdfParams.page = 1;

                    //Inform user that page needs to be set properly
                    embedError("The comment, viewrect, and highlight parameters require a page parameter, but none was specified. Defaulting to page 1.");

                }

            }

            //Let's go ahead and ensure page is always the first parameter.
            if(pdfParams.page){
                paramArray.push("page=" + encodeURIComponent(pdfParams.page));
                delete pdfParams.page;
            }

            //FDF needs to be the last parameter in the string
            if(pdfParams.fdf){
                fdf = pdfParams.fdf;
                delete pdfParams.fdf;
            }

            //Add all other parameters, as needed
            if(pdfParams){

                for (prop in pdfParams) {
                    if (pdfParams.hasOwnProperty(prop)) {
                        paramArray.push(encodeURIComponent(prop) + "=" + encodeURIComponent(pdfParams[prop]));
                    }
                }

                //Add fdf as the last parameter, if needed
                if(fdf){
                    paramArray.push("fdf=" + encodeURIComponent(fdf));
                }

                //Join all parameters in the array into a string
                string = paramArray.join("&");

                //The string will be empty if no PDF Parameters were provided
                //Only prepend the hash if the string is not empty
                if(string){
                    string = "#" + string;
                }

            }

            return string;

        };

        let embedError = function (msg){
            if(!suppressConsole){
                console.log("[PDFObject]", msg);
            }
            return false;
        };

        let emptyNodeContents = function (node){
            while(node.firstChild){
                node.removeChild(node.firstChild);
            }
        };

        let getTargetElement = function (targetSelector){

            //Default to body for full-browser PDF
            let targetNode = document.body;

            //If a targetSelector is specified, check to see whether
            //it's passing a selector, jQuery object, or an HTML element

            if(typeof targetSelector === "string"){

                //Is CSS selector
                targetNode = document.querySelector(targetSelector);

            } else if (win.jQuery !== undefined && targetSelector instanceof jQuery && targetSelector.length) {

                //Is jQuery element. Extract HTML node
                targetNode = targetSelector.get(0);

            } else if (targetSelector.nodeType !== undefined && targetSelector.nodeType === 1){

                //Is HTML element
                targetNode = targetSelector;

            }

            return targetNode;

        };

        let convertBase64ToDownloadableLink = function (b64, filename, targetNode, fallbackHTML) {

            //IE-11 safe version. More verbose than modern fetch()
            if (window.Blob && window.URL && window.URL.createObjectURL) {

                var xhr = new XMLHttpRequest();
                xhr.open('GET', b64, true);
                xhr.responseType = 'blob';
                xhr.onload = function() {

                    if (xhr.status === 200) {

                        var blob = xhr.response;
                        var link = document.createElement('a');
                        link.innerText = "Download PDF";
                        link.href = URL.createObjectURL(blob);
                        link.setAttribute('download', filename);
                        targetNode.innerHTML = fallbackHTML.replace(/\[pdflink\]/g, link.outerHTML);

                    }

                };

                xhr.send();

            }

        };


        let generatePDFObjectMarkup = function (embedType, targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute, PDFJS_URL){

            //Ensure target element is empty first
            emptyNodeContents(targetNode);

            let source = url;

            if(embedType === "pdfjs"){
                //If PDFJS_URL already contains a ?, assume querystring is in place, and use an ampersand to append PDFJS's file parameter
                let connector = (PDFJS_URL.indexOf("?") !== -1) ? "&" : "?";
                source = PDFJS_URL + connector + "file=" + encodeURIComponent(url) + pdfOpenFragment;
            } else {
                source += pdfOpenFragment;
            }

            let el = document.createElement("iframe");
            el.className = "pdfobject";
            el.type = "application/pdf";
            el.title = title;
            el.src = source;
            el.allow = "fullscreen";
            el.frameborder = "0";
            if(id){ el.id = id; }

            if(!omitInlineStyles){

                let style = "border: none;";

                if(targetNode !== document.body){
                    //assign width and height to target node
                    style += "width: " + width + "; height: " + height + ";";
                } else {
                    //this is a full-page embed, use CSS to fill the viewport
                    style += "position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: 100%; height: 100%;";
                }

                el.style.cssText = style;

            }

            //Allow developer to insert custom attribute on iframe element, but ensure it does not conflict with attributes used by PDFObject
            let reservedTokens = ["className", "type", "title", "src", "style", "id", "allow", "frameborder"];
            if(customAttribute && customAttribute.key && reservedTokens.indexOf(customAttribute.key) === -1){
                el.setAttribute(customAttribute.key, (typeof customAttribute.value !== "undefined") ? customAttribute.value : "");
            }

            targetNode.classList.add("pdfobject-container");
            targetNode.appendChild(el);

            return targetNode.getElementsByTagName("iframe")[0];

        };

        let embed = function(url, targetSelector, options){

            //If targetSelector is not defined, convert to boolean
            let selector = targetSelector || false;

            //Ensure options object is not undefined -- enables easier error checking below
            let opt = options || {};

            //Get passed options, or set reasonable defaults
            suppressConsole = (typeof opt.suppressConsole === "boolean") ? opt.suppressConsole : false;
            let id = (typeof opt.id === "string") ? opt.id : "";
            let page = opt.page || false;
            let pdfOpenParams = opt.pdfOpenParams || {};
            let fallbackLink = (typeof opt.fallbackLink === "string" || typeof opt.fallbackLink === "boolean") ? opt.fallbackLink : true;
            let width = opt.width || "100%";
            let height = opt.height || "100%";
            let title = opt.title || "Embedded PDF";
            let forcePDFJS = (typeof opt.forcePDFJS === "boolean") ? opt.forcePDFJS : false;
            let omitInlineStyles = (typeof opt.omitInlineStyles === "boolean") ? opt.omitInlineStyles : false;
            let PDFJS_URL = opt.PDFJS_URL || false;
            let targetNode = getTargetElement(selector);
            let pdfOpenFragment = "";
            let customAttribute = opt.customAttribute || {};
            let fallbackFileNameForBase64 = opt.fallbackFileNameForBase64;
            let fallbackHTML_default = "<p>This browser does not support inline PDFs. Please download the PDF to view it: [pdflink]</p>";

            //Ensure URL is available. If not, exit now.
            if(typeof url !== "string"){ return embedError("URL is not valid"); }

            //If target element is specified but is not valid, exit without doing anything
            if(!targetNode){ return embedError("Target element cannot be determined"); }

            //page option overrides pdfOpenParams, if found
            if(page){ pdfOpenParams.page = page; }

            //Stringify optional Adobe params for opening document (as fragment identifier)
            pdfOpenFragment = buildURLFragmentString(pdfOpenParams);


            // --== Do the dance: Embed attempt #1 ==--

            //If the forcePDFJS option is invoked, skip everything else and embed as directed
            if(forcePDFJS && PDFJS_URL){
                return generatePDFObjectMarkup("pdfjs", targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute, PDFJS_URL);
            }

            // --== Embed attempt #2 ==--

            //Embed PDF if support is detected, or if this is a relatively modern browser
            if(supportsPDFs){
                return generatePDFObjectMarkup("iframe", targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute);
            }

            // --== Embed attempt #3 ==--

            //If everything else has failed and a PDFJS fallback is provided, try to use it
            if(PDFJS_URL){
                return generatePDFObjectMarkup("pdfjs", targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute, PDFJS_URL);
            }

            // --== PDF embed not supported! Use fallback ==--

            //Display the fallback link if available
            if(fallbackLink){

                //If a custom fallback has been provided, handle it now
                if(typeof fallbackLink === "string"){

                    //Ensure [url] is set in custom fallback
                    targetNode.innerHTML = fallbackLink.replace(/\[url\]/g, url);

                } else {

                    //If the PDF is a base64 string, convert it to a downloadable link
                    const match = url.match(/data:application\/pdf;(?:.*filename=([^;]+);)?.*base64,/i);
                    if(match){

                        fallbackFileNameForBase64 =
                            fallbackFileNameForBase64 // from options
                            || match[1] // from data URI metadata
                            || "file.pdf"; // default

                        //Asynchronously append the link to the targetNode
                        convertBase64ToDownloadableLink(url, fallbackFileNameForBase64, targetNode, fallbackHTML_default);

                    } else {

                        //Use default fallback link
                        let link = "<a href='" + url + "'>Download PDF</a>";
                        targetNode.innerHTML = fallbackHTML_default.replace(/\[pdflink\]/g, link);

                    }

                }

            }

            return embedError("This browser does not support embedded PDFs");

        };

        return {
            embed: function (a,b,c){ return embed(a,b,c); },
            pdfobjectversion: (function () { return pdfobjectversion; })(),
            supportsPDFs: (function (){ return supportsPDFs; })()
        };

    })); // END OF PDFObject

    // Media Recording

    class MediaRecordingStatus {
      static #_CLOSED = 0;
      static #_INITIALIZING = 1;
      static #_RECORDING = 2;

      static get CLOSED() { return this.#_CLOSED; }
      static get INITIALIZING() { return this.#_INITIALIZING; }
      static get RECORDING() { return this.#_RECORDING; }
    }

    // Audio Recorder object
    const audioRecorder = {
      recordingState: MediaRecordingStatus.CLOSED, /** Stores the recording state*/
      /** Stores the recorded audio as Blob objects of audio data as the recording continues*/
      audioBlobs: [],/*of type Blob[]*/
      /** Stores the reference of the MediaRecorder instance that handles the MediaStream when recording starts*/
      mediaRecorder: null, /*of type MediaRecorder*/
      /** Stores the reference to the stream currently capturing the audio*/
      streamBeingCaptured: null, /*of type MediaStream*/
      /** Start recording the audio 
       * @returns {Promise} - returns a promise that resolves if audio recording successfully started
       */
      isMediaRecordingSupported: function () {
        return !!(navigator?.mediaDevices && navigator.mediaDevices.getUserMedia);
      },
      start: function () {

        audioRecorder.recordingState = MediaRecordingStatus.INITIALIZING;

        // Feature Detection
        if (!(navigator?.mediaDevices && navigator.mediaDevices.getUserMedia)) {
          // Feature is not supported in browser
          // return a custom error
          audioRecorder.recordingState = MediaRecordingStatus.CLOSED;
          return Promise.reject(new Error("mediaDevices API or getUserMedia method is not supported in this browser."));
        } else {
          // Feature is supported in browser

          // create an audio stream
          return navigator.mediaDevices.getUserMedia({ audio: true }/*of type MediaStreamConstraints*/)
            // returns a promise that resolves to the audio stream
            .then(stream /*of type MediaStream*/ => {

              // save the reference of the stream to be able to stop it when necessary
              audioRecorder.streamBeingCaptured = stream;

              // create a media recorder instance by passing that stream into the MediaRecorder constructor
              audioRecorder.mediaRecorder = new MediaRecorder(stream); /*the MediaRecorder interface of the MediaStream Recording
              API provides functionality to easily record media*/

              // clear previously saved audio Blobs, if any
              audioRecorder.audioBlobs = [];

              // add a dataavailable event listener in order to store the audio data Blobs when recording
              audioRecorder.mediaRecorder.addEventListener("dataavailable", event => {
                // store audio Blob object
                audioRecorder.audioBlobs.push(event.data);
              });

              // start the recording by calling the start method on the media recorder
              audioRecorder.mediaRecorder.start();
              audioRecorder.recordingState = MediaRecordingStatus.RECORDING;
            });

            /* errors are not handled in the API because if its handled and the promise is chained, the .then after the catch will be executed*/
        }
      },
      /** Stop the started audio recording
       * @returns {Promise} - returns a promise that resolves to the audio as a blob file
       */
      stop: function () {
        // return a promise that would return the blob or URL of the recording
        return new Promise(resolve => {

          // save audio type to pass to set the Blob type
          const mimeType = audioRecorder.mediaRecorder.mimeType;

          // listen to the stop event in order to create & return a single Blob object
          audioRecorder.mediaRecorder.addEventListener("stop", () => {
            // create a single blob object, as we might have gathered a few Blob objects that needs to be joined as one
            const audioBlob = new Blob(audioRecorder.audioBlobs, { type: mimeType });
            audioRecorder.recordingState = MediaRecordingStatus.CLOSED;
            
            // resolve promise with the single audio blob representing the recorded audio
            resolve(audioBlob);
            audioRecorder.cancel();
          });
          audioRecorder.cancel();
        });
      },
      /** Cancel audio recording*/
      cancel: function () {
        // stop the recording feature
        audioRecorder.mediaRecorder?.stop();

        // stop all the tracks on the active stream in order to stop the stream
        audioRecorder.stopStream();

        // reset API properties for next recording
        audioRecorder.resetRecordingProperties();
      },
      /** Stop all the tracks on the active stream in order to stop the stream and remove
       * the red flashing dot showing in the tab
       */
      stopStream: function () {
        // stopping the capturing request by stopping all the tracks on the active stream
        audioRecorder.streamBeingCaptured?.getTracks() //get all tracks from the stream
          ?.forEach(track /*of type MediaStreamTrack*/ => track.stop()); //stop each one
      },
      /** Reset all the recording properties including the media recorder and stream being captured*/
      resetRecordingProperties: function () {

        audioRecorder.mediaRecorder = null;
        audioRecorder.streamBeingCaptured = null;
        audioRecorder.recordingState = MediaRecordingStatus.CLOSED;
        audioRecorder.audioBlobs = [];

        /*No need to remove event listeners attached to mediaRecorder as
        If a DOM element which is removed is reference-free (no references pointing to it), the element itself is picked
        up by the garbage collector as well as any event handlers/listeners associated with it.
        getEventListeners(audioRecorder.mediaRecorder) will return an empty array of events.*/
      }
    }; // END OF Media Recording

    const NON_STYLABLE_NODE_NAMES = ["CODE", "IFRAME", "IMG", "AUDIO", "VIDEO", "EMBED", "OBJECT", "TABLE"];
    const STYLES = [
      { tagName: "span", style: { "color": "var(--note-text-color-1)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-2)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-3)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-4)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-5)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-6)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-7)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-8)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-1)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-2)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-3)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-4)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-5)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-6)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-7)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-8)" }, attributes: null },
      { tagName: "strong", style: null, attributes: null },
      { tagName: "em", style: null, attributes: null },
      { tagName: "u", style: null, attributes: null }
    ];
    const STYLE_STRONG_INDEX = 16;
    const STYLE_EM_INDEX = 17;
    const STYLE_U_INDEX = 18;
    const STYLE_TEXT_COLOR_BASE_INDEX = -1;
    const STYLE_HIGHLIGHT_COLOR_BASE_INDEX = STYLE_TEXT_COLOR_BASE_INDEX + 8;
    const STYLE_LINK_BASE_INDEX = STYLE_HIGHLIGHT_COLOR_BASE_INDEX + 8;
    const STYLE_GROUPS = [[0, 7], [8, 15]];

    // Helper: gets all the distinct links in the text and indexes them as styles
    function updateLinkStyles(editor) {

      const links = new Set();
      editor.querySelectorAll("a").forEach((linkNode) => {
        if (linkNode.hasAttribute("href")) links.add(linkNode.getAttribute("href"));
      });

      while (STYLES[STYLES.length - 1].tagName === "a") {
        STYLES.pop();
      }

      for(let link of links) STYLES.push({tagName: "a", style: null, attributes: { "href": link }});
    }

    function generateUId() {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }
      return s4() + s4() + s4() + s4() +
             s4() + s4() + s4() + s4();
    }

    function setEditMode(editMode) {
      let editor = document.getElementById("editor");
      let toolbar = document.getElementById("toolbar");
      let filename = document.getElementById("filename");

      if (editMode) {
        editor.contentEditable = "true";
        filename.contentEditable = "plaintext-only";
        toolbar.style.display = "flex";
      }
      else {
        editor.contentEditable = "false";
        filename.contentEditable = "false";
        toolbar.style.display = "none";
      }
    }

    function removeDocumentNodes(html, editMode) {

      const template = document.createElement("template");
      template.innerHTML = html;

      template.content.querySelectorAll(".embedded-local-epub").forEach(el => {
        el.replaceChildren();
        if (editMode === false) el.setAttribute("data-readonly", "true");
      });

      /*template.content.querySelectorAll(".embedded-local-pdf").forEach(el => {
        el.replaceChildren();
      });*/

      if (editMode === false) {

        template.content.querySelectorAll(".x-remover").forEach(el => {
          el.parentNode?.removeChild(el);
        });

        template.content.querySelectorAll('*[contenteditable]').forEach(el => {
          el.setAttribute("contenteditable", "false");
        });
      }

      return template.innerHTML;
    }

    async function exportToFile(save, editMode) {

      let filename = document.getElementById("filename").innerText.trim();

      if (!filename) {
        alert("Title is empty!");
        return;
      }

      if (audioRecorder.recordingState !== MediaRecordingStatus.CLOSED) {
        alert("Stop recording before " + (save ? "saving." : "sharing."));
        return;
      }

      filename = filename.endsWith(".html") ? filename : filename + ".html";

      if (editMode === false) {
        setEditMode(false);
      }

      let content = removeDocumentNodes(document.documentElement.outerHTML, editMode);
      let blob = new Blob(["<!DOCTYPE html>\n" + content], { type: "text/html" });
      let file = new File([blob], filename, { type: "text/html" });

      if (editMode === false) {
        setEditMode(true);
      }

      if (save === false && navigator.canShare && navigator.canShare({ files: [file] })) {
        try {
          await navigator.share({
            files: [file],
            title: filename,
            text: ""
          });
        } catch (error) {
          console.error("share failed:", error);
        }
      } else {
        let a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
        URL.revokeObjectURL(a.href);
      }
    }

    function getTopLevelNodeOfCurrentPosition(useSelectionRange = null) {

      let topNode = null;
      let range = useSelectionRange;

      if (!range) {

        let selection = window.getSelection();

        if (selection?.rangeCount) {
          range = selection.getRangeAt(0);
        }
      }

      if (range) {

        let block = range.startContainer;
        const editor = document.getElementById("editor");

        if (block && block !== editor) {

          while (block.parentNode && block.parentNode !== editor) {
            block = block.parentNode;
          }

          if (block.parentNode === editor) {
            topNode = block;
          }
        }
      }

      return topNode;
    }

    function createRemover(callback = null) {

      const divNode = document.createElement("div");
      divNode.innerText = "❌";

      if (callback) {
        divNode.addEventListener("click", function (e) {
          callback();
        }, false);
      } else {
        divNode.setAttribute("onclick", "event.target?.parentNode?.parentNode?.removeChild(event.target?.parentNode)");
      }
      divNode.setAttribute("class", "x-remover non-selectable");
      divNode.setAttribute("contenteditable", "false");
      return divNode;
    }

    function insertImage(event) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextSibling;
        reader.onload = function (e) {
          const divNode = document.createElement("div");
          const img = document.createElement("img");
          img.src = e.target.result;
          divNode.appendChild(img);
          divNode.appendChild(createRemover());
          divNode.setAttribute("id", `img${generateUId()}`);
          divNode.setAttribute("class", "embedded-local-image");
          divNode.setAttribute("contenteditable", "false");
          editor.insertBefore(divNode, nextSibling);
        };
        reader.readAsDataURL(file);
      }
    }

    function insertImageLink() {

      const url = prompt("Image URL")?.trim();
      if (!url) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");
      const img = document.createElement("img");
      img.src = `${url}`;
      divNode.appendChild(img);
      divNode.appendChild(createRemover());
      divNode.setAttribute("id", `img${generateUId()}`);
      divNode.setAttribute("class", "image-link");
      divNode.setAttribute("contenteditable", "false");
      editor.insertBefore(divNode, nextSibling);
    }

    function insertAudio(event) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextSibling;
        reader.onload = function (e) {
          const divNode = document.createElement("div");
          const audio = document.createElement("audio");
          audio.src = e.target.result;
          audio.setAttribute("controls", "");
          divNode.appendChild(audio);
          divNode.appendChild(createRemover());
          divNode.setAttribute("id", `audio${generateUId()}`);
          divNode.setAttribute("class", "embedded-local-audio");
          divNode.setAttribute("contenteditable", "false");
          editor.insertBefore(divNode, nextSibling);
        };
        reader.readAsDataURL(file);
      }
    }

    function insertAudioLink() {

      const url = prompt("Audio URL")?.trim();
      if (!url) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");
      const audio = document.createElement("audio");
      audio.src = `${url}`;
      audio.setAttribute("controls", "");
      divNode.appendChild(audio);
      divNode.appendChild(createRemover());
      divNode.setAttribute("id", `audio${generateUId()}`);
      divNode.setAttribute("class", "audio-link");
      divNode.setAttribute("contenteditable", "false");
      editor.insertBefore(divNode, nextSibling);
    }

    function insertVideoLink() {

      const url = prompt("Video URL")?.trim();
      if (!url) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");
      const video = document.createElement("video");
      video.src = `${url}`;
      video.setAttribute("controls", "");
      divNode.appendChild(video);
      divNode.appendChild(createRemover());
      divNode.setAttribute("id", `video${generateUId()}`);
      divNode.setAttribute("class", "video-link");
      divNode.setAttribute("contenteditable", "false");
      editor.insertBefore(divNode, nextSibling);
    }

    const audioRecordingInserter = {

      /** Stores the audio recording node id*/
      strArId: null,

      /** Stores the audio recording node*/
      audioRecordingNode: null,

      /** Stores the audio recording node's next sibling present already in the DOM tree*/
      nextSibling: null,

      /** Stores the elapsed time node*/
      elapsedTimeTag: null,

      /** Stores the actual start time when an audio recording begins to take place to ensure elapsed time start time is accurate*/
      audioRecordStartTime: null,

      /** Stores the maximum recording time in hours to stop recording once maximum recording hour has been reached */
      maximumRecordingTimeInHours: 1,

      /** Stores the reference of the setInterval function that controls the timer in audio recording*/
      elapsedTimeTimer: null,

      /** Resets all the audioRecordingInserter's data members*/
      reset: function () {
        audioRecordingInserter.strArId = null;
        audioRecordingInserter.audioRecordingNode = null;
        audioRecordingInserter.nextSibling = null;
        audioRecordingInserter.elapsedTimeTag = null;
        audioRecordingInserter.audioRecordStartTime = null;
        audioRecordingInserter.elapsedTimeTimer = null;
      },

      /** Tries to start recording and insert the audio recording ui in the page*/
      insert: function () {

        if (!audioRecorder.isMediaRecordingSupported()) {
          console.log("Media recording is not supported in this browser.");
          alert("Media recording is not supported in this browser.");
          return;
        }

        if (audioRecorder.recordingState !== MediaRecordingStatus.CLOSED) {
          alert("A recording is already in progress.");
          return;
        }
        audioRecordingInserter.reset();

        audioRecordingInserter.nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
        audioRecordingInserter.strArId = `ar${generateUId()}`;
        audioRecordingInserter.audioRecordingNode = document.createElement("div");
        audioRecordingInserter.audioRecordingNode.setAttribute("id", audioRecordingInserter.strArId);
        audioRecordingInserter.audioRecordingNode.setAttribute("class", "audio-recording");
        audioRecordingInserter.audioRecordingNode.setAttribute("contenteditable", "false");

        const audioRecordingControlsNode = document.createElement("div");
        audioRecordingControlsNode.setAttribute("class", "recording-control-buttons-container non-selectable");
        audioRecordingControlsNode.setAttribute("contenteditable", "false");
        audioRecordingControlsNode.innerHTML = `
            <b class="cancel-recording-button non-selectable" contenteditable="false" aria-hidden="true">✖</b>
            <div class="recording-elapsed-time" contenteditable="false">
              <b class="red-recording-dot non-selectable" contenteditable="false" aria-hidden="true">🔴</b>
              <p class="elapsed-time non-selectable" style="font-size: 28px;" contenteditable="false">00:00</p>
            </div>
            <b class="stop-recording-button non-selectable" contenteditable="false" aria-hidden="true">✓</b>`;
        audioRecordingInserter.audioRecordingNode.appendChild(audioRecordingControlsNode);

        if (audioRecorder.recordingState === MediaRecordingStatus.CLOSED) {
          audioRecordingInserter.startAudioRecording();
        } else {
          audioRecordingInserter.reset();
        }
      },

      /** Starts recording using the audio recording API*/
      startAudioRecording: function () {

        console.log("Recording Audio...");

        const audioElements = document.querySelectorAll("audio");

        for (let audioElement of audioElements) {

          // If a previous audio recording is playing, pause it
          if (!audioElement.paused) {
            audioElement.pause();
          }
        }

        if (audioRecorder.recordingState !== MediaRecordingStatus.CLOSED) {
          audioRecordingInserter.reset();
          return;
        }

        // start recording using the audio recording API
        audioRecorder.start()
          .then(() => { //on success
            audioRecordingInserter.audioRecordStartTime = new Date(); // store the recording start time to display the elapsed time according to it
            editor.insertBefore(audioRecordingInserter.audioRecordingNode, audioRecordingInserter.nextSibling);
            audioRecordingInserter.elapsedTimeTag = document.querySelectorAll(`#${audioRecordingInserter.strArId} .elapsed-time`)[0];
            const stopRecordingButton = document.querySelectorAll(`#${audioRecordingInserter.strArId} .stop-recording-button`)[0];
            const cancelRecordingButton = document.querySelectorAll(`#${audioRecordingInserter.strArId} .cancel-recording-button`)[0];
            stopRecordingButton.onclick = audioRecordingInserter.stopAudioRecording;
            cancelRecordingButton.onclick = audioRecordingInserter.cancelAudioRecording;
            audioRecordingInserter.handleElapsedRecordingTime();
          })
          .catch(error => { // on error
            // No Browser Support Error
            if (error.message.includes("mediaDevices API or getUserMedia method is not supported in this browser.")) {
              console.log("To record audio, use browsers like Chrome and Firefox.");
              alert("To record audio, use browsers like Chrome and Firefox.");
            }

            // Error handling structure
            switch (error.name) {
              case "AbortError": // error from navigator.mediaDevices.getUserMedia
                console.log("An AbortError has occured.");
                break;
              case "NotAllowedError": // error from navigator.mediaDevices.getUserMedia
                console.log("A NotAllowedError has occured. User might have denied permission.");
                break;
              case "NotFoundError": // error from navigator.mediaDevices.getUserMedia
                console.log("A NotFoundError has occured.");
                break;
              case "NotReadableError": // error from navigator.mediaDevices.getUserMedia
                console.log("A NotReadableError has occured.");
                break;
              case "SecurityError": // error from navigator.mediaDevices.getUserMedia or from the MediaRecorder.start
                console.log("A SecurityError has occured.");
                break;
              case "TypeError": // error from navigator.mediaDevices.getUserMedia
                console.log("A TypeError has occured.");
                break;
              case "InvalidStateError": // error from the MediaRecorder.start
                console.log("An InvalidStateError has occured.");
                break;
              case "UnknownError": // error from the MediaRecorder.start
                console.log("An UnknownError has occured.");
                break;
              default:
                console.log("An error occured with the error name " + error.name);
            };
            audioRecordingInserter.cancelAudioRecording();
          });
      },

      /** Stops the currently started audio recording & sends it*/
      stopAudioRecording: function () {

        console.log("Stopping Audio Recording...");

        // stop the recording using the audio recording API
        audioRecorder.stop()
          .then(audioAsblob => {

            audioRecordingInserter.handleRecordingEnd();
            audioRecordingInserter.showAudioPlay(audioAsblob);
          })
          .catch(error => {
            // Error handling structure
            switch (error.name) {
              case "InvalidStateError": // error from the MediaRecorder.stop
                console.log("An InvalidStateError has occured.");
                break;
              default:
                console.log("An error occured with the error name " + error.name);
            };
            audioRecordingInserter.cancelAudioRecording();
          });
      },

      /** Cancels the currently started audio recording */
      cancelAudioRecording: function () {

        console.log("Canceling audio...");

        // cancel the recording using the audio recording API
        audioRecorder.cancel();
        audioRecordingInserter.handleRecordingEnd();

        if (editor.contains(audioRecordingInserter.audioRecordingNode)) editor.removeChild(audioRecordingInserter.audioRecordingNode);
        audioRecordingInserter.reset(); // audioRecordingInserter's job is finished here
      },

      /** Shows the audio play interface for playing the recorded audio using the audio element in the HTML document
       * @param {Blob} recorderAudioAsBlob - recorded audio as a Blob Object 
      */
      showAudioPlay: function (recorderAudioAsBlob) {

        // read content of files (Blobs) asynchronously
        let reader = new FileReader();

        // once content has been read
        reader.onload = (e) => {

          audioRecordingInserter.audioRecordingNode.innerHTML = `<audio controls src="${e.target.result}"></audio>`;
          audioRecordingInserter.audioRecordingNode.appendChild(createRemover());
          document.querySelectorAll(`#${audioRecordingInserter.strArId} audio`)[0].load();
          audioRecordingInserter.reset(); // audioRecordingInserter's job is finished here
        };

        // read content and convert it to a URL (base64)
        reader.readAsDataURL(recorderAudioAsBlob);
      },

      /** Hides the recording status bar*/
      hideRecordingStatusBar: function () {
        document.getElementById("editorContainer").classList.add("thin-line");
        document.getElementById("recordingBar").classList.add("hidden");
      },

      /** Checks if the recording animated dot is showing in the window viewport*/
      recordingDotShowingInViewport: function () {

        const dot = document.querySelectorAll(".audio-recording .red-recording-dot")[0];
        const toolbar = document.getElementById("toolbar");
        const dotRect = dot.getBoundingClientRect();
        const toolbarRect = toolbar.getBoundingClientRect();
        const wWidth = (window.innerWidth || document.documentElement.clientWidth);
        const wHeight = (window.innerHeight || document.documentElement.clientHeight);
        const dotTopOffset = 11;
        const dotBottomOffset = 6;

        return (dotRect.top + dotTopOffset < wHeight
            && dotRect.bottom - dotBottomOffset > toolbarRect.bottom
            && dotRect.left < wWidth
            && dotRect.left > -dotRect.width);
      },

      /** Displays the recording status bar if the recording animated dot is not showing in the window viewport, otherwise it hides the recording status bar*/
      showRecordingStatusBar: function () {

        if (!audioRecordingInserter.recordingDotShowingInViewport()) {
          document.getElementById("editorContainer").classList.remove("thin-line");
          document.getElementById("recordingBar").classList.remove("hidden");
        } else {
          audioRecordingInserter.hideRecordingStatusBar();
        }
      },

      /** Computes the elapsed recording time since the moment the function is called in the format h:m:s*/
      handleElapsedRecordingTime: function () {

        // display inital time when recording begins
        audioRecordingInserter.displayElapsedTimeDuringAudioRecording("00:00");
        audioRecordingInserter.showRecordingStatusBar();
        document.addEventListener("scroll", audioRecordingInserter.showRecordingStatusBar);

        // create an interval that compute & displays elapsed time, as well as, animate red dot - every second
        audioRecordingInserter.elapsedTimeTimer = setInterval(() => {
          // compute the elapsed time every second
          const elapsedTime = audioRecordingInserter.computeElapsedTime(audioRecordingInserter.audioRecordStartTime); // pass the actual record start time
          // display the elapsed time
          audioRecordingInserter.displayElapsedTimeDuringAudioRecording(elapsedTime);
        }, 1000); // every second
      },

      /** Displays elapsed time during audio recording
       * @param {String} elapsedTime - elapsed time in the format mm:ss or hh:mm:ss 
       */
      displayElapsedTimeDuringAudioRecording: function (elapsedTime) {

        // 1. display the passed elapsed time as the elapsed time in the elapsedTime HTML element
        audioRecordingInserter.elapsedTimeTag.innerHTML = elapsedTime;

        // 2. Stop the recording when the max number of hours is reached
        if (audioRecordingInserter.elapsedTimeReachedMaximumNumberOfHours(elapsedTime)) {
          audioRecordingInserter.stopAudioRecording();
        } else {
          audioRecordingInserter.showRecordingStatusBar();
        }
      },

      /**
       * @param {String} elapsedTime - elapsed time in the format mm:ss or hh:mm:ss  
       * @returns {Boolean} whether the elapsed time reached the maximum number of hours or not
       */
      elapsedTimeReachedMaximumNumberOfHours: function (elapsedTime) {

        // Split the elapsed time by the symbo :
        const elapsedTimeSplitted = elapsedTime.split(":");

        // Turn the maximum recording time in hours to a string and pad it with zero if less than 10
        const maximumRecordingTimeInHoursAsString = audioRecordingInserter.maximumRecordingTimeInHours < 10 ?
                                                      "0" + audioRecordingInserter.maximumRecordingTimeInHours :
                                                      audioRecordingInserter.maximumRecordingTimeInHours.toString();

        // if it the elapsed time reach hours and also reach the maximum recording time in hours return true
        if (elapsedTimeSplitted.length === 3 && elapsedTimeSplitted[0] === maximumRecordingTimeInHoursAsString)
          return true;
        else // otherwise, return false
          return false;
      },

      /** Computes the elapsedTime since the moment the function is called in the format mm:ss or hh:mm:ss
       * @param {String} startTime - start time to compute the elapsed time since
       * @returns {String} elapsed time in mm:ss format or hh:mm:ss format, if elapsed hours are 0.
       */
      computeElapsedTime: function (startTime) {

        // record end time
        const endTime = new Date();

        // time difference in ms
        let timeDiff = endTime - startTime;

        // convert time difference from ms to seconds
        timeDiff = timeDiff / 1000;

        // extract integer seconds that dont form a minute using %
        let seconds = Math.floor(timeDiff % 60); // ignoring uncomplete seconds (floor)

        // pad seconds with a zero if neccessary
        seconds = seconds < 10 ? "0" + seconds : seconds;

        // convert time difference from seconds to minutes using %
        timeDiff = Math.floor(timeDiff / 60);

        // extract integer minutes that don't form an hour using %
        let minutes = timeDiff % 60; // no need to floor possible incomplete minutes, becase they've been handled as seconds
        minutes = minutes < 10 ? "0" + minutes : minutes;

        // convert time difference from minutes to hours
        timeDiff = Math.floor(timeDiff / 60);

        // extract integer hours that don't form a day using %
        let hours = timeDiff % 24; // no need to floor possible incomplete hours, becase they've been handled as seconds

        // convert time difference from hours to days
        timeDiff = Math.floor(timeDiff / 24);

        // the rest of timeDiff is number of days
        let days = timeDiff; // add days to hours

        let totalHours = hours + (days * 24);
        totalHours = totalHours < 10 ? "0" + totalHours : totalHours;

        if (totalHours === "00") {
          return minutes + ":" + seconds;
        } else {
          return totalHours + ":" + minutes + ":" + seconds;
        }
      },

      /** Hides the displayed recording control buttons */
      handleRecordingEnd: function () {

        // stop interval that handles both time elapsed and the red dot
        if (audioRecordingInserter.elapsedTimeTimer) {
          clearInterval(audioRecordingInserter.elapsedTimeTimer);
          audioRecordingInserter.elapsedTimeTimer = null;
          console.log("Recording timer stopped.");
        }
        audioRecordingInserter.hideRecordingStatusBar();
        document.removeEventListener("scroll", audioRecordingInserter.showRecordingStatusBar);
      }
    };

    function insertAudioRecording() {
      audioRecordingInserter.insert();
    }

    function loadAllReferencedDocuments() {

      document.querySelectorAll(".embedded-local-epub").forEach(async el => {
        const dataUrl = el.getAttribute("data-epub");
        await loadEpub(dataUrl, null, el);
      });

      /*document.querySelectorAll(".embedded-local-pdf").forEach(async el => {
        const dataUrl = el.getAttribute("data-pdf");
        await loadPdf(dataUrl, null, el);
      });*/
    }

    function insertEpub(event, element = null) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextSibling;
        reader.onload = async function (e) {
          loadEpub(e.target?.result, nextSibling);
        }
        reader.readAsDataURL(file);
      }
    }

    function loadEpub(epubData, nextSibling, element = null) {

      if (epubData) {

        let book = null;
        const epubId = generateUId();
        const strEpubId = `epub${epubId}`;
        element?.replaceChildren();
        const divNode = element || document.createElement("div");
        divNode.setAttribute("class", "embedded-local-epub epub-loading");
        divNode.setAttribute("contenteditable", "false");
        divNode.setAttribute("data-epub", epubData);
        if (!element) editor.insertBefore(divNode, nextSibling);

        setTimeout(async () => {

          try {
            //book = ePub(epubData, { openAs: "base64" }); // BUG: not working
            book = ePub(await (await window.fetch(epubData)).blob());
          } catch (error) { // we allow ePub loading only if epub library is available and the data could be loaded
            console.log(error);
            if (editor.contains(divNode)) editor.removeChild(divNode);
            return;
          }
          const strTocId = `toc${epubId}`;

          const navButtons = document.createElement("div");
          navButtons.style = "float: top; display: flow-root;";
          navButtons.setAttribute("contenteditable", "false");
          const prev = document.createElement("div");
          const next = document.createElement("div");
          prev.setAttribute("id", `prev${epubId}`);
          next.setAttribute("id", `next${epubId}`);
          prev.setAttribute("class", "non-selectable");
          next.setAttribute("class", "non-selectable");
          prev.textContent = "<PREV";
          next.textContent = "NEXT>";
          prev.style = "float: left; left: 0; margin: 5px 5px; cursor: pointer;";
          next.style = "float: right; right: 0; margin: 5px 5px; cursor: pointer;";
          prev.setAttribute("contenteditable", "false");
          next.setAttribute("contenteditable", "false");
          navButtons.appendChild(prev);
          navButtons.appendChild(next);

          const selectToc = document.createElement("select");
          const divEbook = document.createElement("div");
          divEbook.style = "flex: top;";
          divEbook.setAttribute("class", "ebook-content");
          divEbook.setAttribute("id", strEpubId);
          selectToc.style = "float: top; left: 0; margin: 5px 5px; background: inherit; color: inherit;";
          selectToc.setAttribute("id", strTocId);
          divNode.appendChild(selectToc);

          divNode.appendChild(navButtons);

          divNode.appendChild(divEbook);
          divEbook.book = book;
          const readonly = divNode.getAttribute("data-readonly") ?? false;

          if (!readonly) {
            divNode.appendChild(createRemover(function () {
              book.destroy();
              if (editor.contains(divNode)) editor.removeChild(divNode);
            }));
          }
          const rendition = book.renderTo(strEpubId, { flow: "scrolled",
                                                       width: "100%", height: 600, replacements: "base64" /*, allowScriptedContent: true*/ });

          const keyListener = function (e) {

            // Left Key
            if ((e.keyCode || e.which) === 37) {
              rendition?.prev();
            }

            // Right Key
            if ((e.keyCode || e.which) === 39) {
              rendition?.next();
            }
          };
          rendition?.on("keyup", keyListener);
          document.addEventListener("keyup", keyListener, false);

          prev.addEventListener("click", function (e) {
            rendition?.prev();
            e.preventDefault();
          }, false);

          next.addEventListener("click", function (e) {
            rendition?.next();
            e.preventDefault();
          }, false);

          const displayed = rendition?.display();
          book.loaded.navigation.then(function (toc) {

            divNode.classList.remove("epub-loading");
            const docfrag = document.createDocumentFragment();

            toc.forEach(function (chapter) {

              const option = document.createElement("option");
              option.textContent = chapter.label;
              option.setAttribute("ref", chapter.href);

              docfrag.appendChild(option);
            });
            selectToc.appendChild(docfrag);
            selectToc.onchange = function () {

              const index = selectToc.selectedIndex,
                    url = selectToc.options[index].getAttribute("ref");
              rendition?.display(url);

              return false;
            };
          });
          function navigatedTo(href) {

            let result = false;

            if (href) {

              const selectToc = document.getElementById(strTocId);
              const selectedOption = selectToc.querySelector("option[selected]");

              if (selectedOption) {
                selectedOption.removeAttribute("selected");
              }
              const allOptions = selectToc.querySelectorAll("option");

              for (let i = 0; i < allOptions.length; ++i) {

                let selected = allOptions[i].getAttribute("ref") === href;

                if (selected) {
                  allOptions[i].setAttribute("selected", "true");
                  selectToc.selectedIndex = i;
                  result = true;
                }
              }
            }

            return result;
          }
          rendition?.on("rendered", function (section) {

            const current = book.navigation && book.navigation.get(section.href);
            navigatedTo(current?.href);
          });
          rendition?.on("relocated", function (location) {

            let current = book.navigation.get(location.start?.href);

            while (current?.parent) {
              current = book.navigation.get(current.parent);
            }
            navigatedTo(current?.href);
          });
        }, 0);
      };
    }

    function insertPdf(event, element = null) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextSibling;
        reader.onload = async function (e) {
          await loadPdf(e.target?.result, nextSibling);
        }
        reader.readAsDataURL(file);
      }
    }

    async function loadPdf(pdfData, nextSibling, element = null) {

      if (pdfData) {

        element?.replaceChildren();
        const divNode = element || document.createElement("div");
        const strPdfId = divNode.getAttribute("id");

        if (!strPdfId) {
          divNode.setAttribute("id", `pdf${generateUId()}`);
        }
        divNode.setAttribute("class", "embedded-local-pdf pdf-loading");
        divNode.setAttribute("contenteditable", "false");
        //divNode.setAttribute("data-pdf", pdfData);

        if (!element) editor.insertBefore(divNode, nextSibling);

        const pdfContainer = PDFObject.embed(pdfData, divNode, {
          height: "800px",
          pdfOpenParams: {
            navpanes: 1,
            view: "FitH",
            pagemode: "thumbs"
          }
        });
        function pdfLoad(event) {
          divNode.classList.remove("pdf-loading");
          pdfContainer.removeEventListener("load", pdfLoad);
        }
        pdfContainer.addEventListener("load", pdfLoad);
        divNode.appendChild(createRemover());
      }
    }

    function insertPdfLink() {

      const url = prompt("PDF URL")?.trim();
      if (!url) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");
      divNode.setAttribute("id", `pdf${generateUId()}`);
      divNode.setAttribute("class", "pdf-link pdf-loading");
      divNode.setAttribute("contenteditable", "false");

      editor.insertBefore(divNode, nextSibling);

      const pdfContainer = PDFObject.embed(url, divNode, {
        height: "800px",
        pdfOpenParams: {
          navpanes: 1,
          view: "FitH",
          pagemode: "thumbs"
        }
      });
      function pdfLoad(event) {
        divNode.classList.remove("pdf-loading");
        pdfContainer.removeEventListener("load", pdfLoad);
      }
      pdfContainer.addEventListener("load", pdfLoad);
      divNode.appendChild(createRemover());
    }

    function insertTable(headless) {

      const dims = prompt((headless ? "Headless table" : "Table") + " rows and columns")?.trim();
      if (!dims) return;
      // Split the input into the number of rows and columns
      let r1 = -1, r2 = -1, c1 = -1, c2 = -1, i = 0, l = dims.length;
      
      while (i < l) {

        if (dims[i] >= '0' && dims[i] <= '9') {
          if (r1 < 0) {
            r1 = i++;
            continue;
          }

          if (r2 > -1) {
            if (c1 < 0) {
              c1 = i++;
              continue;
            }
          }
        } else {
          if (r1 > -1) {
            if (r2 < 0) {
              r2 = i++;
              continue;
            }

            if (c1 > -1) {
              if (c2 < 0) {
                c2 = i++;
                break;
              }
            }
          }
        }
        ++i;
      }

      if (r1 < 0 || r2 < 0 || r1 === r2 || c1 < 0 || c1 === c2) {
        alert("Invalid input.");
        return;
      }

      if (c2 < 0) {
        c2 = l;
      }
      let rows = parseInt(dims.substring(r1, r2));
      const cols = parseInt(dims.substring(c1, c2));

      if (rows < 1 || cols < 1) {
        alert("Invalid input.");
        return;
      }
      let thead = "";

      if (!headless) {
        --rows;

        for (let i = 0; i < cols; ++i) {
          thead += `\n<th scope="col" contenteditable="true">Column ${i + 1}</th>`;
        }
        thead = "<thead>\n<tr>" + thead + "\n</tr>\n</thead>";
      }
      let tbody = "";

      for (let i = 0; i < rows; ++i) {
        let tr = "";

        for (let j = 0; j < cols; ++j) {
          tr += '\n<td contenteditable="true"><br/></td>';
        }
        tr = "<tr>" + tr + "\n</tr>";
        tbody += `\n${tr}`;
      }
      tbody = "<tbody>" + tbody + "\n</tbody>";

      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");
      divNode.setAttribute("id", `table${generateUId()}`);
      divNode.setAttribute("class", "embedded-table");
      divNode.setAttribute("contenteditable", "false");
      divNode.innerHTML = ['<table contenteditable="false">', thead, tbody, "</table>"].join("\n");

      editor.insertBefore(divNode, nextSibling);
      divNode.appendChild(createRemover());
    }

    function insertText() {

      const topNode = getTopLevelNodeOfCurrentPosition();
      const p = document.createElement("p");
      p.setAttribute("id", `text${generateUId()}`);
      p.setAttribute("class", "text-block");
      p.appendChild(document.createElement("br"));
      editor.insertBefore(p, topNode?.nextSibling);
      setCaret(p, 0);
    }

    function insertCode() {

      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");
      const pre = document.createElement("pre");
      const code = document.createElement("code");
      code.setAttribute("contenteditable", "plaintext-only");
      code.style = "white-space: pre;"
      code.innerText = "\n";
      pre.appendChild(code);
      divNode.appendChild(pre);
      divNode.setAttribute("id", `code${generateUId()}`);
      divNode.setAttribute("class", "code-block");
      divNode.setAttribute("contenteditable", "true");
      editor.insertBefore(divNode, nextSibling);
      setCaret(code, 0);
    }

    function insertEmbeddedContent() {

      const iframeHtml = prompt("Embedded Page (iframe or URL)")?.trim();
      if (!iframeHtml) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");

      if (iframeHtml.length < "<IFRAME".length || !iframeHtml.toUpperCase().startsWith("<IFRAME")) {
        divNode.innerHTML = `<iframe src="${iframeHtml}" allow="fullscreen" width="100%" height="400"></iframe>`;
      } else {
        divNode.innerHTML = `${iframeHtml}`;
      }
      divNode.setAttribute("id", `embed${generateUId()}`);
      divNode.setAttribute("class", "embedded-content");
      divNode.setAttribute("contenteditable", "true");
      editor.insertBefore(divNode, nextSibling);
      setCaret(divNode, 0);
    }

    function alignText(alignmentClass) {

      let range = null;

      if (!range) {

        const selection = window.getSelection();

        if (selection?.rangeCount) {
          range = selection.getRangeAt(0);
        }
      }

      if (!range) return;

      let rootNode = range.startContainer;
      let editor = document.getElementById("editor");

      while (rootNode && rootNode.parentNode !== editor) {

        if (["TH", "TD"].includes(rootNode.nodeName)) {

          let p = 1;
          let child = rootNode;

          while (child.previousSibling) {
            child = child.previousSibling;
            if (child.nodeName === rootNode.nodeName) ++p;
          };
          let tableNode = rootNode;

          while (tableNode && tableNode.nodeName !== "TABLE") {
            tableNode = tableNode.parentNode;
          }
          tableNode?.querySelectorAll(`tr th:nth-child(${p}), tr td:nth-child(${p})`)?.forEach((el) => {

            el.classList.remove("left-text", "center-text", "right-text", "justify-text");
            el.classList.add(alignmentClass);
          });
          return;
        }
        rootNode = rootNode.parentNode;
      }
      rootNode?.classList?.remove("left-text", "center-text", "right-text", "justify-text");
      rootNode?.classList?.add(alignmentClass);
    }

    // Toggles dropdown visibility
    function toggleDropdown(id) {
      const dropdown = document.getElementById(id);
      if (dropdown.classList.contains("show")) {
        dropdown.classList.remove("show");
      } else {
        // Close any open dropdowns first
        document.querySelectorAll(".dropdown-content").forEach(el => el.classList.remove("show"));
        dropdown.classList.add("show");
      }
    }

    // Closes dropdowns if clicking outside
    document.addEventListener("click", function (e) {
      if (!e.target.closest(".dropdown")) {
        document.querySelectorAll(".dropdown-content").forEach(el => el.classList.remove("show"));
      }
    });

    // Helper: Places the caret at a given element and offset.
    function setCaret(el, pos) {
      const selection = window.getSelection();
      const range = document.createRange();
      range.setStart(el, pos);
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    class BitArray {

      #_bitCount = 0;
      #_a;

      constructor(bitCount) {
        this.#_bitCount = bitCount;
        this.#_a = new Uint32Array(Math.ceil(bitCount / 32)).fill(0);
      }

      get length() {
        return this.#_bitCount;
      }

      get isZero() {

        const n = this.#_a.length;

        for (let i = 0; i < n; ++i) {
          if (this.#_a[i] !== 0) return false;
        }

        return true;
      }

      identical(ba) {

        if (this.#_a.length === ba.#_a.length) {

          const n = this.#_a.length;

          for (let i = 0; i < n; ++i) {
            if (this.#_a[i] !== ba.#_a[i]) return false;
          }
          return true;
        }
        
        return false;
      }

      clone() {

        const ba = new BitArray(this.#_bitCount);
        ba.#_a = Uint32Array.from(this.#_a);

        return ba;
      }

      // Set the i-th bit to 1
      set(i) {

        const bigIndex = Math.floor(i / 32);
        const smallIndex = i % 32;

        this.#_a[bigIndex] = this.#_a[bigIndex] | (1 << smallIndex);
      }

      // Clear the i-th bit
      clear(i) {

        const bigIndex = Math.floor(i / 32);
        const smallIndex = i % 32;

        this.#_a[bigIndex] = this.#_a[bigIndex] & (~(1 << smallIndex));
      }

      setValue(i, value) {

        if (value) set(i);
        else clear(i);
      }

      // Return the value of the i-th bit
      get(i) {

        const bigIndex = Math.floor(i / 32);
        const smallIndex = i % 32;

        const value = this.#_a[bigIndex] & (1 << smallIndex);
        // we convert to boolean to make sure the result is always 0 or 1,
        // instead of what is returned by the mask
        return value != 0;
      }

      bitOrAssign(ba) {

        const n = Math.min(this.#_a.length, ba.#_a.length);

        for (let i = 0; i < n; ++i) {
          this.#_a[i] |= ba.#_a[i];
        }

        return this;
      }

      bitOr(ba) {
        return this.clone().bitOrAssign(ba);
      }

      bitAndAssign(ba) {

        const n = Math.min(this.#_a.length, ba.#_a.length);

        for (let i = 0; i < n; ++i) {
          this.#_a[i] &= ba.#_a[i];
        }

        return this;
      }

      bitAnd(ba) {
        return this.clone().bitAndAssign(ba);
      }

      invertAssign() {

        const n = this.#_a.length;

        for (let i = 0; i < n; ++i) {
          this.#_a[i] = ~this.#_a[i];
        }

        return this;
      }

      invert() {
        return this.clone().invertAssign();
      }
    }

    // Helper: gets the node's text
    function getNodeText(node) {

      if (node) {
        return ((node.nodeType === Node.TEXT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
            ? (node.textContent ?? "") : ((node.nodeName === "BR") ? "\n" : (node.innerText ?? "")));
      }

      return "";
    }

    // The core function that does the styling
    // using binary indexed trees
    function wrapRangeText(range, styleIndex) {

      // Checks if the node has the specified tag, style properties and attributes
      function nodeHasSameStyle(node, tagName, style, attributes) {

        if (node?.nodeName === tagName) {

          let styleOk = true;

          if (style) {
            for (let property in style) {
              if (node.style[property] !== style[property]) {
                styleOk = false;
                break;
              }
            }
          }
          let attributesOk = true;

          if (attributes) {
            for (let attribute in attributes) {
              if (((!node.hasAttribute(attribute) || !node.getAttribute(attribute)) && attributes[attribute]) ||
                  node.getAttribute(attribute) !== attributes[attribute]) {
                attributesOk = false;
                break;
              }
            }
          }

          if (styleOk && attributesOk) return true;
        }

        return false;
      }

      // For each node in the node tree returns the start and end positions in the text of the root node (specified as the argument)
      function getNodePositions(node) {

        const positions = new Map();
        let text = getNodeText(node);
        positions.set(node, {
          start: 0,
          end: text.length
        });
        const elements = [];
        node = node.hasChildNodes ? node.firstChild : null;

        while (node) {

          if (node.nodeType === Node.ELEMENT_NODE) {
            elements.push(...node.childNodes);
          }

          if (node.nodeType === Node.ELEMENT_NODE ||
              node.nodeType === Node.TEXT_NODE) {

            let prevSibling = node.previousSibling;

            while (prevSibling && !positions.has(prevSibling))
              prevSibling = prevSibling.previousSibling;

            text = getNodeText(node);
            const start = prevSibling ? positions.get(prevSibling).end : positions.get(node.parentNode).start;
            const end = start + text.length;

            positions.set(node, {
              start: start,
              end: end
            });

            while (node.nextSibling &&
                   node.nextSibling.nodeType !== Node.TEXT_NODE &&
                   node.nextSibling.nodeType !== Node.ELEMENT_NODE)
              node = node.nextSibling;
          }
          node = node.nextSibling ?? (elements.length > 0 ? elements.shift() : null);
        }

        return positions;
      }

      // For each character in the root node text (having maxTextLength) gets the styles applied to it as a bit pattern
      // (the binary indexed tree implementation)
      function getStyledPositions(positions, styles, maxTextLength) {

        const styledPositions = new Array(maxTextLength + 1);

        for (let i = 0; i < maxTextLength + 1; i++)
          styledPositions[i] = new BitArray(styles.length);

        const a = new Int32Array(maxTextLength + 1);
        let styleIndex = 0;

        for (const style of styles) {

          const styleBitPattern = new BitArray(styles.length);
          styleBitPattern.set(styleIndex++);
          const entries = positions.entries().filter(([node, value]) => nodeHasSameStyle(node, style.tagName.toUpperCase(), style.style, style.attributes));
          a.fill(0);

          for (const [_, value] of entries) {
            a[value.start] += 1;
            a[value.end] -= 1;
          }

          for (let i = 0; i < a.length - 1; ++i) {

            a[i + 1] += a[i];

            if (a[i]) styledPositions[i].bitOrAssign(styleBitPattern);
          }
        }

        return styledPositions;
      }

      // Gets the top parent node of the child node, parent that has root container as its direct parent
      // the root container argument is either the editor or a TR element (for a table's th or td cell)
      // we are working on this top parent node text to style it
      function getTopLevelNodeOf(childNode, rootContainer) {

        while (childNode && childNode.parentNode !== rootContainer) {
          childNode = childNode.parentNode;
        }

        return childNode;
      }

      // determines which type of nodes are stylable (H1-H6, P, SMALL, or any direct child of TH or TD)
      function isSelectableNodeForStyling(node) {
        return node && (node.nodeName.match(/^H[1-6]$|^P$|^SMALL$/) || ["TH", "TD"].includes(node.parentNode?.nodeName));
      }

      // Gets the list of text positions of all the nodes within the root container and within the specified range
      function getSelectionPositions(rootContainer, range) {

        const selPositions = [];

        if (range) {

          if (range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {

            const node = getTopLevelNodeOf(range.startContainer, rootContainer);

            if (node) {

              const positions = getNodePositions(node);
              const start = positions.get(range.startContainer).start + range.startOffset;
              const end = start + range.endOffset - range.startOffset;
              selPositions.push({ node: node, start: start, end: end, positions: positions });
            }
          } else {

            let nodeStart = getTopLevelNodeOf(range.startContainer, rootContainer);
            let nodeEnd = getTopLevelNodeOf(range.endContainer, rootContainer);

            while (nodeStart &&
                   nodeStart !== nodeEnd &&
                   !isSelectableNodeForStyling(nodeStart))
              nodeStart = nodeStart.nextSibling;

            while (nodeEnd &&
                   nodeStart !== nodeEnd &&
                   !isSelectableNodeForStyling(nodeEnd))
              nodeEnd = nodeEnd.previousSibling;

            if (nodeStart && nodeEnd) {

              if (nodeStart === nodeEnd) {

                const positions = getNodePositions(nodeStart);
                const start = positions.get(range.startContainer).start + range.startOffset;
                const end = positions.get(range.endContainer).start + range.endOffset;
                selPositions.push({ node: nodeStart, start: start, end: end, positions: positions });
              } else {

                let positions = getNodePositions(nodeStart);
                let start = positions.get(range.startContainer).start + range.startOffset;
                let end = positions.get(nodeStart).end;
                selPositions.push({ node: nodeStart, start: start, end: end, positions: positions });

                let node = nodeStart.nextSibling;

                while (node && node !== nodeEnd) {

                  if (node.parentNode === rootContainer && isSelectableNodeForStyling(node)) {

                    positions = getNodePositions(node);
                    start = positions.get(node).start;
                    end = positions.get(node).end;
                    selPositions.push({ node: node, start: start, end: end, positions: positions });
                  }
                  node = node.nextSibling;
                }

                positions = getNodePositions(nodeEnd);
                start = positions.get(nodeEnd).start;
                end = positions.get(range.endContainer).start + range.endOffset;
                selPositions.push({ node: nodeEnd, start: start, end: end, positions: positions });
              }
            }
          }
        }

        return selPositions;
      }

      // Creates HTML text elements and BR elements from the specified text
      function createHtmlElementsFromText(text) {

        const elements = text.split("\n");

        for (let i = elements.length - 1; i > 0; i--) {
          elements.splice(i, 0, document.createElement("br"));
        }

        return elements;
      }

      // Applies CSS style to the element
      function applyCss(element, style) {

        for (let property in style) {
          element.style[property] = style[property];
        }
      }

      // Creates the HTML node with the specified text and styles, having the specified parent
      function createHtmlNode(parentNode, text, styleBitPattern) {

        text = text.replace(/\t/, "&nbsp;"); // "&emsp;" "&ensp;"

        if (styleBitPattern.isZero) {
          parentNode.append(...createHtmlElementsFromText(text));
        } else {

          for (let i = 0; i < styleBitPattern.length; ++i) {

            if (styleBitPattern.get(i)) {

              const child = document.createElement(STYLES[i].tagName);
              
              if (STYLES[i].style) {
                applyCss(child, STYLES[i].style);
              }

              if (STYLES[i].attributes) {
                for (let attribute in STYLES[i].attributes) {
                  child.setAttribute(attribute, STYLES[i].attributes[attribute]);
                }
              }
              parentNode.appendChild(child);
              parentNode = child;
            }
          }
          parentNode.append(...createHtmlElementsFromText(text));
        }
      }

      // Rebuilds the HTML tree rooted at node and with the specified styles (specified as an array of style bit patterns, one style bit pattern for each character)
      function buildHtmlTree(node, styledPositions) {

        const text = getNodeText(node);
        const length = text.length;
        let p = 0;
        const frag = document.createDocumentFragment();

        for (let i = 1; i < length; ++i) {
          if (!styledPositions[i].identical(styledPositions[p])) {
            createHtmlNode(frag, text.substring(p, i), styledPositions[p]);
            p = i;
          }
        }

        if (p < length) {
          createHtmlNode(frag, text.substring(p), styledPositions[p]);
        }

        if (node.nodeType === Node.ELEMENT_NODE) {
          node.replaceChildren(frag);
        } else if (node.nodeType === Node.TEXT_NODE) {
          node.replaceWith(frag);
        }
      }

      // gets the current range
      if (!range) {

        const selection = window.getSelection();

        if (selection?.rangeCount) {
          range = selection.getRangeAt(0);
        }
      }

      if (!range) return;

      // finds the current root container to work on
      let rootNode = range.commonAncestorContainer;
      let rootContainer = document.getElementById("editor");

      while (rootNode && rootNode !== rootContainer) {

        if (["TH", "TD"].includes(rootNode.nodeName)) {
          rootContainer = rootNode.parentNode;
          break;
        }
        rootNode = rootNode.parentNode;
      }
      // gets all the selected nodes within the root container as a list of start and end positions within each root container's direct child text
      const selPositions = getSelectionPositions(rootContainer, range);
      const styledPositions = [];
      let removeStyle = true;

      const styleBitPattern = new BitArray(STYLES.length);
      styleBitPattern.set(styleIndex); // the bit pattern of the style we want to apply over the selected text

      // for each root container's direct selected child we get the current styling (getStyledPositions)
      for (const p of selPositions) {

        const styled = getStyledPositions(p.positions, STYLES, p.positions.get(p.node).end);

        for (let i = p.start; i < p.end; ++i) { // we compare with the current style pattern, if all the selected text contains the style completely it means we want to remove the styling
          if (styled[i].bitAnd(styleBitPattern).isZero) removeStyle = false; // if there area characters that don't have the style then we must apply the new style
        }                                                                    // otherwise we remove the style on all the characters in the range
        styledPositions.push(styled);
      }

      if (removeStyle) { // if we want to remove the styling

        styleBitPattern.invertAssign(); // we invert the current style bit pattern

        for (let i = 0; i < selPositions.length; ++i) { // for each root container's direct selected child text

          const styled = styledPositions[i];

          for (let j = selPositions[i].start; j < selPositions[i].end; ++j) {
            styled[j].bitAndAssign(styleBitPattern);      // we remove the style by applying the inverted bit pattern
          }                                               // to each of the characters' style pattern in the range
          buildHtmlTree(selPositions[i].node, styled);    // we rebuild the HTML tree rooted at node
        }
      } else {

        let styleGroupClearBitPattern = null; // if the current style is part of a style group, we create a clear styles bit pattern
                                              // to remove the other styles in the group applied to the selected text
                                              // (for example the text color styles, we don't want to apply multiple text colors over the same text)
        for (let styleGroup of STYLE_GROUPS) {

          if (styleIndex >= styleGroup[0] && styleIndex <= styleGroup[1]) {

            styleGroupClearBitPattern = new BitArray(STYLES.length);

            for (let i = styleGroup[0]; i <= styleGroup[1]; i++) {
              styleGroupClearBitPattern.set(i);
            }
            styleGroupClearBitPattern.invertAssign();  // we invert the bit pattern for all the styles in the group
            styleGroupClearBitPattern.set(styleIndex); // we let the current style bit pattern on
            break;
          }
        }

        for (let i = 0; i < selPositions.length; ++i) { // for each root container's direct selected child text

          const styled = styledPositions[i];

          for (let j = selPositions[i].start; j < selPositions[i].end; ++j) {
            if (styleGroupClearBitPattern) styled[j].bitAndAssign(styleGroupClearBitPattern); // we remove other style(s) in the same group with the current style, for each selected character
            styled[j].bitOrAssign(styleBitPattern);     // we apply the style by applying the style bit pattern
          }                                             // to each of the characters' style pattern in the range
          buildHtmlTree(selPositions[i].node, styled);  // we rebuild the HTML tree rooted at node
        }
      }
      window.getSelection().removeAllRanges(); // we remove all selection's ranges after HTML tree rebuild
    }

    // Basic inline formatting: wraps the selection in the specified tag.
    function applyFormat(styleIndex) {

      const selection = window.getSelection();

      if (!selection.rangeCount || selection.isCollapsed) return;
      const range = selection.getRangeAt(0);
      const editor = document.getElementById("editor");

      if (!editor.contains(range.commonAncestorContainer)) return;
      updateLinkStyles(editor);
      wrapRangeText(range, styleIndex);
    }

    // Applies inline style (e.g., font-size, text color, background color) by wrapping the selection in a <span>.
    function applyStyle(styleIndex) {

      const selection = window.getSelection();

      if (!selection.rangeCount || selection.isCollapsed) return;
      const range = selection.getRangeAt(0);
      const editor = document.getElementById("editor");

      if (!editor.contains(range.commonAncestorContainer)) return;
      updateLinkStyles(editor);
      wrapRangeText(range, styleIndex);
    }

    // Applies inline url 
    function applyURL() {

      const selection = window.getSelection();

      if (!selection.rangeCount || selection.isCollapsed) return;
      const range = selection.getRangeAt(0);
      const editor = document.getElementById("editor");

      if (!editor.contains(range.commonAncestorContainer)) return;
      const url = prompt("URL")?.trim();

      if (!url) return;
      updateLinkStyles(editor);
      let linkStyleIndex = STYLES.length - 1;

      for ( ; linkStyleIndex > STYLE_LINK_BASE_INDEX; linkStyleIndex--) {
        if (STYLES[linkStyleIndex].tagName === "a" &&
            STYLES[linkStyleIndex].attributes &&
            STYLES[linkStyleIndex].attributes["href"] === url) {
          break;
        }
      }

      if (linkStyleIndex <= STYLE_LINK_BASE_INDEX) {
        STYLES.push({tagName: "a", style: null, attributes: { "href": url }});
        linkStyleIndex = STYLES.length - 1;
      }

      wrapRangeText(range, linkStyleIndex);
    }

    // Called by the text size dropdown.
    function applyTextSize(size) {

      if (!size) return;
      //applyStyle({"font-size": `${size}`});
    }

    // Called when a text color swatch is clicked.
    function applyTextColor(color) {

      if (!color) return;
      applyStyle(STYLE_TEXT_COLOR_BASE_INDEX + color);
    }

    // Called when a highlight (background color) swatch is clicked.
    function applyHighlightColor(color) {

      if (!color) return;
      applyStyle(STYLE_HIGHLIGHT_COLOR_BASE_INDEX + color);
    }

    // Converts the current block (direct child of #editor) to the chosen tag.
    function changeBlock(tag) {

      const selection = window.getSelection();

      if (!selection.rangeCount || selection.rangeCount > 1) return;
      let node = selection.anchorNode;
      const editor = document.getElementById("editor");

      while (node && node.parentNode !== editor) { // finds current node, child of editor
        if (NON_STYLABLE_NODE_NAMES.includes(node.nodeName)) return;
        node = node.parentNode;
      }

      if (!node || node === editor) return;
      if (NON_STYLABLE_NODE_NAMES.includes(node.nodeName)) return;

      if (node.nodeName === tag.toUpperCase()) return;

      const newBlock = document.createElement(tag);
      newBlock.id = node.id;
      newBlock.setAttribute("class", node.getAttribute("class"));

      while (node.firstChild) { // adds current node's children to the new block, one by one; except if a child is a P and the new tag is a H[1-6]
        if (
          node.firstChild.nodeType === Node.ELEMENT_NODE &&
          node.firstChild.matches("p") &&
          tag.match(/^H[1-6]$/)
        ) {
          // then adds the child's children directly to the new block
          // (instead of adding the child directly: P into another H[1-6])
          let child = node.firstChild;

          while (child.firstChild) {
            newBlock.appendChild(child.firstChild);
          }
          node.removeChild(child); // removes the intermediary child P node
        } else {
          newBlock.appendChild(node.firstChild);
        }
      }
      editor.replaceChild(newBlock, node); // replaces the node with the new block
      const range = document.createRange(); // keeps the selection (reconstructed)
      range.selectNodeContents(newBlock);
      range.collapse(false);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    // Splits the current block at the caret.
    function splitBlock(range) {

      if (!range) return;
      const editor = document.getElementById("editor");
      let block = range.startContainer;

      while (block && block.parentNode !== editor) {
        block = block.parentNode;
      }

      if (!block) { // adds a new empty text block (paragraph) at the end of the document

        const p = document.createElement("p");
        p.setAttribute("id", `text${generateUId()}`);
        p.setAttribute("class", "text-block");
        p.innerHTML = "<br/>";
        editor.appendChild(p);
        setCaret(p, 0);
        return;
      }
      const afterRange = range.cloneRange();
      afterRange.setStart(range.endContainer, range.endOffset); // checks what follows after the caret in the current block
      afterRange.setEndAfter(block.lastChild || block);
      const afterContent = afterRange.cloneContents();

      // caret is at end of current block:
      // if the after range does not have some content (nested elements or non-empty text)
      const isAtEnd = !Array.from(afterContent.childNodes).some(n => {
        return (n.nodeType === Node.ELEMENT_NODE) ||
               (n.nodeType === Node.TEXT_NODE && n.textContent.trim());
      });
      const isTextBlock = block.classList?.contains("text-block");
      const newBlock = document.createElement(isTextBlock ? block.nodeName.toLowerCase() : "p");
      newBlock.setAttribute("id", `text${generateUId()}`);
      newBlock.setAttribute("class", isTextBlock ? block.getAttribute("class") : "text-block");

      if (isAtEnd) { // if the caret is at the end of current block, then add an empty text-block, next to current block

        newBlock.innerHTML = "<br/>";
      } else { // else append the last (from caret to end of block) children of the current block into a new text-block

        const extractRange = range.cloneRange();
        extractRange.setEndAfter(block.lastChild || block);
        const extracted = extractRange.extractContents(); // selects all content from start of caret to end of current block

        if (!extracted.childNodes.length || !getNodeText(extracted).length) { // this should not happen: this means the caret is at the end of current block
          newBlock.innerHTML = "<br/>";
        } else {
          newBlock.appendChild(extracted);
        }
      }

      if (block.nextSibling) {
        editor.insertBefore(newBlock, block.nextSibling);
      } else {
        editor.appendChild(newBlock);
      }
      setCaret(newBlock, 0); // move the caret into the new block

      if (!block.textContent?.trim() && !block?.querySelector("img, video, iframe, embed, object")) {
        block.innerHTML = "<br/>";
      }
    }

    // Normalizes stray text nodes and nested blocks.
    function normalizeEditor() {

      const editor = document.getElementById("editor");
      Array.from(editor.childNodes).forEach(node => {

        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {

          const p = document.createElement("p");
          p.setAttribute("id", `text${generateUId()}`);
          p.setAttribute("class", "text-block");
          p.textContent = node.textContent;
          editor.replaceChild(p, node);
        }
      });
      editor.querySelectorAll("p p, h1 p, h2 p, h3 p, h4 p, h5 p, h6 p, p font, small p").forEach(nested => {

        const parent = nested.parentNode;

        if (!parent.id && nested.childElementCount === 1) {

          parent.insertBefore(nested.firstChild, nested);
          parent.removeChild(nested);
          parent.id = nested.id;
          return ;
        }

        while (nested.firstChild) {
          parent.insertBefore(nested.firstChild, nested);
        }
        parent.removeChild(nested);
      });
    }

    // Normalize stray text nodes and nested blocks.
    function cleanEditor() {

      const editor = document.getElementById("editor");

      if (editor.firstChild && ["H1", "H2", "H3", "H4", "H5", "H6", "P"].includes(editor.firstChild.nodeName)) {
        return;
      }
      const htmlText = editor.innerHTML.trim();

      if (htmlText === "" || htmlText === "<br>" || htmlText === "<br/>") {
        editor.innerHTML = `<p class="text-block" id="text${generateUId()}"><br/></p>`;
      }
    }

    function updateTitle() {

      let filename = document.getElementById("filename");

      if (filename.innerHTML === "<br>" || filename.innerHTML === "<br/>") {
        filename.innerHTML = "";
      }
      document.title = filename.innerHTML.trim() || "Nash Note";
    }

    /*function printSelectionInfo() {
      const selection = window.getSelection();
      console.log("selection: ", selection);

      if (selection?.rangeCount) {
        const range = selection.getRangeAt(0);
        console.log("range: ", range);
      }
    }*/

    function handleEnterKey(range, parentNodeNames) {

      let block = range?.startContainer;

      while (block && block !== editor) {

        if (block.nodeType === Node.ELEMENT_NODE && parentNodeNames.includes(block.nodeName)) {

          const textNode = range.startContainer;

          if (parentNodeNames.includes(textNode.nodeName)) {

            //printSelectionInfo();

            if (textNode.childNodes.length > range.startOffset) {
              textNode.insertBefore(document.createElement("br"), textNode.childNodes[range.startOffset]);
            } else {
              textNode.appendChild(document.createElement("br"));
            }
            setCaret(textNode, range.startOffset + 1);
          } else if (textNode.nodeName === "BR") {

            //printSelectionInfo();
            const brNode = document.createElement("br");
            textNode.parentNode.insertBefore(brNode, textNode.nextSibling);
            setCaret(brNode, 0);
          } else if (textNode.nodeType === Node.TEXT_NODE) {

            //printSelectionInfo();
            const text1 = textNode.textContent.substring(0, range.startOffset);
            const text2 = textNode.textContent.substring(range.startOffset);
            const newTextNode = (text2 && text2 !== "") ? document.createTextNode(text2) : null;
            const parentNode = textNode.parentNode;
            const nextSibling = textNode.nextSibling;
            const brNode = document.createElement("br");
            parentNode.insertBefore(brNode, nextSibling);

            if (text1 && text1 !== "") {

              if (textNode.textContent !== text1) {
                textNode.textContent = text1;
              }
            } else {
              parentNode.removeChild(textNode);
            }

            if (newTextNode) {

              parentNode.insertBefore(newTextNode, nextSibling);
              setCaret(newTextNode, 0);
            } else if (text1 && text1 !== "") {

              if (!nextSibling) {

                const brNode2 = document.createElement("br");
                parentNode.insertBefore(brNode2, nextSibling);
                setCaret(parentNode, [...parentNode.childNodes].indexOf(brNode2));
              } else {
                setCaret(parentNode, [...parentNode.childNodes].indexOf(nextSibling));
              }
            } else {

              const brNode2 = document.createElement("br");
              parentNode.insertBefore(brNode2, nextSibling);
              setCaret(brNode2, 0);
            }
          }
          return true;
        }
        block = block.parentNode;
      }

      return false;
    }

    function keydownHandler(e) {

      let range = null;
      const selection = window.getSelection();

      if (selection.rangeCount) {
        range = selection.getRangeAt(0);
      }
      const block = range?.startContainer;

      if (block) {

        const blockedNodeClasses = [
          "embedded-local-epub",
          "embedded-local-pdf",
          "embedded-local-image",
          "embedded-local-audio",
          "embedded-table",
          "image-link",
          "audio-link",
          "video-link",
          "pdf-link",
          "audio-recording",
          "recording-control-buttons-container"
        ];

        if (block.parentNode &&
            [...block.parentNode.classList].some(c => blockedNodeClasses.indexOf(c) !== -1)) {
            e.stopImmediatePropagation();
            e.preventDefault();
            return;
        }
      }

      if (e.key === "Enter" && !e.shiftKey) {

        if (block && handleEnterKey(range, ["CODE", "TD", "TH"])) {

          e.stopImmediatePropagation();
          e.preventDefault();
          return;
        }
        e.preventDefault();
        splitBlock(range);
        return;
      }

      if (e.key === "Backspace" && range.startContainer === range.endContainer && range.startOffset === range.endOffset && range.startOffset === 0) {

        const topNode = getTopLevelNodeOfCurrentPosition();

        if (topNode) {

          // blocks moving of the current line in the code block into the previous sibling p node
          if (topNode.classList.contains("code-block") && !(block?.previousSibling)) {
            e.stopImmediatePropagation();
            e.preventDefault();
            return;
          }

          if (topNode.classList.contains("text-block")) {

            if (!block.previousSibling && (!topNode.previousElementSibling ||
                !topNode.previousElementSibling.classList?.contains("text-block"))) {
              e.stopImmediatePropagation();
              e.preventDefault();
              return;
            }

            if (topNode === block &&
                (!topNode.previousElementSibling ||
                !topNode.previousElementSibling.classList?.contains("text-block"))) {
              e.stopImmediatePropagation();
              e.preventDefault();
              return;
            }

            if (topNode.previousElementSibling &&
                !topNode.previousElementSibling.classList?.contains("text-block")) {
              e.stopImmediatePropagation();
              e.preventDefault();
              return;
            }
          }
        }
      }

      if ((e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'y')) {
        e.preventDefault();
      }
    }

    function clickHandler(e) {
      const target = e.target.closest("a");
      if (!target || !document.getElementById("editorContainer").contains(target)) return;

      e.preventDefault();

      const userConfirmed = confirm(`"${target.href}" open this url?`);
      if (userConfirmed) {
        window.open(target.href, "_blank");
      }
    }

    function unloadHandler(e) {
      if (document.getElementById("editor").contentEditable !== "true") {
        return;
      }
      e.preventDefault()
      e.returnValue = '';
    }

    let lastValidSelectionRange = null;

    document.onselectionchange = () => {
      const selection = document.getSelection();

      if (selection?.rangeCount) {

        const range = selection.getRangeAt(0);

        if (editor.contains(range.startContainer)) {
          lastValidSelectionRange = range;
        }
      }
    };

    let editor = document.getElementById("editor");
    let filename = document.getElementById("filename");

    editor.addEventListener("keydown", keydownHandler);
    editor.addEventListener("click", clickHandler);
    editor.addEventListener("blur", normalizeEditor);
    editor.addEventListener("input", cleanEditor);
    editor.addEventListener("focus", cleanEditor);

    filename.addEventListener("input", updateTitle);

    window.addEventListener("beforeunload", unloadHandler);

    loadAllReferencedDocuments();

    document.querySelectorAll(".text-block").forEach(el => {
      if (!el.getAttribute("id")) el.setAttribute("id", `text${generateUId()}`);
    });

    updateTitle();

    /* Event handlers */

    document.getElementById("btnH1").addEventListener("click", (e) => changeBlock("h1"));
    document.getElementById("btnH2").addEventListener("click", (e) => changeBlock("h2"));
    document.getElementById("btnM").addEventListener("click", (e) => changeBlock("p"));
    document.getElementById("btnS").addEventListener("click", (e) => changeBlock("small"));

    document.getElementById("btnB").addEventListener("click", (e) => applyFormat(STYLE_STRONG_INDEX));
    document.getElementById("btnI").addEventListener("click", (e) => applyFormat(STYLE_EM_INDEX));
    document.getElementById("btnU").addEventListener("click", (e) => applyFormat(STYLE_U_INDEX));
    document.getElementById("btnLink").addEventListener("click", (e) => applyURL());

    document.getElementById("imageUpload").addEventListener("change", (e) => insertImage(e));
    document.getElementById("btnImageLink").addEventListener("click", (e) => insertImageLink());

    document.getElementById("btnTextColorMenu").addEventListener("click", (e) => toggleDropdown("textColorDropdown"));
    
    for (let i = 1; i < 9; ++i) {
      document.getElementById(`btnTextColor${i}`).addEventListener("click", (e) => {
        applyTextColor(i);
        toggleDropdown("textColorDropdown");
      });
    }

    document.getElementById("btnTextHighlightMenu").addEventListener("click", (e) => toggleDropdown("highlightDropdown"));
    
    for (let i = 1; i < 9; ++i) {
      document.getElementById(`btnTextHighlight${i}`).addEventListener("click", (e) => {
        applyHighlightColor(i);
        toggleDropdown("highlightDropdown");
      });
    }

    document.getElementById("btnText").addEventListener("click", (e) => insertText());
    document.getElementById("btnCode").addEventListener("click", (e) => insertCode());
    document.getElementById("btnEmbedContent").addEventListener("click", (e) => insertEmbeddedContent());

    document.getElementById("audioUpload").addEventListener("change", (e) => insertAudio(event));

    document.getElementById("btnAudioLink").addEventListener("click", (e) => insertAudioLink());
    document.getElementById("btnRecordAudio").addEventListener("click", (e) => insertAudioRecording());
    document.getElementById("btnVideoLink").addEventListener("click", (e) => insertVideoLink());

    document.getElementById("epubUpload").addEventListener("change", (e) => insertEpub(e));
    document.getElementById("pdfUpload").addEventListener("change", (e) => insertPdf(e));

    document.getElementById("btnPdfLink").addEventListener("click", (e) => insertPdfLink());
    document.getElementById("btnTable").addEventListener("click", (e) => toggleDropdown("tableDropdown"));
    document.getElementById("btnSimpleTable").addEventListener("click", (e) => {
      toggleDropdown("tableDropdown");
      insertTable(false);
    });
    document.getElementById("btnHeadlessTable").addEventListener("click", (e) => {
      toggleDropdown("tableDropdown");
      insertTable(true);
    });

    document.getElementById("btnAlign").addEventListener("click", (e) => toggleDropdown("alignDropdown"));
    document.getElementById("btnLeftTextAlign").addEventListener("click", (e) => {
      toggleDropdown("alignDropdown");
      alignText("left-text");
    });
    document.getElementById("btnCenterTextAlign").addEventListener("click", (e) => {
      toggleDropdown("alignDropdown");
      alignText("center-text");
    });
    document.getElementById("btnRightTextAlign").addEventListener("click", (e) => {
      toggleDropdown("alignDropdown");
      alignText("right-text");
    });
    document.getElementById("btnJustifyTextAlign").addEventListener("click", (e) => {
      toggleDropdown("alignDropdown");
      alignText("justify-text");
    });

    document.getElementById("btnSaveMenu").addEventListener("click", (e) => toggleDropdown("saveDropdown"));
    document.getElementById("btnSave").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(true, true);
    });
    document.getElementById("btnShare").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(false, true);
    });
    document.getElementById("btnSaveReadOnly").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(true, false);
    });
    document.getElementById("btnShareReadOnly").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(false, false);
    });

    editor.focus();
  </script>

</body>

</html>