<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nash Note</title>
  <link rel="icon" type="image/svg+xml"
    href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%20100%20100%22%3E%0A%20%20%3Crect%20width%3D%22100%22%20height%3D%22100%22%20rx%3D%2220%22%20fill%3D%22black%22%2F%3E%0A%20%20%3Ctext%20x%3D%2250%25%22%20y%3D%2250%25%22%20font-size%3D%2260%22%20font-weight%3D%22bold%22%20text-anchor%3D%22middle%22%20fill%3D%22white%22%20font-family%3D%22Arial%2C%20sans-serif%22%20dominant-baseline%3D%22central%22%3EN.%3C%2Ftext%3E%0A%3C%2Fsvg%3E" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mathup/dist/mathup.css" />
  <style>
    :root {
      --page-bg-color: #f8f9fa;
      --page-text-color: #333;

      --control-bg-color: #f8f9fa;
      --control-text-color: buttontext;
      --control-hover-bg-color: #f0f0f0;
      --control-hover-text-color: #bbb;

      --control-disabled-bg-color: #f8f9fa;
      --control-disabled-text-color: #bbb;

      --note-bg-color: #fff;
      --note-placeholer-color: #bbb;
      --note-link-color: #616161;

      --attribution-color: #bbb;

      --code-bg-color: #e5e4e2;
      --code-text-color: #333;

      --audio-recording-controls-bg-color: #e5e4e2;
      --audio-recording-controls-text-color: #333;

      --table-border-color: #000;

      /* text colors */
      --note-text-color-1: #000000;
      /* black */
      --note-text-color-2: #FF3B30;
      /* red */
      --note-text-color-3: #FF9500;
      /* orange */
      --note-text-color-4: #FFCC00;
      /* yellow */
      --note-text-color-5: #4CD964;
      /* green */
      --note-text-color-6: #5AC8FA;
      /* light-blue */
      --note-text-color-7: #007AFF;
      /* dark-blue */
      --note-text-color-8: #5856D6;
      /* violet */

      /* highlight background colors */
      --note-highlight-color-1: #000000;
      /* red */
      --note-highlight-color-2: #FF3B30;
      /* orange */
      --note-highlight-color-3: #FF9500;
      /* yellow */
      --note-highlight-color-4: #FFCC00;
      /* green */
      --note-highlight-color-5: #4CD964;
      /* light-blue */
      --note-highlight-color-6: #5AC8FA;
      /* violet */
      --note-highlight-color-7: #007AFF;
      /* dark-blue */
      --note-highlight-color-8: #5856D6;
      /* purple */
    }

    /* dark mode */
    @media (prefers-color-scheme: dark) {
      :root {
        --page-bg-color: #3a3a3a;
        --page-text-color: #ddd;

        --control-bg-color: #444;
        --control-text-color: #aaa;
        --control-hover-bg-color: #666;
        --control-hover-text-color: #eee;

        --control-disabled-bg-color: #444;
        --control-disabled-text-color: #666;

        --note-bg-color: #333;
        --note-placeholder-color: #555;

        --code-bg-color: #36454f;
        --code-text-color: #fff;

        --audio-recording-controls-bg-color: #36454f;
        --audio-recording-controls-text-color: #fff;

        --table-border-color: #fff;

        /* text colors */
        --note-text-color-1: #FAFAFA;
        /* black / white */
        --note-text-color-2: #FF3B30;
        /* red */
        --note-text-color-3: #FF9500;
        /* orange */
        --note-text-color-4: #FFCC00;
        /* yellow */
        --note-text-color-5: #4CD964;
        /* green */
        --note-text-color-6: #5AC8FA;
        /* light-blue */
        --note-text-color-7: #007AFF;
        /* dark-blue */
        --note-text-color-8: #5856D6;
        /* violet */

        /* highlight background colors */
        --note-highlight-color-1: #FAFAFA;
        /* red */
        --note-highlight-color-2: #FF3B30;
        /* orange */
        --note-highlight-color-3: #FF9500;
        /* yellow */
        --note-highlight-color-4: #FFCC00;
        /* green */
        --note-highlight-color-5: #4CD964;
        /* light-blue */
        --note-highlight-color-6: #5AC8FA;
        /* violet */
        --note-highlight-color-7: #007AFF;
        /* dark-blue */
        --note-highlight-color-8: #5856D6;
        /* purple */
      }
    }

    body {
      font-family: 'Arial', sans-serif;
      background-color: var(--page-bg-color);
      color: var(--page-text-color);
      margin: 0;
      padding: 40px;
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .editor-container {
      width: 100%;
      max-width: 90%;
      background: var(--note-bg-color);
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0px 5px 15px rgba(0, 0, 0, 0.1);
    }

    .file-title {
      font-size: 28px;
      font-weight: bold;
      margin-bottom: 15px;
      padding: 0px 15px;
      outline: none;
      border: none;
      width: 100%;
      background: transparent;
    }

    .file-title:empty::before {
      content: "Write your title here...";
      color: var(--note-placeholder-color);
      display: block;
    }

    .top-container {
      position: sticky;
      position: -webkit-sticky;
      top: 5px;
      padding: 0 10px;
      z-index: 9999;
    }

    #toolbar {
      gap: 8px;
      background-color: var(--control-bg-color);
      border-radius: 12px;
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      align-items: center;
    }

    #toolbar #splitbar {
      font-size: 24px;
    }

    #toolbar input[type="file"] {
      display: none;
    }

    #toolbar button,
    #toolbar label,
    #toolbar select {
      padding: 8px;
      border: none;
      background: none;
      color: var(--control-text-color);
      font-size: 24px;
      cursor: pointer;
      transition: opacity 0.2s
    }

    #toolbar button:hover,
    #toolbar label:hover,
    #toolbar select:hover {
      background: var(--control-hover-bg-color);
      border-color: var(--control-hover-text-color);
      color: var(--control-hover-text-color);
    }

    #toolbar button:disabled,
    #toolbar label:disabled,
    #toolbar select:disabled {
      background: var(--control-disabled-bg-color);
      border-color: var(--control-disabled-text-color);
      color: var(--control-disabled-text-color);
      cursor: not-allowed;
    }

    /* Dropdown container */
    .dropdown {
      position: relative;
      display: inline-block;
    }

    /* Dropdown button style */
    .dropdown > button {
      padding: 6px 10px;
    }

    /* Dropdown content (hidden by default) */
    .dropdown-content {
      display: none;
      position: absolute;
      top: 110%;
      left: 0;
      background: var(--control-bg-color);
      border: 1px solid var(--control-bg-color);
      color: var(--control-text-color);
      padding: 8px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      z-index: 10;
    }

    /* Show dropdown when .show is added */
    .dropdown-content.show {
      display: block;
    }

    /* Text dropdown container */
    .text-dropdown {
      position: relative;
      display: inline-block;
    }

    /* Text dropdown button style */
    .text-dropdown > button {
      padding: 6px 10px;
    }

    .text-dropdown button {
      width: 100%;
      text-align: left;
    }

    .text-dropdown .fileUpload label {
      max-width: 100%;
      text-align: left;
      display: block;
    }

    /* Text dropdown content (hidden by default) */
    .text-dropdown-content {
      display: none;
      position: absolute;
      width: 200px;
      top: 110%;
      left: 0;
      background: var(--control-bg-color);
      border: 1px solid var(--control-bg-color);
      color: var(--control-text-color);
      padding: 8px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      z-index: 10;
    }

    /* Show text dropdown when .show is added */
    .text-dropdown-content.show {
      display: block;
    }

    /* Grid of swatches */
    .swatch-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, 24px);
      gap: 6px;
    }

    .color-swatch {
      width: 24px;
      height: 24px;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .color-swatch:hover {
      transform: scale(1.1);
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);
    }

    #fontSizeDropdown {
      width: 100px;
    }

    #alignDropdown {
      width: 100px;
    }

    #linksDropdown {
      width: 180px;
    }

    #embedDropdown {
      width: 130px;
    }

    #saveDropdown {
      width: 270px;
      right: 0;
      left: auto;
    }

    #editor {
      border-radius: 12px;
      padding: 15px;
      min-height: 250px;
      outline: none;
      font-size: 16px;
      line-height: 1.6;
      /* background: #f4f4f4; */
    }

    #editor p {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
    }

    #editor a {
      color: var(--note-link-color);
      text-decoration: none;
      font-weight: 800;
      transition: all 0.2s ease-in-out;
      border-bottom: 2px solid transparent;
    }

    #editor a:hover {
      border-bottom: 2px solid var(--note-link-color);
      color: var(--note-link-color);
    }

    #editor pre code {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
      background: var(--code-bg-color);
      color: var(--code-text-color);
      display: block;
      margin: 0;
      padding: 8px;
      border-radius: 6px;
      white-space: pre-line;
    }

    #footer {
      text-align: center;
      margin-top: 20px;
      color: var(--attribution-color);
    }

    #footer a {
      text-decoration: none;
      color: var(--attribution-color);
    }

    .non-selectable {
      user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      -webkit-touch-callout: none;
      -o-user-select: none;
      -moz-user-select: none;
    }

    img {
      max-width: 100%;
      height: auto;
      display: block;
      border-radius: 12px;
    }

    audio {
      width: 100%;
      display: block;
    }

    video {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 12px;
    }

    .image-link {
      margin: 10px 0;
    }

    .video-link {
      margin: 10px 0;
    }

    .audio-link {
      margin: 10px 0;
    }

    .embedded-local-image {
      margin: 10px 0;
    }

    .embedded-local-audio {
      margin: 10px 0;
    }

    .embedded-content {
      margin: 10px 0;
    }

    .embedded-math {
      margin: 10px 0;
    }

    .embedded-math mrow,
    .embedded-math math {
      font-size: 28px;
    }

    .embedded-local-epub {
      margin: 20px 0;
    }

    .embedded-local-pdf {
      margin: 20px 0;
    }

    .pdf-link {
      margin: 20px 0;
    }

    .embedded-table {
      margin: 10px 0;
    }

    .embedded-table table {
      width: 100%;
      height: auto;
      padding: 0 0;
      margin: 0 0;
      text-align: left;
      table-layout:fixed;
      border: 1px solid var(--table-border-color);
      border-collapse: collapse;
      border-spacing: 0;
    }

    .embedded-table table th,
    .embedded-table table td {
      overflow: hidden;
      border: 1px solid var(--table-border-color);
      margin: 0 0;
      padding: 0 8px;
    }

    .epub-loading::before {
      content: "ePUB document is loading...";
      display: block;
      color: var(--note-placeholer-color);
      margin: 0;
    }

    .pdf-loading::before {
      content: "PDF document is loading...";
      display: block;
      color: var(--note-placeholer-color);
      margin: 0;
    }

    .thin-line::before {
      content: "";
      display: block;
      width: 100%;
      height: 1px;
      background-color: var(--control-bg-color);
      color: var(--control-text-color);
      margin: 10px 0;
    }

    .embedded-local-epub,
    .embedded-local-pdf,
    .embedded-local-image,
    .embedded-local-audio,
    .embedded-content,
    .embedded-math,
    .embedded-table,
    .image-link,
    .audio-link,
    .video-link,
    .pdf-link,
    .audio-recording {
      width: 100%;
      height: auto;
      display: block;
      position: relative;
    }

    .x-remover {
      background-color: #aaa;
      padding: 6.5px 6.7px 3.8px 6.5px;
      color: #ff3b30;
      display: none;
      position: absolute;
      top: 0;
      right: 0;
      margin-top: -10px;
      margin-right: -10px;
      font-weight: 700;
      border-radius: 50%;
      border: 1px solid #333;
      text-align: center;
      line-height: 20px;
      font-family: sans-serif;
      cursor: pointer;
    }

    .embedded-local-epub:hover .x-remover,
    .embedded-local-pdf:hover .x-remover,
    .embedded-local-image:hover .x-remover,
    .embedded-local-audio:hover .x-remover,
    .embedded-content:hover .x-remover,
    .embedded-math:hover .x-remover,
    .embedded-table:hover .x-remover,
    .image-link:hover .x-remover,
    .audio-link:hover .x-remover,
    .video-link:hover .x-remover,
    .pdf-link:hover .x-remover,
    .audio-recording:hover .x-remover {
      display: block;
    }

    /* Audio Recording UI */

    #recordingBar {
      content: "";
      display: block;
      height: 4px;
      border-radius: 2px;
      background-color: red;
      color: red;
      margin: 10px 0;
      /*transitions with Firefox, IE and Opera Support browser support*/
      animation-name: flashing-recording-dot;
      -webkit-animation-name: flashing-recording-dot;
      -moz-animation-name: flashing-recording-dot;
      -o-animation-name: flashing-recording-dot;
      animation-duration: 2s;
      -webkit-animation-duration: 2s;
      -moz-animation-duration: 2s;
      -o-animation-duration: 2s;
      animation-iteration-count: infinite;
      -webkit-animation-iteration-count: infinite;
      -moz-animation-iteration-count: infinite;
      -o-animation-iteration-count: infinite;
    }

    #recordingBar.hidden {
      display: none;
    }

    .audio-recording {
      margin: 20px 0;
    }

    .recording-control-buttons-container {
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      justify-content: space-evenly;
      /*horizontal centering*/
      align-items: center;
      width: 100%;
      height: auto;
      margin: 0;
      border-radius: 12px;
      background-color: var(--audio-recording-controls-bg-color);
      color: var(--audio-recording-controls-text-color);
    }

    .recording-cancelled-container {
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      align-items: start;
      width: 100%;
      height: auto;
      margin: 0;
      padding: 10px 0px;
      border-radius: 12px;
      background-color: var(--audio-recording-controls-bg-color);
      color: var(--audio-recording-controls-text-color);
    }

    .cancel-recording-button,
    .stop-recording-button {
      font-size: 32px;
      cursor: pointer;
      background-color: transparent;
      border-color: transparent;
    }

    .cancel-recording-button {
      color: red;
      opacity: 0.7;
    }

    .cancel-recording-button:hover {
      color: rgb(206, 4, 4);
    }

    .stop-recording-button {
      color: #33cc33;
      opacity: 0.7;
    }

    .stop-recording-button:hover {
      color: #27a527;
    }

    .recording-elapsed-time {
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      justify-content: center;
      /*horizontal centering*/
      align-items: center;
    }

    .red-recording-dot {
      font-size: 24px;
      color: red;
      margin-right: 12px;
      /*transitions with Firefox, IE and Opera Support browser support*/
      animation-name: flashing-recording-dot;
      -webkit-animation-name: flashing-recording-dot;
      -moz-animation-name: flashing-recording-dot;
      -o-animation-name: flashing-recording-dot;
      animation-duration: 2s;
      -webkit-animation-duration: 2s;
      -moz-animation-duration: 2s;
      -o-animation-duration: 2s;
      animation-iteration-count: infinite;
      -webkit-animation-iteration-count: infinite;
      -moz-animation-iteration-count: infinite;
      -o-animation-iteration-count: infinite;
    }

    /* The animation code */
    @keyframes flashing-recording-dot {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0;
      }
      100% {
        opacity: 1;
      }
    }

    @-webkit-keyframes flashing-recording-dot {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0;
      }
      100% {
        opacity: 1;
      }
    }

    @-moz-keyframes flashing-recording-dot {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0;
      }
      100% {
        opacity: 1;
      }
    }

    @-o-keyframes flashing-recording-dot {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0;
      }
      100% {
        opacity: 1;
      }
    }
    /* END OF Audio Recording UI */

    small {
      display: block;
    }

    .xlarge-text {
      font-size: 32px;
    }

    .large-text {
      font-size: 24px;
    }

    .medium-text {
      font-size: 16px;
    }

    .small-text {
      font-size: 14px;
    }

    .left-text {
      text-align: left;
    }

    .center-text {
      text-align: center;
    }

    .right-text {
      text-align: right;
    }

    .justify-text {
      text-align: justify;
    }

    .left-align {
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      flex-direction: row;
      justify-content: flex-start;
    }

    .center-align {
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      flex-direction: row;
      justify-content: center;
    }

    .right-align {
      /*targeting Chrome & Safari*/
      display: -webkit-flex;
      /*targeting IE10*/
      display: -ms-flex;
      display: flex;
      flex-direction: row;
      justify-content: flex-end;
    }

    @media print {
      .no-print {
        display: none !important;
      }

      .editor-container {
        width: 100%;
        max-width: 100%;
        box-shadow: none;
      }

      .embedded-local-audio,
      .audio-link,
      .audio-recording {
        display: none !important;
      }
    }
  </style>
</head>

<body>

  <div class="editor-container">
    <div id="filename" contenteditable="plaintext-only" class="file-title"></div>

    <div class="top-container">
      <div id="toolbar" class="no-print">
        <button id="btnH1" title="Extra large text">XL</button>
        <button id="btnH2" title="Large text">L</button>
        <button id="btnM" title="Medium text">M</button>
        <button id="btnS" title="Small text">S</button>

        <button id="btnB" title="Bold text"><b>B</b></button>
        <button id="btnI" title="Italic text"><i>I</i></button>
        <button id="btnU" title="Underline text"><u>U</u></button>
        <button id="btnStrikethrough" title="Strikethrough text">Ꞩ</button>

        <div class="dropdown">
          <button id="btnTextColorMenu" title="Colorize text">Color</button>
          <div id="textColorDropdown" class="dropdown-content">
            <div class="swatch-grid">
              <button id="btnTextColor1" class="color-swatch" style="background: var(--note-text-color-1);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor2" class="color-swatch" style="background: var(--note-text-color-2);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor3" class="color-swatch" style="background: var(--note-text-color-3);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor4" class="color-swatch" style="background: var(--note-text-color-4);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor5" class="color-swatch" style="background: var(--note-text-color-5);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor6" class="color-swatch" style="background: var(--note-text-color-6);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor7" class="color-swatch" style="background: var(--note-text-color-7);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextColor8" class="color-swatch" style="background: var(--note-text-color-8);"
                onmousedown="event.preventDefault();"></button>
            </div>
          </div>
        </div>

        <!-- Highlight Color Dropdown -->
        <div class="dropdown">
          <button id="btnTextHighlightMenu" title="Highlight text">Highlight</button>
          <div id="highlightDropdown" class="dropdown-content">
            <div class="swatch-grid">
              <button id="btnTextHighlight1" class="color-swatch" style="background: var(--note-highlight-color-1);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight2" class="color-swatch" style="background: var(--note-highlight-color-2);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight3" class="color-swatch" style="background: var(--note-highlight-color-3);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight4" class="color-swatch" style="background: var(--note-highlight-color-4);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight5" class="color-swatch" style="background: var(--note-highlight-color-5);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight6" class="color-swatch" style="background: var(--note-highlight-color-6);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight7" class="color-swatch" style="background: var(--note-highlight-color-7);"
                onmousedown="event.preventDefault();"></button>
              <button id="btnTextHighlight8" class="color-swatch" style="background: var(--note-highlight-color-8);"
                onmousedown="event.preventDefault();"></button>
            </div>
          </div>
        </div>

        <!-- Font Size Dropdown -->
        <div class="text-dropdown">
          <button id="btnFontSizeMenu" title="Change text size"><b>T</b></button>
          <div id="fontSizeDropdown" class="text-dropdown-content">
            <div class="text">
              <button id="btnFontSize1" title="25%">25%</button>
              <button id="btnFontSize2" title="33.33%">33.33%</button>
              <button id="btnFontSize3" title="50%">50%</button>
              <button id="btnFontSize4" title="66.66%">66.66%</button>
              <button id="btnFontSize5" title="75%">75%</button>
              <button id="btnFontSize6" title="125%">125%</button>
              <button id="btnFontSize7" title="150%">150%</button>
              <button id="btnFontSize8" title="175%">175%</button>
              <button id="btnFontSize9" title="200%">200%</button>
              <button id="btnFontSize10" title="250%">250%</button>
              <button id="btnFontSize11" title="300%">300%</button>
              <button id="btnFontSize12" title="350%">350%</button>
            </div>
          </div>
        </div>

        <div class="text-dropdown">
          <button id="btnAlign" title="Alignment">Align</button>
          <div id="alignDropdown" class="text-dropdown-content">
            <button id="btnLeftTextAlign" title="Align to the left">Left</button>
            <button id="btnCenterTextAlign" title="Align to the center">Center</button>
            <button id="btnRightTextAlign" title="Align to the right">Right</button>
            <button id="btnJustifyTextAlign" title="Justify text">Justify</button>
          </div>
        </div>

        <div id="splitbar">|</div>
        <button id="btnText" title="Add text">📝</button>
        <button id="btnCode" title="Add source code text">🖥</button>

        <div class="text-dropdown">
          <button id="btnLinks" title="Insert links">🔗</button>
          <div id="linksDropdown" class="text-dropdown-content">
            <button id="btnLinkText" title="Make text link">🌎 Text Link</button>
            <button id="btnLinkImage" title="Insert image link">📷 Image Link</button>
            <button id="btnLinkAudio" title="Insert audio link">🔈 Audio Link</button>
            <button id="btnLinkVideo" title="Insert video link">🎞 Video Link</button>
            <button id="btnLinkPdf" title="Insert PDF file link">📕 PDF Link</button>
          </div>
        </div>

        <div class="text-dropdown">
          <button id="btnEmbed" title="Embed contents">📎</button>
          <div id="embedDropdown" class="text-dropdown-content">
            <button id="btnEmbedWeb" title="Embed web page or HTML object">🌎 Web</button>

            <div class="fileUpload">
              <label for="imageUpload" title="Embed image file">📷 Image</label>
              <input type="file" id="imageUpload" accept="image/*" onclick="this.value = null">
            </div>

            <div class="fileUpload">
              <label for="audioUpload" title="Embed audio file">🔈 Audio</label>
              <input type="file" id="audioUpload" accept="audio/*" onclick="this.value = null">
            </div>

            <div class="fileUpload">
              <label for="pdfUpload" title="Embed PDF file">📕 PDF</label>
              <input type="file" id="pdfUpload" accept=".pdf" onclick="this.value = null">
            </div>

            <div class="fileUpload">
              <label for="epubUpload" title="Embed ePUB file">📖 ePub</label>
              <input type="file" id="epubUpload" accept=".epub" onclick="this.value = null">
            </div>
          </div>
        </div>

        <button id="btnRecordAudio" title="Record audio">🎤</button>
        <button id="btnEmbedMath" title="Insert math expression">Σ</button>

        <div class="text-dropdown">
          <button id="btnTable" title="Add table">Table</button>
          <div id="tableDropdown" class="text-dropdown-content">
            <button id="btnSimpleTable" title="Add simple table">Simple Table</button>
            <button id="btnHeadlessTable" title="Add headless table">Headless Table</button>
          </div>
        </div>

        <div id="splitbar">|</div>
        <button id="btnUndo" disabled title="Undo">↩</button>
        <button id="btnRedo" disabled title="Redo">↪</button>

        <div id="splitbar" style="margin-left: auto;">|</div>
        <!-- Block conversion -->
        <div class="text-dropdown">
          <button id="btnSaveMenu" title="Save or Share">💾</button>
          <div id="saveDropdown" class="text-dropdown-content">
            <button id="btnSave">Save</button>
            <button id="btnSaveTo">Save To...</button>
            <button id="btnShare">Share</button>
            <button id="btnSaveReadOnly">Save as Read-Only</button>
            <button id="btnSaveToReadOnly">Save To as Read-Only</button>
            <button id="btnShareReadOnly">Share as Read-Only</button>
          </div>
        </div>

      </div>
      <div id="recordingBar" class="hidden" aria-hidden="true"></div>
    </div>

    <div id="editorContainer" class="thin-line">
      <div id="editor" contenteditable="true">
        <p id="text28096aea6fa9cc5d10934d24509e2c83" class="text-block"><br/></p>
      </div>
    </div>

    <div id="footer">
      <small><a href="https://github.com/flaviup">flaviup@github.com</a></small>
      <br/>
      <small>Nash 0.1</small>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script -->
  <script src="https://github.com/futurepress/epub.js/releases/download/v0.3.88/epub.min.js"></script> <!-- check newer versions like 0.3.93 -->
  <script src="https://cdn.jsdelivr.net/npm/mathup/dist/browser/mathup.iife.min.js"></script>

  <script type="module">
    /**
     *  PDFObject v2.3.1
     *  https://github.com/pipwerks/PDFObject
     *  @license
     *  Copyright (c) 2008-2025 Philip Hutchison
     *  MIT-style license: http://pipwerks.mit-license.org/
     *  UMD module pattern from https://github.com/umdjs/umd/blob/master/templates/returnExports.js
     */

    (function (root, factory) {
        if (typeof define === "function" && define.amd) {
            // AMD. Register as an anonymous module.
            define([], factory);
        } else if (typeof module === "object" && module.exports) {
            // Node. Does not work with strict CommonJS, but
            // only CommonJS-like environments that support module.exports,
            // like Node.
            module.exports = factory();
        } else {
            // Browser globals (root is window)
            root.PDFObject = factory();
        }
    }(globalThis, function () {

        "use strict";

        //PDFObject is designed for client-side (browsers), not server-side (node)
        //Will choke on undefined navigator and window vars when run on server
        //Return boolean false and exit function when running server-side

        if(typeof window === "undefined" || window.navigator === undefined || window.navigator.userAgent === undefined){ return false; }

        let pdfobjectversion = "2.3.1";
        let win = window;
        let nav = win.navigator;
        let ua = nav.userAgent;
        let suppressConsole = false;

        //Fallback validation when navigator.pdfViewerEnabled is not supported
        let isModernBrowser = function (){

            /*
              userAgent sniffing is not the ideal path, but most browsers revoked the ability to check navigator.mimeTypes
              for security purposes. As of 2023, browsers have begun implementing navigator.pdfViewerEnabled, but older versions
              do not have navigator.pdfViewerEnabled or the ability to check navigator.mimeTypes. We're left with basic browser
              sniffing and assumptions of PDF support based on browser vendor.
            */

            //Chromium has provided native PDF support since 2011.
            //Most modern browsers use Chromium under the hood: Google Chrome, Microsoft Edge, Opera, Brave, Vivaldi, Arc, and more.
            //Chromium uses the PDFium rendering engine, which is based on Foxit's PDF rendering engine.
            //Note that MS Edge opts to use a different PDF rendering engine. As of 2024, Edge uses a version of Adobe's Reader
            let isChromium = (win.chrome !== undefined);

            //Safari on macOS has provided native PDF support since 2009.
            //This code snippet also detects the DuckDuckGo browser, which uses Safari/Webkit under the hood.
            let isSafari = (win.safari !== undefined || (nav.vendor !== undefined && /Apple/.test(nav.vendor) && /Safari/.test(ua)));

            //Firefox has provided PDF support via PDFJS since 2013.
            let isFirefox = (win.Mozilla !== undefined || /irefox/.test(ua));

            return isChromium || isSafari || isFirefox;

        };

        /*
          Special handling for Internet Explorer 11.
          Check for ActiveX support, then whether "AcroPDF.PDF" or "PDF.PdfCtrl" are valid.
          IE11 uses ActiveX for Adobe Reader and other PDF plugins, but window.ActiveXObject will evaluate to false.
          ("ActiveXObject" in window) evaluates to true.
          MS Edge does not support ActiveX so this test will evaluate false for MS Edge.
        */
        let validateAX = function (type){
            var ax = null;
            try {
                ax = new ActiveXObject(type);
            } catch (e) {
                //ensure ax remains null when ActiveXObject attempt fails
                ax = null;
            }
            return !!ax; //convert resulting object to boolean
        };

        let hasActiveXPDFPlugin = function (){ return ("ActiveXObject" in win) && (validateAX("AcroPDF.PDF") || validateAX("PDF.PdfCtrl")) };

        let checkSupport = function (){

            //Safari on iPadOS doesn't report as 'mobile' when requesting desktop site, yet still fails to embed PDFs
            let isSafariIOSDesktopMode = (nav.platform !== undefined && nav.platform === "MacIntel" && nav.maxTouchPoints !== undefined && nav.maxTouchPoints > 1);

            let isMobileDevice = (isSafariIOSDesktopMode || /Mobi|Tablet|Android|iPad|iPhone/.test(ua));

            //As of June 2023, no mobile browsers properly support inline PDFs. If mobile, just say no.
            if(isMobileDevice){ return false; }

            //Modern browsers began supporting navigator.pdfViewerEnabled in late 2022 and early 2023.
            let supportsPDFVE = (typeof nav.pdfViewerEnabled === "boolean");

            //If browser supports nav.pdfViewerEnabled and is explicitly saying PDFs are NOT supported (e.g. PDFJS disabled by user in Firefox), respect it.
            if(supportsPDFVE && !nav.pdfViewerEnabled){ return false; }

            return (supportsPDFVE && nav.pdfViewerEnabled) || isModernBrowser() || hasActiveXPDFPlugin();

        };

        //Determines whether PDF support is available
        let supportsPDFs = checkSupport();

        //Create a fragment identifier for using PDF Open parameters when embedding PDF
        let buildURLFragmentString = function(pdfParams){

            let string = "";
            let prop;
            let paramArray = [];
            let fdf = "";

            //The comment, viewrect, and highlight parameters require page to be set first.

            //Check to ensure page is used if comment, viewrect, or highlight are specified
            if(pdfParams.comment || pdfParams.viewrect || pdfParams.highlight){

                if(!pdfParams.page){

                    //If page is not set, use the first page
                    pdfParams.page = 1;

                    //Inform user that page needs to be set properly
                    embedError("The comment, viewrect, and highlight parameters require a page parameter, but none was specified. Defaulting to page 1.");

                }

            }

            //Let's go ahead and ensure page is always the first parameter.
            if(pdfParams.page){
                paramArray.push("page=" + encodeURIComponent(pdfParams.page));
                delete pdfParams.page;
            }

            //FDF needs to be the last parameter in the string
            if(pdfParams.fdf){
                fdf = pdfParams.fdf;
                delete pdfParams.fdf;
            }

            //Add all other parameters, as needed
            if(pdfParams){

                for (prop in pdfParams) {
                    if (pdfParams.hasOwnProperty(prop)) {
                        paramArray.push(encodeURIComponent(prop) + "=" + encodeURIComponent(pdfParams[prop]));
                    }
                }

                //Add fdf as the last parameter, if needed
                if(fdf){
                    paramArray.push("fdf=" + encodeURIComponent(fdf));
                }

                //Join all parameters in the array into a string
                string = paramArray.join("&");

                //The string will be empty if no PDF Parameters were provided
                //Only prepend the hash if the string is not empty
                if(string){
                    string = "#" + string;
                }

            }

            return string;

        };

        let embedError = function (msg){
            if(!suppressConsole){
                console.log("[PDFObject]", msg);
            }
            return false;
        };

        let emptyNodeContents = function (node){
            while(node.firstChild){
                node.removeChild(node.firstChild);
            }
        };

        let getTargetElement = function (targetSelector){

            //Default to body for full-browser PDF
            let targetNode = document.body;

            //If a targetSelector is specified, check to see whether
            //it's passing a selector, jQuery object, or an HTML element

            if(typeof targetSelector === "string"){

                //Is CSS selector
                targetNode = document.querySelector(targetSelector);

            } else if (win.jQuery !== undefined && targetSelector instanceof jQuery && targetSelector.length) {

                //Is jQuery element. Extract HTML node
                targetNode = targetSelector.get(0);

            } else if (targetSelector.nodeType !== undefined && targetSelector.nodeType === 1){

                //Is HTML element
                targetNode = targetSelector;

            }

            return targetNode;

        };

        let convertBase64ToDownloadableLink = function (b64, filename, targetNode, fallbackHTML) {

            //IE-11 safe version. More verbose than modern fetch()
            if (window.Blob && window.URL && window.URL.createObjectURL) {

                var xhr = new XMLHttpRequest();
                xhr.open('GET', b64, true);
                xhr.responseType = 'blob';
                xhr.onload = function() {

                    if (xhr.status === 200) {

                        var blob = xhr.response;
                        var link = document.createElement('a');
                        link.innerText = "Download PDF";
                        link.href = URL.createObjectURL(blob);
                        link.setAttribute('download', filename);
                        targetNode.innerHTML = fallbackHTML.replace(/\[pdflink\]/g, link.outerHTML);

                    }

                };

                xhr.send();

            }

        };


        let generatePDFObjectMarkup = function (embedType, targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute, PDFJS_URL){

            //Ensure target element is empty first
            emptyNodeContents(targetNode);

            let source = url;

            if(embedType === "pdfjs"){
                //If PDFJS_URL already contains a ?, assume querystring is in place, and use an ampersand to append PDFJS's file parameter
                let connector = (PDFJS_URL.indexOf("?") !== -1) ? "&" : "?";
                source = PDFJS_URL + connector + "file=" + encodeURIComponent(url) + pdfOpenFragment;
            } else {
                source += pdfOpenFragment;
            }

            let el = document.createElement("iframe");
            el.className = "pdfobject";
            el.type = "application/pdf";
            el.title = title;
            el.src = source;
            el.allow = "fullscreen";
            el.frameborder = "0";
            if(id){ el.id = id; }

            if(!omitInlineStyles){

                let style = "border: none;";

                if(targetNode !== document.body){
                    //assign width and height to target node
                    style += "width: " + width + "; height: " + height + ";";
                } else {
                    //this is a full-page embed, use CSS to fill the viewport
                    style += "position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: 100%; height: 100%;";
                }

                el.style.cssText = style;

            }

            //Allow developer to insert custom attribute on iframe element, but ensure it does not conflict with attributes used by PDFObject
            let reservedTokens = ["className", "type", "title", "src", "style", "id", "allow", "frameborder"];
            if(customAttribute && customAttribute.key && reservedTokens.indexOf(customAttribute.key) === -1){
                el.setAttribute(customAttribute.key, (typeof customAttribute.value !== "undefined") ? customAttribute.value : "");
            }

            targetNode.classList.add("pdfobject-container");
            targetNode.appendChild(el);

            return targetNode.getElementsByTagName("iframe")[0];

        };

        let embed = function(url, targetSelector, options){

            //If targetSelector is not defined, convert to boolean
            let selector = targetSelector || false;

            //Ensure options object is not undefined -- enables easier error checking below
            let opt = options || {};

            //Get passed options, or set reasonable defaults
            suppressConsole = (typeof opt.suppressConsole === "boolean") ? opt.suppressConsole : false;
            let id = (typeof opt.id === "string") ? opt.id : "";
            let page = opt.page || false;
            let pdfOpenParams = opt.pdfOpenParams || {};
            let fallbackLink = (typeof opt.fallbackLink === "string" || typeof opt.fallbackLink === "boolean") ? opt.fallbackLink : true;
            let width = opt.width || "100%";
            let height = opt.height || "100%";
            let title = opt.title || "Embedded PDF";
            let forcePDFJS = (typeof opt.forcePDFJS === "boolean") ? opt.forcePDFJS : false;
            let omitInlineStyles = (typeof opt.omitInlineStyles === "boolean") ? opt.omitInlineStyles : false;
            let PDFJS_URL = opt.PDFJS_URL || false;
            let targetNode = getTargetElement(selector);
            let pdfOpenFragment = "";
            let customAttribute = opt.customAttribute || {};
            let fallbackFileNameForBase64 = opt.fallbackFileNameForBase64;
            let fallbackHTML_default = "<p>This browser does not support inline PDFs. Please download the PDF to view it: [pdflink]</p>";

            //Ensure URL is available. If not, exit now.
            if(typeof url !== "string"){ return embedError("URL is not valid"); }

            //If target element is specified but is not valid, exit without doing anything
            if(!targetNode){ return embedError("Target element cannot be determined"); }

            //page option overrides pdfOpenParams, if found
            if(page){ pdfOpenParams.page = page; }

            //Stringify optional Adobe params for opening document (as fragment identifier)
            pdfOpenFragment = buildURLFragmentString(pdfOpenParams);


            // --== Do the dance: Embed attempt #1 ==--

            //If the forcePDFJS option is invoked, skip everything else and embed as directed
            if(forcePDFJS && PDFJS_URL){
                return generatePDFObjectMarkup("pdfjs", targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute, PDFJS_URL);
            }

            // --== Embed attempt #2 ==--

            //Embed PDF if support is detected, or if this is a relatively modern browser
            if(supportsPDFs){
                return generatePDFObjectMarkup("iframe", targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute);
            }

            // --== Embed attempt #3 ==--

            //If everything else has failed and a PDFJS fallback is provided, try to use it
            if(PDFJS_URL){
                return generatePDFObjectMarkup("pdfjs", targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute, PDFJS_URL);
            }

            // --== PDF embed not supported! Use fallback ==--

            //Display the fallback link if available
            if(fallbackLink){

                //If a custom fallback has been provided, handle it now
                if(typeof fallbackLink === "string"){

                    //Ensure [url] is set in custom fallback
                    targetNode.innerHTML = fallbackLink.replace(/\[url\]/g, url);

                } else {

                    //If the PDF is a base64 string, convert it to a downloadable link
                    const match = url.match(/data:application\/pdf;(?:.*filename=([^;]+);)?.*base64,/i);
                    if(match){

                        fallbackFileNameForBase64 =
                            fallbackFileNameForBase64 // from options
                            || match[1] // from data URI metadata
                            || "file.pdf"; // default

                        //Asynchronously append the link to the targetNode
                        convertBase64ToDownloadableLink(url, fallbackFileNameForBase64, targetNode, fallbackHTML_default);

                    } else {

                        //Use default fallback link
                        let link = "<a href='" + url + "'>Download PDF</a>";
                        targetNode.innerHTML = fallbackHTML_default.replace(/\[pdflink\]/g, link);

                    }

                }

            }

            return embedError("This browser does not support embedded PDFs");

        };

        return {
            embed: function (a,b,c){ return embed(a,b,c); },
            pdfobjectversion: (function () { return pdfobjectversion; })(),
            supportsPDFs: (function (){ return supportsPDFs; })()
        };

    })); // END OF PDFObject

    // Pub-Sub / Observer Pattern
    // based on https://github.com/hassanshaikley/pico-pubsub
    const t = new EventTarget();
    const sub = (e, c) => (t.addEventListener(e, c), () => t.removeEventListener(e, c));
    const pub = (n, d) => t.dispatchEvent(new CustomEvent(n, { detail: d }));

    // Undo-Redo
    // based on https://blog.julik.nl/2025/03/a-tiny-undo-stack

    class UndoStack {

      static #_UNDO_STACK_CHANGE_EVENT_NAME = "UNDO_STACK_CHANGE";

      static #_UNDO_STACK_CHANGE_EVENT_CLEAR = 0;
      static #_UNDO_STACK_CHANGE_EVENT_CLEAR_REDO = 1;
      static #_UNDO_STACK_CHANGE_EVENT_PUSH = 2;
      static #_UNDO_STACK_CHANGE_EVENT_UNDO = 3;
      static #_UNDO_STACK_CHANGE_EVENT_REDO = 4;
      static #_UNDO_STACK_CHANGE_EVENT_REMOVE_LAST = 5;

      #_past = [];
      #_future = [];

      constructor() {}

      get undoCount() {
        return this.#_past.length;
      }

      get redoCount() {
        return this.#_future.length;
      }

      get undoAvailable() {
        return this.#_past.length > 0;
      }

      get redoAvailable() {
        return this.#_future.length > 0;
      }

      onChange(callback) {
        return sub(UndoStack.#_UNDO_STACK_CHANGE_EVENT_NAME, callback);
      }

      static #_cleanup(actions) {

        for (let a of actions) {
          a?.cleanup();
        }
      }

      clear() {

        if (this.#_past.length > 0 || this.#_future.length > 0) {

          UndoStack.#_cleanup(this.#_past);
          UndoStack.#_cleanup(this.#_future);
          this.#_past.length = 0;
          this.#_future.length = 0;

          console.log("Undo/redo stacks cleared.");
          pub(UndoStack.#_UNDO_STACK_CHANGE_EVENT_NAME, UndoStack.#_UNDO_STACK_CHANGE_EVENT_CLEAR);
        }
      }

      clearRedo() {

        if (this.#_future.length > 0) {

          UndoStack.#_cleanup(this.#_future);
          this.#_future.length = 0;
          console.log("Redo stack cleared.");
          pub(UndoStack.#_UNDO_STACK_CHANGE_EVENT_NAME, UndoStack.#_UNDO_STACK_CHANGE_EVENT_CLEAR_REDO);
        }
      }

      push(doFn, undoFn, ...withArguments) {

        const args = withArguments; // structuredClone(withArguments);
        const action = {
          doWithData() {
            doFn(...args);
          },
          undoWithData() {
            undoFn(...args);
          },
          cleanup () {
            if (doFn.cleanup) doFn.cleanup();
            if (undoFn.cleanup) undoFn.cleanup();
          }
        };
        action.doWithData();

        // Adding a new action wipes the redoable steps
        this.#_past.push(action);
        UndoStack.#_cleanup(this.#_future);
        this.#_future.length = 0;

        pub(UndoStack.#_UNDO_STACK_CHANGE_EVENT_NAME, UndoStack.#_UNDO_STACK_CHANGE_EVENT_PUSH);

        return this.#_past.length - 1;
      }

      replace(index, doFn, undoFn, ...withArguments) {

        if (index > -1 && index < this.#_past.length) {

          const args = withArguments; // structuredClone(withArguments);
          const action = {
            doWithData() {
              doFn(...args);
            },
            undoWithData() {
              undoFn(...args);
            },
            cleanup () {
              if (doFn.cleanup) doFn.cleanup();
              if (undoFn.cleanup) undoFn.cleanup();
            }
          };
          this.#_past[index] = action;
        }
      }

      undo() {

        const action = this.#_past.pop();

        if (action) {

          action.undoWithData();
          this.#_future.unshift(action);
          pub(UndoStack.#_UNDO_STACK_CHANGE_EVENT_NAME, UndoStack.#_UNDO_STACK_CHANGE_EVENT_UNDO);
        }
      }

      removeLast() {

          const action = this.#_past.pop();

          if (action) pub(UndoStack.#_UNDO_STACK_CHANGE_EVENT_NAME, UndoStack.#_UNDO_STACK_CHANGE_EVENT_REMOVE_LAST);
      }

      redo() {

        const action = this.#_future.shift();

        if (action) {

          action.doWithData();
          this.#_past.push(action);
          pub(UndoStack.#_UNDO_STACK_CHANGE_EVENT_NAME, UndoStack.#_UNDO_STACK_CHANGE_EVENT_REDO);
        }
      }
    }

    const UNDO_STACK = new UndoStack();
    UNDO_STACK.onChange(function (event) {

      if (UNDO_STACK.undoAvailable)
        document.getElementById("btnUndo").removeAttribute("disabled");
      else
        document.getElementById("btnUndo").setAttribute("disabled", "");

      if (UNDO_STACK.redoAvailable)
        document.getElementById("btnRedo").removeAttribute("disabled");
      else
        document.getElementById("btnRedo").setAttribute("disabled", "");
    });

    // Media Recording

    class MediaRecordingStatus {
      static #_CLOSED = 0;
      static #_INITIALIZING = 1;
      static #_RECORDING = 2;

      static get CLOSED() { return this.#_CLOSED; }
      static get INITIALIZING() { return this.#_INITIALIZING; }
      static get RECORDING() { return this.#_RECORDING; }
    }

    // Audio Recorder object
    const audioRecorder = {
      recordingState: MediaRecordingStatus.CLOSED, /** Stores the recording state*/
      /** Stores the recorded audio as Blob objects of audio data as the recording continues*/
      audioBlobs: [],/*of type Blob[]*/
      /** Stores the reference of the MediaRecorder instance that handles the MediaStream when recording starts*/
      mediaRecorder: null, /*of type MediaRecorder*/
      /** Stores the reference to the stream currently capturing the audio*/
      streamBeingCaptured: null, /*of type MediaStream*/
      /** Start recording the audio 
       * @returns {Promise} - returns a promise that resolves if audio recording successfully started
       */
      isMediaRecordingSupported: function () {
        return !!(navigator?.mediaDevices && navigator.mediaDevices.getUserMedia);
      },
      start: function () {

        audioRecorder.recordingState = MediaRecordingStatus.INITIALIZING;

        // Feature Detection
        if (!(navigator?.mediaDevices && navigator.mediaDevices.getUserMedia)) {
          // Feature is not supported in browser
          // return a custom error
          audioRecorder.recordingState = MediaRecordingStatus.CLOSED;
          return Promise.reject(new Error("mediaDevices API or getUserMedia method is not supported in this browser."));
        } else {
          // Feature is supported in browser

          // create an audio stream
          return navigator.mediaDevices.getUserMedia({ audio: true }/*of type MediaStreamConstraints*/)
            // returns a promise that resolves to the audio stream
            .then(stream /*of type MediaStream*/ => {

              // save the reference of the stream to be able to stop it when necessary
              audioRecorder.streamBeingCaptured = stream;

              // create a media recorder instance by passing that stream into the MediaRecorder constructor
              audioRecorder.mediaRecorder = new MediaRecorder(stream); /*the MediaRecorder interface of the MediaStream Recording
              API provides functionality to easily record media*/

              // clear previously saved audio Blobs, if any
              audioRecorder.audioBlobs = [];

              // add a dataavailable event listener in order to store the audio data Blobs when recording
              audioRecorder.mediaRecorder.addEventListener("dataavailable", event => {
                // store audio Blob object
                audioRecorder.audioBlobs.push(event.data);
              });

              // start the recording by calling the start method on the media recorder
              audioRecorder.mediaRecorder.start();
              audioRecorder.recordingState = MediaRecordingStatus.RECORDING;
            });

            /* errors are not handled in the API because if its handled and the promise is chained, the .then after the catch will be executed*/
        }
      },
      /** Stop the started audio recording
       * @returns {Promise} - returns a promise that resolves to the audio as a blob file
       */
      stop: function () {
        // return a promise that would return the blob or URL of the recording
        return new Promise(resolve => {

          // save audio type to pass to set the Blob type
          const mimeType = audioRecorder.mediaRecorder.mimeType;

          // listen to the stop event in order to create & return a single Blob object
          audioRecorder.mediaRecorder.addEventListener("stop", () => {
            // create a single blob object, as we might have gathered a few Blob objects that needs to be joined as one
            const audioBlob = new Blob(audioRecorder.audioBlobs, { type: mimeType });
            audioRecorder.recordingState = MediaRecordingStatus.CLOSED;
            
            // resolve promise with the single audio blob representing the recorded audio
            resolve(audioBlob);
            audioRecorder.cancel();
          });
          audioRecorder.cancel();
        });
      },
      /** Cancel audio recording*/
      cancel: function () {
        // stop the recording feature
        audioRecorder.mediaRecorder?.stop();

        // stop all the tracks on the active stream in order to stop the stream
        audioRecorder.stopStream();

        // reset API properties for next recording
        audioRecorder.resetRecordingProperties();
      },
      /** Stop all the tracks on the active stream in order to stop the stream and remove
       * the red flashing dot showing in the tab
       */
      stopStream: function () {
        // stopping the capturing request by stopping all the tracks on the active stream
        audioRecorder.streamBeingCaptured?.getTracks() //get all tracks from the stream
          ?.forEach(track /*of type MediaStreamTrack*/ => track.stop()); //stop each one
      },
      /** Reset all the recording properties including the media recorder and stream being captured*/
      resetRecordingProperties: function () {

        audioRecorder.mediaRecorder = null;
        audioRecorder.streamBeingCaptured = null;
        audioRecorder.recordingState = MediaRecordingStatus.CLOSED;
        audioRecorder.audioBlobs = [];

        /*No need to remove event listeners attached to mediaRecorder as
        If a DOM element which is removed is reference-free (no references pointing to it), the element itself is picked
        up by the garbage collector as well as any event handlers/listeners associated with it.
        getEventListeners(audioRecorder.mediaRecorder) will return an empty array of events.*/
      }
    }; // END OF Media Recording

    const editor = document.getElementById("editor");
    const filename = document.getElementById("filename");

    function editorInsertBefore(childNode, siblingNodeId) {

      if (childNode && !editor.contains(childNode)) {

        const siblingNode = siblingNodeId ? document.getElementById(siblingNodeId) : null;
        if (!siblingNode || editor.contains(siblingNode)) editor.insertBefore(childNode, siblingNode);
      }
    }

    function editorRemoveChild(childNode, siblingNodeId) {

      if (childNode && editor.contains(childNode)) editor.removeChild(childNode);
    }

    editor.UNDO_STACK = UNDO_STACK;

    const STYLES = [
      { tagName: "span", style: { "color": "var(--note-text-color-1)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-2)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-3)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-4)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-5)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-6)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-7)" }, attributes: null },
      { tagName: "span", style: { "color": "var(--note-text-color-8)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-1)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-2)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-3)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-4)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-5)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-6)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-7)" }, attributes: null },
      { tagName: "span", style: { "background-color": "var(--note-highlight-color-8)" }, attributes: null },
      { tagName: "span", style: { "font-size": "25%" }, attributes: null },
      { tagName: "span", style: { "font-size": "33.33%" }, attributes: null },
      { tagName: "span", style: { "font-size": "50%" }, attributes: null },
      { tagName: "span", style: { "font-size": "66.66%" }, attributes: null },
      { tagName: "span", style: { "font-size": "75%" }, attributes: null },
      { tagName: "span", style: { "font-size": "125%" }, attributes: null },
      { tagName: "span", style: { "font-size": "150%" }, attributes: null },
      { tagName: "span", style: { "font-size": "175%" }, attributes: null },
      { tagName: "span", style: { "font-size": "200%" }, attributes: null },
      { tagName: "span", style: { "font-size": "250%" }, attributes: null },
      { tagName: "span", style: { "font-size": "300%" }, attributes: null },
      { tagName: "span", style: { "font-size": "350%" }, attributes: null },
      { tagName: "strong", style: null, attributes: null },
      { tagName: "em", style: null, attributes: null },
      { tagName: "u", style: null, attributes: null },
      { tagName: "s", style: null, attributes: null }
    ];

    const TEXT_COLORS_N = 8;
    const HIGHLIGHT_COLORS_N = 8;
    const FONT_SIZES_N = 12;

    const STYLE_TEXT_COLOR_BASE_INDEX = -1;
    const STYLE_HIGHLIGHT_COLOR_BASE_INDEX = STYLE_TEXT_COLOR_BASE_INDEX + TEXT_COLORS_N;
    const STYLE_FONT_BASE_INDEX = STYLE_HIGHLIGHT_COLOR_BASE_INDEX + HIGHLIGHT_COLORS_N;

    const STYLE_STRONG_INDEX = STYLE_FONT_BASE_INDEX + FONT_SIZES_N + 1;
    const STYLE_EM_INDEX = STYLE_STRONG_INDEX + 1;
    const STYLE_U_INDEX = STYLE_EM_INDEX + 1;
    const STYLE_S_INDEX = STYLE_U_INDEX + 1;

    const STYLE_LINK_BASE_INDEX = STYLE_S_INDEX;

    const STYLE_GROUPS = [[STYLE_TEXT_COLOR_BASE_INDEX + 1, STYLE_TEXT_COLOR_BASE_INDEX + TEXT_COLORS_N],
                          [STYLE_HIGHLIGHT_COLOR_BASE_INDEX + 1, STYLE_HIGHLIGHT_COLOR_BASE_INDEX + HIGHLIGHT_COLORS_N],
                          [STYLE_FONT_BASE_INDEX + 1, STYLE_FONT_BASE_INDEX + FONT_SIZES_N]];

    // Helper: gets all the distinct links in the text and indexes them as styles
    function updateLinkStyles(editor) {

      const links = new Set();
      editor.querySelectorAll("a").forEach((linkNode) => {
        if (linkNode.hasAttribute("href")) links.add(linkNode.getAttribute("href"));
      });

      while (STYLES[STYLES.length - 1].tagName === "a") {
        STYLES.pop();
      }

      for(let link of links) STYLES.push({tagName: "a", style: null, attributes: { "href": link }});
    }

    // Helper: generates a unique id
    function generateUId() {

      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }

      return s4() + s4() + s4() + s4() +
             s4() + s4() + s4() + s4();
    }

    // Blocks page interaction
    function blockPageInteraction() {

      const divNode = document.createElement("div");
      divNode.setAttribute("id", `blockingPage${generateUId()}`);
      document.body.appendChild(divNode);

      return function() {
        divNode.remove();
      }
    }

    function setEditMode(editMode) {

      const toolbar = document.getElementById("toolbar");

      if (editMode) {

        editor.contentEditable = "true";
        filename.contentEditable = "plaintext-only";
        toolbar.style.display = "flex";
      } else {

        editor.contentEditable = "false";
        filename.contentEditable = "false";
        toolbar.style.display = "none";
      }
    }

    function removeDocumentNodes(html, editMode) {

      const template = document.createElement("template");
      template.innerHTML = html;

      template.content.querySelectorAll(".embedded-local-epub").forEach(el => {
        el.replaceChildren();
        if (editMode === false) el.setAttribute("data-readonly", "true");
      });

      /*template.content.querySelectorAll(".embedded-local-pdf").forEach(el => {
        el.replaceChildren();
      });*/

      if (editMode === false) {

        template.content.querySelectorAll(".x-remover").forEach(el => {
          el.parentNode?.removeChild(el);
        });

        template.content.querySelectorAll("*[contenteditable]").forEach(el => {
          el.setAttribute("contenteditable", "false");
        });
      }

      return template.innerHTML;
    }

    class SaveType {
      static #_DOWNLOAD = 0;
      static #_FILE = 1;
      static #_SHARE = 2;

      static get DOWNLOAD() { return this.#_DOWNLOAD; }
      static get FILE() { return this.#_FILE; }
      static get SHARE() { return this.#_SHARE; }
    }

    function getNewFileHandle(suggestedName) {

      const opts = {
        suggestedName: suggestedName,
        types: [
          {
            description: "Html file",
            accept: { "text/html": [".html"] },
          },
        ],
      };

      return window.showSaveFilePicker ? window.showSaveFilePicker(opts) : null;
    }

    async function exportToFile(saveType, editMode) {

      let filename = document.getElementById("filename").innerText.trim();

      if (!filename) {
        alert("Title is empty!");
        return;
      }

      if (audioRecorder.recordingState !== MediaRecordingStatus.CLOSED) {
        alert("Stop recording before " + (saveType === SaveType.SHARE ? "sharing." : "saving."));
        return;
      }

      filename = filename.endsWith(".html") ? filename : filename + ".html";

      if (editMode === false) {
        setEditMode(false);
      }

      let content = removeDocumentNodes(document.documentElement.outerHTML, editMode);
      let blob = new Blob(["<!DOCTYPE html>\n" + content], { type: "text/html" });
      let file = new File([blob], filename, { type: "text/html" });

      if (editMode === false) {
        setEditMode(true);
      }

      switch (saveType) {

        case SaveType.DOWNLOAD:

          let a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = filename;
          a.click();
          URL.revokeObjectURL(a.href);
          break;

        case SaveType.FILE:

          let writable = null;

          try {

            const promise = getNewFileHandle(filename);

            if (!promise) {
              alert("Feature not supported in this browser.");
              return;
            }

            const fileHandle = await promise;
            writable = await fileHandle.createWritable();
            await writable.write(blob);
            await writable.close();
          } catch (error) {

            console.error("save to file failed:", error);

            if (writable) {

              try {
                await writable.close();
              } catch (err) {
                console.error("closing the file failed:", err);
              }
            }
          }
          break;

        case SaveType.SHARE:

          if (navigator.canShare && navigator.canShare({ files: [file] })) {

            try {
              await navigator.share({
                files: [file],
                title: filename,
                text: ""
              });
            } catch (error) {
              console.error("share failed:", error);
            }
          }
          break;
      }
    }

    // Gets the top parent node of the child node, parent that has root container as its direct parent
    // the root container argument is either the editor or a TR element (for a table's th or td cell)
    // we are working on this top parent node text to style it
    function getTopLevelNodeOf(childNode, rootContainer) {

      if (childNode !== rootContainer) {

        while (childNode && childNode.parentNode !== rootContainer) {
          childNode = childNode.parentNode;
        }
      }

      return (childNode?.parentNode === rootContainer) ? childNode : null;
    }

    function getTopLevelNodeOfCurrentPosition(useSelectionRange = null) {

      let range = useSelectionRange;

      if (!range) {

        let selection = window.getSelection();

        if (selection?.rangeCount) {
          range = selection.getRangeAt(0);
        }
      }

      return getTopLevelNodeOf(range?.startContainer, document.getElementById("editor"));
    }

    function createRemover(callback = null) {

      const divNode = document.createElement("div");
      divNode.innerText = "❌";

      if (callback) {
        divNode.addEventListener("click", function (e) {
          callback();
        }, false);
      } else {
        divNode.setAttribute("onclick", "handleXRemoveEvent(event)");
      }
      divNode.setAttribute("class", "x-remover non-selectable");
      divNode.setAttribute("contenteditable", "false");

      return divNode;
    }

    function showPrompt(message) {

      return new Promise((resolve, reject) => setTimeout(function() {
        resolve(prompt(message));
      }, 10));
    }

    function insertImage(event) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextElementSibling;
        reader.onload = function (e) {

          const divNode = document.createElement("div");
          const img = document.createElement("img");
          img.src = e.target.result;
          divNode.appendChild(img);
          divNode.appendChild(createRemover());
          divNode.setAttribute("id", `img${generateUId()}`);
          divNode.setAttribute("class", "embedded-local-image");
          divNode.setAttribute("contenteditable", "false");
          UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
        };
        reader.readAsDataURL(file);
      }
    }

    async function insertImageLink() {

      const url = (await showPrompt("Image URL"))?.trim();
      if (!url) return;

      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextElementSibling;
      const divNode = document.createElement("div");
      const img = document.createElement("img");
      img.src = `${url}`;
      divNode.appendChild(img);
      divNode.appendChild(createRemover());
      divNode.setAttribute("id", `img${generateUId()}`);
      divNode.setAttribute("class", "image-link");
      divNode.setAttribute("contenteditable", "false");
      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
    }

    function insertAudio(event) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextElementSibling;
        reader.onload = function (e) {

          const divNode = document.createElement("div");
          const audio = document.createElement("audio");
          audio.src = e.target.result;
          audio.setAttribute("controls", "");
          divNode.appendChild(audio);
          divNode.appendChild(createRemover());
          divNode.setAttribute("id", `audio${generateUId()}`);
          divNode.setAttribute("class", "embedded-local-audio");
          divNode.setAttribute("contenteditable", "false");
          UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
        };
        reader.readAsDataURL(file);
      }
    }

    async function insertAudioLink() {

      const url = (await showPrompt("Audio URL"))?.trim();
      if (!url) return;

      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextElementSibling;
      const divNode = document.createElement("div");
      const audio = document.createElement("audio");
      audio.src = `${url}`;
      audio.setAttribute("controls", "");
      divNode.appendChild(audio);
      divNode.appendChild(createRemover());
      divNode.setAttribute("id", `audio${generateUId()}`);
      divNode.setAttribute("class", "audio-link");
      divNode.setAttribute("contenteditable", "false");
      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
    }

    async function insertVideoLink() {

      const url = (await showPrompt("Video URL"))?.trim();
      if (!url) return;

      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextElementSibling;
      const divNode = document.createElement("div");
      const video = document.createElement("video");
      video.src = `${url}`;
      video.setAttribute("controls", "");
      divNode.appendChild(video);
      divNode.appendChild(createRemover());
      divNode.setAttribute("id", `video${generateUId()}`);
      divNode.setAttribute("class", "video-link");
      divNode.setAttribute("contenteditable", "false");
      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
    }

    const audioRecordingInserter = {

      /** Stores the audio recording node id*/
      strArId: null,

      /** Stores the audio recording node*/
      audioRecordingNode: null,

      /** Stores the audio recording node's next sibling present already in the DOM tree*/
      nextSibling: null,

      /** Stores the elapsed time node*/
      elapsedTimeTag: null,

      /** Stores the actual start time when an audio recording begins to take place to ensure elapsed time start time is accurate*/
      audioRecordStartTime: null,

      /** Stores the maximum recording time in hours to stop recording once maximum recording hour has been reached */
      maximumRecordingTimeInHours: 1,

      /** Stores the reference of the setInterval function that controls the timer in audio recording*/
      elapsedTimeTimer: null,

      undoStackIndex: -1,

      /** Resets all the audioRecordingInserter's data members*/
      reset: function () {

        audioRecordingInserter.strArId = null;
        audioRecordingInserter.audioRecordingNode = null;
        audioRecordingInserter.nextSibling = null;
        audioRecordingInserter.elapsedTimeTag = null;
        audioRecordingInserter.audioRecordStartTime = null;
        audioRecordingInserter.elapsedTimeTimer = null;
        audioRecordingInserter.undoStackIndex = -1;
      },

      /** Tries to start recording and insert the audio recording ui in the page*/
      insert: function (useSelectionRange) {

        if (!audioRecorder.isMediaRecordingSupported()) {
          console.log("Media recording is not supported in this browser.");
          alert("Media recording is not supported in this browser.");
          return;
        }

        if (audioRecorder.recordingState !== MediaRecordingStatus.CLOSED) {
          alert("A recording is already in progress.");
          return;
        }
        audioRecordingInserter.reset();

        audioRecordingInserter.nextSibling = getTopLevelNodeOfCurrentPosition(useSelectionRange)?.nextElementSibling;
        audioRecordingInserter.strArId = `ar${generateUId()}`;
        audioRecordingInserter.audioRecordingNode = document.createElement("div");
        audioRecordingInserter.audioRecordingNode.setAttribute("id", audioRecordingInserter.strArId);
        audioRecordingInserter.audioRecordingNode.setAttribute("class", "audio-recording");
        audioRecordingInserter.audioRecordingNode.setAttribute("contenteditable", "false");

        const audioRecordingControlsNode = document.createElement("div");
        audioRecordingControlsNode.setAttribute("class", "recording-control-buttons-container non-selectable");
        audioRecordingControlsNode.setAttribute("contenteditable", "false");
        audioRecordingControlsNode.innerHTML = `
            <button class="cancel-recording-button non-selectable" contenteditable="false" aria-hidden="true">✖</button>
            <div class="recording-elapsed-time non-selectable" contenteditable="false">
              <b class="red-recording-dot non-selectable" contenteditable="false" aria-hidden="true">🔴</b>
              <p class="elapsed-time non-selectable" style="font-size: 28px;" contenteditable="false">00:00</p>
            </div>
            <button class="stop-recording-button non-selectable" contenteditable="false" aria-hidden="true">✓</button>`;
        audioRecordingInserter.audioRecordingNode.appendChild(audioRecordingControlsNode);

        if (audioRecorder.recordingState === MediaRecordingStatus.CLOSED) {
          audioRecordingInserter.startAudioRecording();
        } else {
          audioRecordingInserter.reset();
        }
      },

      /** Starts recording using the audio recording API*/
      startAudioRecording: function () {

        console.log("Recording Audio...");

        const audioElements = document.querySelectorAll("audio");

        for (let audioElement of audioElements) {

          // If a previous audio recording is playing, pause it
          if (!audioElement.paused) {
            audioElement.pause();
          }
        }

        if (audioRecorder.recordingState !== MediaRecordingStatus.CLOSED) {
          audioRecordingInserter.reset();
          return;
        }

        // start recording using the audio recording API
        audioRecorder.start()
          .then(() => { //on success

            audioRecordingInserter.audioRecordStartTime = new Date(); // store the recording start time to display the elapsed time according to it
            const audioRecordingNode = audioRecordingInserter.audioRecordingNode;
            const nextSibling = audioRecordingInserter.nextSibling;
            audioRecordingInserter.undoStackIndex = UNDO_STACK.push(editorInsertBefore, function (_, _2) {
              audioRecordingInserter.onClickCancelAudioRecording();
            }, audioRecordingNode, nextSibling?.id);
            audioRecordingInserter.elapsedTimeTag = document.querySelectorAll(`#${audioRecordingInserter.strArId} .elapsed-time`)[0];
            const stopRecordingButton = document.querySelectorAll(`#${audioRecordingInserter.strArId} .stop-recording-button`)[0];
            const cancelRecordingButton = document.querySelectorAll(`#${audioRecordingInserter.strArId} .cancel-recording-button`)[0];
            stopRecordingButton.onclick = audioRecordingInserter.stopAudioRecording;
            cancelRecordingButton.onclick = audioRecordingInserter.onClickCancelAudioRecording;
            audioRecordingInserter.handleElapsedRecordingTime();
          })
          .catch(error => { // on error
            // No Browser Support Error
            if (error.message.includes("mediaDevices API or getUserMedia method is not supported in this browser.")) {
              console.log("To record audio, use browsers like Chrome and Firefox.");
              alert("To record audio, use browsers like Chrome and Firefox.");
            }

            // Error handling structure
            switch (error.name) {
              case "AbortError": // error from navigator.mediaDevices.getUserMedia
                console.log("An AbortError has occured.");
                break;
              case "NotAllowedError": // error from navigator.mediaDevices.getUserMedia
                console.log("A NotAllowedError has occured. User might have denied permission.");
                break;
              case "NotFoundError": // error from navigator.mediaDevices.getUserMedia
                console.log("A NotFoundError has occured.");
                break;
              case "NotReadableError": // error from navigator.mediaDevices.getUserMedia
                console.log("A NotReadableError has occured.");
                break;
              case "SecurityError": // error from navigator.mediaDevices.getUserMedia or from the MediaRecorder.start
                console.log("A SecurityError has occured.");
                break;
              case "TypeError": // error from navigator.mediaDevices.getUserMedia
                console.log("A TypeError has occured.");
                break;
              case "InvalidStateError": // error from the MediaRecorder.start
                console.log("An InvalidStateError has occured.");
                break;
              case "UnknownError": // error from the MediaRecorder.start
                console.log("An UnknownError has occured.");
                break;
              default:
                console.log("An error occured with the error name " + error.name);
            };
            audioRecordingInserter.cancelAudioRecording();
          });
      },

      /** Stops the currently started audio recording & sends it*/
      stopAudioRecording: function () {

        console.log("Stopping Audio Recording...");

        // stop the recording using the audio recording API
        audioRecorder.stop()
          .then(audioAsblob => {

            audioRecordingInserter.handleRecordingEnd();
            audioRecordingInserter.showAudioPlay(audioAsblob);
          })
          .catch(error => {
            // Error handling structure
            switch (error.name) {
              case "InvalidStateError": // error from the MediaRecorder.stop
                console.log("An InvalidStateError has occured.");
                break;
              default:
                console.log("An error occured with the error name " + error.name);
            };
            audioRecordingInserter.cancelAudioRecording();
          });
      },

      /** Cancels the currently started audio recording */
      cancelAudioRecording: function () {

        console.log("Canceling audio...");

        // cancel the recording using the audio recording API
        audioRecorder.cancel();
        audioRecordingInserter.handleRecordingEnd();

        const audioRecordingNode = audioRecordingInserter.audioRecordingNode;
        const nextSibling = audioRecordingInserter.nextSibling;
        audioRecordingNode.innerHTML = '<div class="recording-cancelled-container" contenteditable="false"><span style="margin: 0 10px">Cancelled audio recording</span></div>';
        audioRecordingNode.appendChild(createRemover());
        UNDO_STACK.replace(audioRecordingInserter.undoStackIndex, editorInsertBefore, editorRemoveChild, audioRecordingNode, nextSibling?.id);
        audioRecordingInserter.reset(); // audioRecordingInserter's job is finished here
      },

      onClickCancelAudioRecording: function () {

        if (confirm("Do you want to cancel audio recording? The cancellation cannot be undone.")) {
          audioRecordingInserter.cancelAudioRecording();
        }
      },

      /** Shows the audio play interface for playing the recorded audio using the audio element in the HTML document
       * @param {Blob} recorderAudioAsBlob - recorded audio as a Blob Object 
      */
      showAudioPlay: function (recorderAudioAsBlob) {

        // read content of files (Blobs) asynchronously
        let reader = new FileReader();

        // once content has been read
        reader.onload = (e) => {

          const audioRecordingNode = audioRecordingInserter.audioRecordingNode;
          const nextSibling = audioRecordingInserter.nextSibling;
          audioRecordingNode.innerHTML = `<audio controls src="${e.target.result}"></audio>`;
          audioRecordingNode.appendChild(createRemover());

          UNDO_STACK.replace(audioRecordingInserter.undoStackIndex, editorInsertBefore, editorRemoveChild, audioRecordingNode, nextSibling?.id);

          document.querySelectorAll(`#${audioRecordingInserter.strArId} audio`)[0].load();
          audioRecordingInserter.reset(); // audioRecordingInserter's job is finished here
        };

        // read content and convert it to a URL (base64)
        reader.readAsDataURL(recorderAudioAsBlob);
      },

      /** Hides the recording status bar*/
      hideRecordingStatusBar: function () {
        document.getElementById("editorContainer").classList.add("thin-line");
        document.getElementById("recordingBar").classList.add("hidden");
      },

      /** Checks if the recording animated dot is showing in the window viewport*/
      recordingDotShowingInViewport: function () {

        const dot = document.querySelectorAll(".audio-recording .red-recording-dot")[0];
        const toolbar = document.getElementById("toolbar");
        const dotRect = dot.getBoundingClientRect();
        const toolbarRect = toolbar.getBoundingClientRect();
        const wWidth = (window.innerWidth || document.documentElement.clientWidth);
        const wHeight = (window.innerHeight || document.documentElement.clientHeight);
        const dotTopOffset = 11;
        const dotBottomOffset = 6;

        return (dotRect.top + dotTopOffset < wHeight
            && dotRect.bottom - dotBottomOffset > toolbarRect.bottom
            && dotRect.left < wWidth
            && dotRect.left > -dotRect.width);
      },

      /** Displays the recording status bar if the recording animated dot is not showing in the window viewport, otherwise it hides the recording status bar*/
      showRecordingStatusBar: function () {

        if (!audioRecordingInserter.recordingDotShowingInViewport()) {
          document.getElementById("editorContainer").classList.remove("thin-line");
          document.getElementById("recordingBar").classList.remove("hidden");
        } else {
          audioRecordingInserter.hideRecordingStatusBar();
        }
      },

      /** Computes the elapsed recording time since the moment the function is called in the format h:m:s*/
      handleElapsedRecordingTime: function () {

        // display inital time when recording begins
        audioRecordingInserter.displayElapsedTimeDuringAudioRecording("00:00");
        audioRecordingInserter.showRecordingStatusBar();
        document.addEventListener("scroll", audioRecordingInserter.showRecordingStatusBar);

        // create an interval that compute & displays elapsed time, as well as, animate red dot - every second
        audioRecordingInserter.elapsedTimeTimer = setInterval(() => {
          // compute the elapsed time every second
          const elapsedTime = audioRecordingInserter.computeElapsedTime(audioRecordingInserter.audioRecordStartTime); // pass the actual record start time
          // display the elapsed time
          audioRecordingInserter.displayElapsedTimeDuringAudioRecording(elapsedTime);
        }, 1000); // every second
      },

      /** Displays elapsed time during audio recording
       * @param {String} elapsedTime - elapsed time in the format mm:ss or hh:mm:ss 
       */
      displayElapsedTimeDuringAudioRecording: function (elapsedTime) {

        // 1. display the passed elapsed time as the elapsed time in the elapsedTime HTML element
        audioRecordingInserter.elapsedTimeTag.innerHTML = elapsedTime;

        // 2. Stop the recording when the max number of hours is reached
        if (audioRecordingInserter.elapsedTimeReachedMaximumNumberOfHours(elapsedTime)) {
          audioRecordingInserter.stopAudioRecording();
        } else {
          audioRecordingInserter.showRecordingStatusBar();
        }
      },

      /**
       * @param {String} elapsedTime - elapsed time in the format mm:ss or hh:mm:ss  
       * @returns {Boolean} whether the elapsed time reached the maximum number of hours or not
       */
      elapsedTimeReachedMaximumNumberOfHours: function (elapsedTime) {

        // Split the elapsed time by the symbo :
        const elapsedTimeSplitted = elapsedTime.split(":");

        // Turn the maximum recording time in hours to a string and pad it with zero if less than 10
        const maximumRecordingTimeInHoursAsString = audioRecordingInserter.maximumRecordingTimeInHours < 10 ?
                                                      "0" + audioRecordingInserter.maximumRecordingTimeInHours :
                                                      audioRecordingInserter.maximumRecordingTimeInHours.toString();

        // if it the elapsed time reach hours and also reach the maximum recording time in hours return true
        if (elapsedTimeSplitted.length === 3 && elapsedTimeSplitted[0] === maximumRecordingTimeInHoursAsString)
          return true;
        else // otherwise, return false
          return false;
      },

      /** Computes the elapsedTime since the moment the function is called in the format mm:ss or hh:mm:ss
       * @param {String} startTime - start time to compute the elapsed time since
       * @returns {String} elapsed time in mm:ss format or hh:mm:ss format, if elapsed hours are 0.
       */
      computeElapsedTime: function (startTime) {

        // record end time
        const endTime = new Date();

        // time difference in ms
        let timeDiff = endTime - startTime;

        // convert time difference from ms to seconds
        timeDiff = timeDiff / 1000;

        // extract integer seconds that dont form a minute using %
        let seconds = Math.floor(timeDiff % 60); // ignoring uncomplete seconds (floor)

        // pad seconds with a zero if neccessary
        seconds = seconds < 10 ? "0" + seconds : seconds;

        // convert time difference from seconds to minutes using %
        timeDiff = Math.floor(timeDiff / 60);

        // extract integer minutes that don't form an hour using %
        let minutes = timeDiff % 60; // no need to floor possible incomplete minutes, becase they've been handled as seconds
        minutes = minutes < 10 ? "0" + minutes : minutes;

        // convert time difference from minutes to hours
        timeDiff = Math.floor(timeDiff / 60);

        // extract integer hours that don't form a day using %
        let hours = timeDiff % 24; // no need to floor possible incomplete hours, becase they've been handled as seconds

        // convert time difference from hours to days
        timeDiff = Math.floor(timeDiff / 24);

        // the rest of timeDiff is number of days
        let days = timeDiff; // add days to hours

        let totalHours = hours + (days * 24);
        totalHours = totalHours < 10 ? "0" + totalHours : totalHours;

        if (totalHours === "00") {
          return minutes + ":" + seconds;
        } else {
          return totalHours + ":" + minutes + ":" + seconds;
        }
      },

      /** Hides the displayed recording control buttons */
      handleRecordingEnd: function () {

        // stop interval that handles both time elapsed and the red dot
        if (audioRecordingInserter.elapsedTimeTimer) {
          clearInterval(audioRecordingInserter.elapsedTimeTimer);
          audioRecordingInserter.elapsedTimeTimer = null;
          console.log("Recording timer stopped.");
        }
        audioRecordingInserter.hideRecordingStatusBar();
        document.removeEventListener("scroll", audioRecordingInserter.showRecordingStatusBar);
      }
    };

    function insertAudioRecording() {
      audioRecordingInserter.insert(lastValidSelectionRange);
    }

    function onMathClick(e) {

      let node = e.target;

      while (node && !node.classList?.contains("embedded-math")) {
        node = node.parentNode;
      }

      if (!node?.id) return false;

      const currentExpression = node.getAttribute("data-math");
      const newExpression = prompt("Introduce math expression (see https://mathup.xyz):", currentExpression)?.trim();

      if (!newExpression || currentExpression === newExpression) return false;

      UNDO_STACK.push((nodeId, newExpression, _) => {

        const node = document.getElementById(nodeId);

        if (!node) return;

        node.setAttribute("data-math", newExpression);
        const mathNode = node.querySelector("math");

        if (mathNode) mathup(newExpression, { bare: true }).updateDOM(mathNode);
      }, (nodeId, _, oldExpression) => {

        const node = document.getElementById(nodeId);

        if (!node) return;

        node.setAttribute("data-math", oldExpression);
        const mathNode = node.querySelector("math");

        if (mathNode) mathup(oldExpression, { bare: true }).updateDOM(mathNode);
      }, node.id, newExpression, currentExpression);

      return true;
    }

    function insertMath() {

      const expression = prompt("Introduce math expression (see https://mathup.xyz):")?.trim();
      if (!expression) return;

      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextElementSibling;
      const divNode = document.createElement("div");

      const mathNode = mathup(expression, { bare: false, display: "inline" }).toDOM();
      mathNode.addEventListener("click", onMathClick);

      divNode.appendChild(mathNode);
      divNode.appendChild(createRemover());
      divNode.setAttribute("id", `math${generateUId()}`);
      divNode.setAttribute("class", "embedded-math");
      divNode.setAttribute("contenteditable", "false");
      divNode.setAttribute("data-math", expression);
      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
    }

    function loadAllReferencedDocuments() {

      document.querySelectorAll(".embedded-local-epub").forEach(async el => {
        const dataUrl = el.getAttribute("data-epub");
        await loadEpub(dataUrl, null, el);
      });

      /*document.querySelectorAll(".embedded-local-pdf").forEach(async el => {
        const dataUrl = el.getAttribute("data-pdf");
        await loadPdf(dataUrl, null, el);
      });*/
    }

    function insertEpub(event, element = null) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextElementSibling;
        reader.onload = async function (e) {
          loadEpub(e.target?.result, nextSibling);
        }
        reader.readAsDataURL(file);
      }
    }

    function loadEpub(epubData, nextSibling, element = null) {

      if (epubData) {

        let book = null;
        const epubId = generateUId();
        const strEpubId = `epub${epubId}`;
        element?.replaceChildren();
        const divNode = element || document.createElement("div");
        divNode.setAttribute("class", "embedded-local-epub epub-loading");
        divNode.setAttribute("contenteditable", "false");
        divNode.setAttribute("data-epub", epubData);
        const destroyBook = () => {
          if (!editor.contains(divNode) && book) {
            book.destroy();
            book = null;
            console.log("Epub book destroyed.");
          }
        }
        const removeEpubNode = (childNode, nextSiblingId) => { editorRemoveChild(childNode, nextSiblingId); };
        removeEpubNode.cleanup = destroyBook;
        if (!element) UNDO_STACK.push(editorInsertBefore, removeEpubNode, divNode, nextSibling?.id);

        setTimeout(async () => {

          const unblockPageInteraction = blockPageInteraction();

          try {
            //book = ePub(epubData, { openAs: "base64" }); // BUG: not working
            book = ePub(await (await window.fetch(epubData)).blob());
          } catch (error) { // we allow ePub loading only if epub library is available and the data could be loaded

            console.log(error);
            unblockPageInteraction();

            if (!element) UNDO_STACK.removeLast();
            if (editor.contains(divNode)) editor.removeChild(divNode);
            return;
          }
          unblockPageInteraction();
          const strTocId = `toc${epubId}`;

          const navButtons = document.createElement("div");
          navButtons.style = "float: top; display: flow-root;";
          navButtons.setAttribute("contenteditable", "false");
          const prev = document.createElement("div");
          const next = document.createElement("div");
          prev.setAttribute("id", `prev${epubId}`);
          next.setAttribute("id", `next${epubId}`);
          prev.setAttribute("class", "non-selectable");
          next.setAttribute("class", "non-selectable");
          prev.textContent = "<PREV";
          next.textContent = "NEXT>";
          prev.style = "float: left; left: 0; margin: 5px 5px; cursor: pointer;";
          next.style = "float: right; right: 0; margin: 5px 5px; cursor: pointer;";
          prev.setAttribute("contenteditable", "false");
          next.setAttribute("contenteditable", "false");
          navButtons.appendChild(prev);
          navButtons.appendChild(next);

          const selectToc = document.createElement("select");
          const divEbook = document.createElement("div");
          divEbook.style = "flex: top;";
          divEbook.setAttribute("class", "ebook-content");
          divEbook.setAttribute("id", strEpubId);
          selectToc.style = "float: top; left: 0; margin: 5px 5px; background: inherit; color: inherit;";
          selectToc.setAttribute("id", strTocId);
          divNode.appendChild(selectToc);

          divNode.appendChild(navButtons);

          divNode.appendChild(divEbook);
          divEbook.book = book;
          const readonly = divNode.getAttribute("data-readonly") ?? false;

          if (!readonly) {

            divNode.appendChild(createRemover(function () {

              editor.UNDO_STACK.push(removeEpubNode, editorInsertBefore,
                                     divNode, nextSibling?.id);
            }));
          }
          const rendition = book.renderTo(strEpubId, { flow: "scrolled",
                                                       width: "100%", height: 600, replacements: "base64" /*, allowScriptedContent: true*/ });

          const keyListener = function (e) {

            // Left Key
            if ((e.keyCode || e.which) === 37) {
              rendition?.prev();
            }

            // Right Key
            if ((e.keyCode || e.which) === 39) {
              rendition?.next();
            }
          };
          rendition?.on("keyup", keyListener);
          document.addEventListener("keyup", keyListener, false);

          prev.addEventListener("click", function (e) {
            rendition?.prev();
            e.preventDefault();
          }, false);

          next.addEventListener("click", function (e) {
            rendition?.next();
            e.preventDefault();
          }, false);

          const displayed = rendition?.display();
          book.loaded.navigation.then(function (toc) {

            divNode.classList.remove("epub-loading");
            const docfrag = document.createDocumentFragment();

            toc.forEach(function (chapter) {

              const option = document.createElement("option");
              option.textContent = chapter.label;
              option.setAttribute("ref", chapter.href);

              docfrag.appendChild(option);
            });
            selectToc.appendChild(docfrag);
            selectToc.onchange = function () {

              const index = selectToc.selectedIndex,
                    url = selectToc.options[index].getAttribute("ref");
              rendition?.display(url);

              return false;
            };
          });
          function navigatedTo(href) {

            let result = false;

            if (href) {

              const selectToc = document.getElementById(strTocId);
              const selectedOption = selectToc.querySelector("option[selected]");

              if (selectedOption) {
                selectedOption.removeAttribute("selected");
              }
              const allOptions = selectToc.querySelectorAll("option");

              for (let i = 0; i < allOptions.length; ++i) {

                let selected = allOptions[i].getAttribute("ref") === href;

                if (selected) {
                  allOptions[i].setAttribute("selected", "true");
                  selectToc.selectedIndex = i;
                  result = true;
                }
              }
            }

            return result;
          }
          rendition?.on("rendered", function (section) {

            const current = book.navigation && book.navigation.get(section.href);
            navigatedTo(current?.href);
          });
          rendition?.on("relocated", function (location) {

            let current = book.navigation.get(location.start?.href);

            while (current?.parent) {
              current = book.navigation.get(current.parent);
            }
            navigatedTo(current?.href);
          });
        }, 0);
      };
    }

    function insertPdf(event, element = null) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextElementSibling;
        reader.onload = async function (e) {
          await loadPdf(e.target?.result, nextSibling);
        }
        reader.readAsDataURL(file);
      }
    }

    async function loadPdf(pdfData, nextSibling, element = null) {

      if (pdfData) {

        element?.replaceChildren();
        const divNode = element || document.createElement("div");
        const strPdfId = divNode.getAttribute("id");

        if (!strPdfId) {
          divNode.setAttribute("id", `pdf${generateUId()}`);
        }
        divNode.setAttribute("class", "embedded-local-pdf pdf-loading");
        divNode.setAttribute("contenteditable", "false");
        //divNode.setAttribute("data-pdf", pdfData);

        if (!element) UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);

        const pdfContainer = PDFObject.embed(pdfData, divNode, {
          height: "800px",
          pdfOpenParams: {
            navpanes: 1,
            view: "FitH",
            pagemode: "thumbs"
          }
        });
        function pdfLoad(event) {
          divNode.classList.remove("pdf-loading");
          pdfContainer.removeEventListener("load", pdfLoad);
        }
        pdfContainer.addEventListener("load", pdfLoad);
        divNode.appendChild(createRemover());
      }
    }

    async function insertPdfLink() {

      const url = (await showPrompt("PDF URL"))?.trim();
      if (!url) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextElementSibling;
      const divNode = document.createElement("div");
      divNode.setAttribute("id", `pdf${generateUId()}`);
      divNode.setAttribute("class", "pdf-link pdf-loading");
      divNode.setAttribute("contenteditable", "false");

      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);

      const pdfContainer = PDFObject.embed(url, divNode, {
        height: "800px",
        pdfOpenParams: {
          navpanes: 1,
          view: "FitH",
          pagemode: "thumbs"
        }
      });
      function pdfLoad(event) {
        divNode.classList.remove("pdf-loading");
        pdfContainer.removeEventListener("load", pdfLoad);
      }
      pdfContainer.addEventListener("load", pdfLoad);
      divNode.appendChild(createRemover());
    }

    async function insertTable(headless) {

      const dims = (await showPrompt((headless ? "Headless table" : "Table") + " rows and columns"))?.trim();
      if (!dims) return;
      // Split the input into the number of rows and columns
      let r1 = -1, r2 = -1, c1 = -1, c2 = -1, i = 0, l = dims.length;
      
      while (i < l) {

        if (dims[i] >= "0" && dims[i] <= "9") {
          if (r1 < 0) {
            r1 = i++;
            continue;
          }

          if (r2 > -1) {
            if (c1 < 0) {
              c1 = i++;
              continue;
            }
          }
        } else {
          if (r1 > -1) {
            if (r2 < 0) {
              r2 = i++;
              continue;
            }

            if (c1 > -1) {
              if (c2 < 0) {
                c2 = i++;
                break;
              }
            }
          }
        }
        ++i;
      }

      if (r1 < 0 || r2 < 0 || r1 === r2 || c1 < 0 || c1 === c2) {
        alert("Invalid input.");
        return;
      }

      if (c2 < 0) {
        c2 = l;
      }
      let rows = parseInt(dims.substring(r1, r2));
      const cols = parseInt(dims.substring(c1, c2));

      if (rows < 1 || cols < 1) {
        alert("Invalid input.");
        return;
      }
      let thead = "";

      if (!headless) {
        --rows;

        for (let i = 0; i < cols; ++i) {
          thead += `\n<th scope="col" contenteditable="true">Column&nbsp;${i + 1}</th>`;
        }
        thead = "<thead>\n<tr>" + thead + "\n</tr>\n</thead>";
      }
      let tbody = "";

      for (let i = 0; i < rows; ++i) {
        let tr = "";

        for (let j = 0; j < cols; ++j) {
          tr += '\n<td contenteditable="true"><br/></td>';
        }
        tr = "<tr>" + tr + "\n</tr>";
        tbody += `\n${tr}`;
      }
      tbody = "<tbody>" + tbody + "\n</tbody>";

      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextElementSibling;
      const divNode = document.createElement("div");
      divNode.setAttribute("id", `table${generateUId()}`);
      divNode.setAttribute("class", "embedded-table");
      divNode.setAttribute("contenteditable", "false");
      divNode.innerHTML = ['<table contenteditable="false">', thead, tbody, "</table>"].join("\n");

      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
      divNode.appendChild(createRemover());
    }

    function insertText() {

      const topNode = getTopLevelNodeOfCurrentPosition();
      const p = document.createElement("p");
      p.setAttribute("id", `text${generateUId()}`);
      p.setAttribute("class", "text-block");
      p.appendChild(document.createElement("br"));
      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, p, topNode?.nextElementSibling?.id);
      setCaret(p, 0);
    }

    function insertCode() {

      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextElementSibling;
      const divNode = document.createElement("div");
      const pre = document.createElement("pre");
      const code = document.createElement("code");
      code.setAttribute("contenteditable", "plaintext-only");
      code.appendChild(document.createElement("br"));
      pre.appendChild(code);
      divNode.appendChild(pre);
      divNode.setAttribute("id", `code${generateUId()}`);
      divNode.setAttribute("class", "code-block");
      divNode.setAttribute("contenteditable", "true");
      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
      setCaret(code, 0);
    }

    async function insertEmbeddedContent() {

      const iframeHtml = (await showPrompt("Embedded Page (iframe or URL)"))?.trim();
      if (!iframeHtml) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextElementSibling;
      const divNode = document.createElement("div");

      if (iframeHtml.length < "<IFRAME".length || !iframeHtml.toUpperCase().startsWith("<IFRAME")) {
        divNode.innerHTML = `<iframe src="${iframeHtml}" allow="fullscreen" width="100%" height="400"></iframe>`;
      } else {
        divNode.innerHTML = `${iframeHtml}`;
      }
      divNode.setAttribute("id", `embed${generateUId()}`);
      divNode.setAttribute("class", "embedded-content");
      divNode.setAttribute("contenteditable", "false");
      UNDO_STACK.push(editorInsertBefore, editorRemoveChild, divNode, nextSibling?.id);
      divNode.appendChild(createRemover());
    }

    class AlignType {
      static #_LEFT = 0;
      static #_CENTER = 1;
      static #_RIGHT = 2;
      static #_JUSTIFY = 3;

      static get LEFT() { return this.#_LEFT; }
      static get CENTER() { return this.#_CENTER; }
      static get RIGHT() { return this.#_RIGHT; }
      static get JUSTIFY() { return this.#_JUSTIFY; }
    }

    const ALIGN_CLASSES = [["left-text", "left-align"], ["center-text", "center-align"], ["right-text", "right-align"], ["justify-text", "left-align"]];
    const ALIGN_CLASSES_FLAT = ALIGN_CLASSES.flat();

    function doAlign(alignType) {

      const selection = window.getSelection();

      if (!selection.rangeCount) return;
      const range = selection.getRangeAt(0);
      const nodeIds = [];
      const ALIGNABLE_NODE_CLASSES = ["text-block", "embedded-table", "embedded-content", "embedded-math", "embedded-local-image", "image-link"];

      if (range) {

        if (range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {

          const node = getTopLevelNodeOf(range.startContainer, editor);

          if (node?.classList && [...node.classList].some(c => ALIGNABLE_NODE_CLASSES.indexOf(c) > -1))
            nodeIds.push(node.id);
        } else {

          let nodeStart = getTopLevelNodeOf(range.startContainer, editor);
          let nodeEnd = getTopLevelNodeOf(range.endContainer, editor);

          while (nodeStart) {

            if (nodeStart.classList && [...nodeStart.classList].some(c => ALIGNABLE_NODE_CLASSES.indexOf(c) > -1))
              nodeIds.push(nodeStart.id);
            
            if (nodeStart === nodeEnd) {

              nodeEnd = null;
              break;
            }

            nodeStart = nodeStart.nextElementSibling;
          }

          while (nodeEnd) {

            if (nodeEnd.classList && [...nodeEnd.classList].some(c => ALIGNABLE_NODE_CLASSES.indexOf(c) > -1))
              nodeIds.push(nodeEnd.id);
            
            if (nodeStart === nodeEnd) break;

            nodeEnd = nodeEnd.previousElementSibling;
          }
        }
      }

      nodeIds.forEach((nodeId) => {

        const node = document.getElementById(nodeId);

        if (!node) return;

        if (node.classList?.contains("text-block")) {

          node.classList?.remove(...ALIGN_CLASSES_FLAT);
          const alignmentClass = ALIGN_CLASSES[alignType][0];

          if (node.classList) node.classList.add(alignmentClass);
          else node.setAttribute("class", alignmentClass);
        } else if (node.classList?.contains("embedded-table")) {

          const columnIdxSet = new Set();
          const alignmentClass = ALIGN_CLASSES[alignType][0];
          node.querySelectorAll("th, td").forEach((child) => {

            if (range.intersectsNode(child)) {

              let columnIndex = 1;
              const nodeName = child.nodeName;

              while (child.previousSibling) {
                child = child.previousSibling;
                if (child.nodeName === nodeName) ++columnIndex;
              };
              columnIdxSet.add(columnIndex);
            }
          });

          for (let columnIndex of columnIdxSet) {

            node?.querySelectorAll(`tr th:nth-child(${columnIndex}), tr td:nth-child(${columnIndex})`)?.forEach((el) => {

              el.classList?.remove(...ALIGN_CLASSES_FLAT);

              if (el.classList) el.classList.add(alignmentClass);
              else el.setAttribute("class", alignmentClass);
            });
          }
        } else if (node.firstElementChild) {

          node.classList?.remove(...ALIGN_CLASSES_FLAT);
          const alignmentClass = ALIGN_CLASSES[alignType][1];

          if (node.classList) node.classList.add(alignmentClass);
          else node.setAttribute("class", alignmentClass);
        }
      });
    }

    // Toggles dropdown visibility
    function toggleDropdown(id) {

      const dropdown = document.getElementById(id);

      if (dropdown.classList.contains("show")) {
        dropdown.classList.remove("show");
      } else {
        // Close any open dropdowns first
        document.querySelectorAll(".dropdown-content, .text-dropdown-content").forEach(el => el.classList.remove("show"));
        dropdown.classList.add("show");
      }
    }

    // Closes dropdowns if clicking outside
    document.addEventListener("click", function (e) {

      if (!e.target.closest(".dropdown")) {
        document.querySelectorAll(".dropdown-content").forEach(el => el.classList.remove("show"));
      }

      if (!e.target.closest(".text-dropdown")) {
        document.querySelectorAll(".text-dropdown-content").forEach(el => el.classList.remove("show"));
      }
    });

    // Helper: Places the caret at a given element and offset.
    function setCaret(el, pos) {

      const selection = window.getSelection();
      const range = document.createRange();
      range.setStart(el, pos);
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    class BitArray {

      #_bitCount = 0;
      #_a;

      constructor(bitCount) {
        this.#_bitCount = bitCount;
        this.#_a = new Uint32Array(Math.ceil(bitCount / 32)).fill(0);
      }

      get length() {
        return this.#_bitCount;
      }

      get isZero() {

        const n = this.#_a.length;

        for (let i = 0; i < n; ++i) {
          if (this.#_a[i] !== 0) return false;
        }

        return true;
      }

      identical(ba) {

        if (this.#_a.length === ba.#_a.length) {

          const n = this.#_a.length;

          for (let i = 0; i < n; ++i) {
            if (this.#_a[i] !== ba.#_a[i]) return false;
          }
          return true;
        }
        
        return false;
      }

      clone() {

        const ba = new BitArray(this.#_bitCount);
        ba.#_a = Uint32Array.from(this.#_a);

        return ba;
      }

      // Set the i-th bit to 1
      set(i) {

        const bigIndex = Math.floor(i / 32);
        const smallIndex = i % 32;

        this.#_a[bigIndex] = this.#_a[bigIndex] | (1 << smallIndex);
      }

      // Clear the i-th bit
      clear(i) {

        const bigIndex = Math.floor(i / 32);
        const smallIndex = i % 32;

        this.#_a[bigIndex] = this.#_a[bigIndex] & (~(1 << smallIndex));
      }

      setValue(i, value) {

        if (value) set(i);
        else clear(i);
      }

      // Return the value of the i-th bit
      get(i) {

        const bigIndex = Math.floor(i / 32);
        const smallIndex = i % 32;

        const value = this.#_a[bigIndex] & (1 << smallIndex);
        // we convert to boolean to make sure the result is always 0 or 1,
        // instead of what is returned by the mask
        return value != 0;
      }

      bitOrAssign(ba) {

        const n = Math.min(this.#_a.length, ba.#_a.length);

        for (let i = 0; i < n; ++i) {
          this.#_a[i] |= ba.#_a[i];
        }

        return this;
      }

      bitOr(ba) {
        return this.clone().bitOrAssign(ba);
      }

      bitAndAssign(ba) {

        const n = Math.min(this.#_a.length, ba.#_a.length);

        for (let i = 0; i < n; ++i) {
          this.#_a[i] &= ba.#_a[i];
        }

        return this;
      }

      bitAnd(ba) {
        return this.clone().bitAndAssign(ba);
      }

      invertAssign() {

        const n = this.#_a.length;

        for (let i = 0; i < n; ++i) {
          this.#_a[i] = ~this.#_a[i];
        }

        return this;
      }

      invert() {
        return this.clone().invertAssign();
      }
    }

    // Helper: gets the node's text
    function getNodeText(node) {

      if (node) {
        return ((node.nodeType === Node.TEXT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
            ? (node.textContent ?? "") : ((node.nodeName === "BR") ? "\n" : (node.innerText ?? "")));
      }

      return "";
    }

    // The core function that does the styling
    // using binary indexed trees
    function wrapRangeText(range, styleIndex) {

      // Checks if the node has the specified tag, style properties and attributes
      function nodeHasSameStyle(node, tagName, style, attributes) {

        if (node?.nodeName === tagName) {

          let styleOk = true;

          if (style) {
            for (let property in style) {
              if (node.style[property] !== style[property]) {
                styleOk = false;
                break;
              }
            }
          }
          let attributesOk = true;

          if (attributes) {
            for (let attribute in attributes) {
              if (((!node.hasAttribute(attribute) || !node.getAttribute(attribute)) && attributes[attribute]) ||
                  node.getAttribute(attribute) !== attributes[attribute]) {
                attributesOk = false;
                break;
              }
            }
          }

          if (styleOk && attributesOk) return true;
        }

        return false;
      }

      // For each node in the node tree returns the start and end positions in the text of the root node (specified as the argument)
      function getNodePositions(node) {

        const positions = new Map();
        let text = getNodeText(node);
        positions.set(node, {
          start: 0,
          end: text.length
        });
        const elements = [];
        node = node.hasChildNodes ? node.firstChild : null;

        while (node) {

          if (node.nodeType === Node.ELEMENT_NODE) {
            elements.push(...node.childNodes);
          }

          if (node.nodeType === Node.ELEMENT_NODE ||
              node.nodeType === Node.TEXT_NODE) {

            let prevSibling = node.previousSibling;

            while (prevSibling && !positions.has(prevSibling))
              prevSibling = prevSibling.previousSibling;

            text = getNodeText(node);
            const start = prevSibling ? positions.get(prevSibling).end : positions.get(node.parentNode).start;
            const end = start + text.length;

            positions.set(node, {
              start: start,
              end: end
            });

            while (node.nextSibling &&
                   node.nextSibling.nodeType !== Node.TEXT_NODE &&
                   node.nextSibling.nodeType !== Node.ELEMENT_NODE)
              node = node.nextSibling;
          }
          node = node.nextSibling ?? (elements.length > 0 ? elements.shift() : null);
        }

        return positions;
      }

      // For each character in the root node text (having maxTextLength) gets the styles applied to it as a bit pattern
      // (the binary indexed tree implementation)
      function getStyledPositions(positions, styles, maxTextLength) {

        const styledPositions = new Array(maxTextLength + 1);

        for (let i = 0; i < maxTextLength + 1; i++)
          styledPositions[i] = new BitArray(styles.length);

        const a = new Int32Array(maxTextLength + 1);
        let styleIndex = 0;

        for (const style of styles) {

          const styleBitPattern = new BitArray(styles.length);
          styleBitPattern.set(styleIndex++);
          const entries = positions.entries().filter(([node, value]) => nodeHasSameStyle(node, style.tagName.toUpperCase(), style.style, style.attributes));
          a.fill(0);

          for (const [_, value] of entries) {
            a[value.start] += 1;
            a[value.end] -= 1;
          }

          for (let i = 0; i < a.length - 1; ++i) {

            a[i + 1] += a[i];

            if (a[i]) styledPositions[i].bitOrAssign(styleBitPattern);
          }
        }

        return styledPositions;
      }

      // determines which type of nodes are stylable (H1-H6, P, SMALL, or any direct child of TH or TD)
      function isSelectableNodeForStyling(node) {
        return node && (node.nodeName === "P" || ["TH", "TD"].includes(node.parentNode?.nodeName));
      }

      // Gets the list of text positions of all the nodes within the root container and within the specified range
      function getSelectionPositions(rootContainer, range) {

        const selPositions = [];

        if (range) {

          if (range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {

            const node = getTopLevelNodeOf(range.startContainer, rootContainer);

            if (node) {

              const positions = getNodePositions(node);
              const start = positions.get(range.startContainer).start + range.startOffset;
              const end = start + range.endOffset - range.startOffset;
              selPositions.push({ node: node, start: start, end: end, positions: positions });
            }
          } else {

            let nodeStart = getTopLevelNodeOf(range.startContainer, rootContainer);
            let nodeEnd = getTopLevelNodeOf(range.endContainer, rootContainer);

            while (nodeStart &&
                   nodeStart !== nodeEnd &&
                   !isSelectableNodeForStyling(nodeStart))
              nodeStart = nodeStart.nextSibling;

            while (nodeEnd &&
                   nodeStart !== nodeEnd &&
                   !isSelectableNodeForStyling(nodeEnd))
              nodeEnd = nodeEnd.previousSibling;

            if (nodeStart && nodeEnd) {

              if (nodeStart === nodeEnd) {

                const positions = getNodePositions(nodeStart);
                const start = positions.get(range.startContainer).start + range.startOffset;
                const end = positions.get(range.endContainer).start + range.endOffset;
                selPositions.push({ node: nodeStart, start: start, end: end, positions: positions });
              } else {

                let positions = getNodePositions(nodeStart);
                let start = positions.get(range.startContainer).start + range.startOffset;
                let end = positions.get(nodeStart).end;
                selPositions.push({ node: nodeStart, start: start, end: end, positions: positions });

                let node = nodeStart.nextSibling;

                while (node && node !== nodeEnd) {

                  if (node.parentNode === rootContainer && isSelectableNodeForStyling(node)) {

                    positions = getNodePositions(node);
                    start = positions.get(node).start;
                    end = positions.get(node).end;
                    selPositions.push({ node: node, start: start, end: end, positions: positions });
                  }
                  node = node.nextSibling;
                }

                positions = getNodePositions(nodeEnd);
                start = positions.get(nodeEnd).start;
                end = positions.get(range.endContainer).start + range.endOffset;
                selPositions.push({ node: nodeEnd, start: start, end: end, positions: positions });
              }
            }
          }
        }

        return selPositions;
      }

      // Creates HTML text elements and BR elements from the specified text
      function createHtmlElementsFromText(text, start, end, callback) {

        const elements = text.split("\n");

        for (let i = 0; i < elements.length; i++) {
          elements[i] = document.createTextNode(elements[i]);
        }

        for (let i = elements.length - 1; i > 0; i--) {
          elements.splice(i, 0, document.createElement("br"));
        }

        if (start > -1 || end > -1) {

          let length = 0;
          let startNode = null, endNode = null, offsetStart = 0, offsetEnd = 0;

          for (let i = 0; i < elements.length; i++) {

            const currElementLength = ((elements[i].nodeName === "BR") ? 1 : elements[i].textContent.length);

            if (length <= start && start < length + currElementLength) {
              startNode = elements[i];
              offsetStart = start - length;
            }

            if (length < end && end <= length + currElementLength) {
              endNode = elements[i];
              offsetEnd = end - length;
            }

            length += currElementLength;
          }
          callback(startNode, endNode, offsetStart, offsetEnd);
        }
        
        return elements;
      }

      // Applies CSS style to the element
      function applyCss(element, style) {

        for (let property in style) {
          element.style[property] = style[property];
        }
      }

      // Creates the HTML node with the specified text and styles, having the specified parent
      function createHtmlNode(parentNode, text, styleBitPattern, start, end) {

        text = text.replace(/\t/, "&nbsp;"); // "&emsp;" "&ensp;"
        let nodeStart = null, nodeEnd = null, startOffset = 0, endOffset = 0;

        function callback(startNode, endNode, offsetStart, offsetEnd) {

          if (!nodeStart) {
            nodeStart = startNode;
            startOffset = offsetStart;
          }

          if (!nodeEnd) {
            nodeEnd = endNode;
            endOffset = offsetEnd;
          }
        }

        if (styleBitPattern.isZero) {
          parentNode.append(...createHtmlElementsFromText(text, start, end, callback));
        } else {

          for (let i = 0; i < styleBitPattern.length; ++i) {

            if (styleBitPattern.get(i)) {

              const child = document.createElement(STYLES[i].tagName);
              
              if (STYLES[i].style) {
                applyCss(child, STYLES[i].style);
              }

              if (STYLES[i].attributes) {
                for (let attribute in STYLES[i].attributes) {
                  child.setAttribute(attribute, STYLES[i].attributes[attribute]);
                }
              }
              parentNode.appendChild(child);
              parentNode = child;
            }
          }
          parentNode.append(...createHtmlElementsFromText(text, start, end, callback));
        }

        return [nodeStart, nodeEnd, startOffset, endOffset];
      }

      // Rebuilds the HTML tree rooted at node and with the specified styles (specified as an array of style bit patterns, one style bit pattern for each character)
      function buildHtmlTree(node, styledPositions, start, end) {

        const text = getNodeText(node);
        const length = text.length;
        let p = 0;
        const frag = document.createDocumentFragment();
        let nodeStart = null, nodeEnd = null, startOffset = 0, endOffset = 0;

        for (let i = 1; i < length; ++i) {

          if (!styledPositions[i].identical(styledPositions[p])) {

            const s = (p <= start && start < i) ? start - p : -1;
            const e = (p < end && end <= i) ? end - p : -1;
            const [nodeStartTmp, nodeEndTmp, startOffsetTmp, endOffsetTmp] = createHtmlNode(frag, text.substring(p, i), styledPositions[p], s, e);
            p = i;

            if (!nodeStart) {
              nodeStart = nodeStartTmp;
              startOffset = startOffsetTmp;
            }

            if (!nodeEnd) {
              nodeEnd = nodeEndTmp;
              endOffset = endOffsetTmp;
            }
          }
        }

        if (p < length) {

          const s = (p <= start && start < length) ? start - p : -1;
          const e = (p < end && end <= length) ? end - p : -1;
          const [nodeStartTmp, nodeEndTmp, startOffsetTmp, endOffsetTmp] = createHtmlNode(frag, text.substring(p), styledPositions[p], s, e);

          if (!nodeStart) {
            nodeStart = nodeStartTmp;
            startOffset = startOffsetTmp;
          }

          if (!nodeEnd) {
            nodeEnd = nodeEndTmp;
            endOffset = endOffsetTmp;
          }
        }

        if (node.nodeType === Node.ELEMENT_NODE) {
          node.replaceChildren(frag);
        } else if (node.nodeType === Node.TEXT_NODE) {
          node.replaceWith(frag);
        }

        return [nodeStart, nodeEnd, startOffset, endOffset];
      }

      // gets the current range
      if (!range) {

        const selection = window.getSelection();

        if (selection?.rangeCount) {
          range = selection.getRangeAt(0);
        }
      }

      if (!range) return;

      // finds the current root container to work on
      let rootNode = range.commonAncestorContainer;
      let rootContainer = document.getElementById("editor");

      while (rootNode && rootNode !== rootContainer) {

        if (["TH", "TD"].includes(rootNode.nodeName)) {
          rootContainer = rootNode.parentNode;
          break;
        }
        rootNode = rootNode.parentNode;
      }
      // gets all the selected nodes within the root container as a list of start and end positions within each root container's direct child text
      const selPositions = getSelectionPositions(rootContainer, range);
      const styledPositions = [];
      let removeStyle = true;

      const styleBitPattern = new BitArray(STYLES.length);
      styleBitPattern.set(styleIndex); // the bit pattern of the style we want to apply over the selected text

      // for each root container's direct selected child we get the current styling (getStyledPositions)
      for (const p of selPositions) {

        const styled = getStyledPositions(p.positions, STYLES, p.positions.get(p.node).end);

        for (let i = p.start; i < p.end; ++i) { // we compare with the current style pattern, if all the selected text contains the style completely it means we want to remove the styling
          if (styled[i].bitAnd(styleBitPattern).isZero) removeStyle = false; // if there area characters that don't have the style then we must apply the new style
        }                                                                    // otherwise we remove the style on all the characters in the range
        styledPositions.push(styled);
      }
      const rangeNodes = [];

      if (removeStyle) { // if we want to remove the styling

        styleBitPattern.invertAssign(); // we invert the current style bit pattern

        for (let i = 0; i < selPositions.length; ++i) { // for each root container's direct selected child text

          const styled = styledPositions[i];

          for (let j = selPositions[i].start; j < selPositions[i].end; ++j) {
            styled[j].bitAndAssign(styleBitPattern);      // we remove the style by applying the inverted bit pattern
          }                                               // to each of the characters' style pattern in the range
          const start = (i == 0) ? selPositions[i].start : -1;
          const end = (i == selPositions.length - 1) ? selPositions[i].end : -1;
          const [nodeStart, nodeEnd, startOffset, endOffset] = buildHtmlTree(selPositions[i].node, styled, start, end); // we rebuild the HTML tree rooted at node
          if (nodeStart || nodeEnd) rangeNodes.push([nodeStart, nodeEnd, startOffset, endOffset]);
        }
      } else {

        let styleGroupClearBitPattern = null; // if the current style is part of a style group, we create a clear styles bit pattern
                                              // to remove the other styles in the group applied to the selected text
                                              // (for example the text color styles, we don't want to apply multiple text colors over the same text)
        for (let styleGroup of STYLE_GROUPS) {

          if (styleIndex >= styleGroup[0] && styleIndex <= styleGroup[1]) {

            styleGroupClearBitPattern = new BitArray(STYLES.length);

            for (let i = styleGroup[0]; i <= styleGroup[1]; i++) {
              styleGroupClearBitPattern.set(i);
            }
            styleGroupClearBitPattern.invertAssign();  // we invert the bit pattern for all the styles in the group
            styleGroupClearBitPattern.set(styleIndex); // we let the current style bit pattern on
            break;
          }
        }

        for (let i = 0; i < selPositions.length; ++i) { // for each root container's direct selected child text

          const styled = styledPositions[i];

          for (let j = selPositions[i].start; j < selPositions[i].end; ++j) {
            if (styleGroupClearBitPattern) styled[j].bitAndAssign(styleGroupClearBitPattern); // we remove other style(s) in the same group with the current style, for each selected character
            styled[j].bitOrAssign(styleBitPattern);     // we apply the style by applying the style bit pattern
          }                                             // to each of the characters' style pattern in the range
          const start = (i == 0) ? selPositions[i].start : -1;
          const end = (i == selPositions.length - 1) ? selPositions[i].end : -1;
          const [nodeStart, nodeEnd, startOffset, endOffset] = buildHtmlTree(selPositions[i].node, styled, start, end); // we rebuild the HTML tree rooted at node
          if (nodeStart || nodeEnd) rangeNodes.push([nodeStart, nodeEnd, startOffset, endOffset]);
        }
      }
      window.getSelection().removeAllRanges(); // we remove all selection's ranges after HTML tree rebuild

      if (rangeNodes.length) {

        const range = document.createRange();
        range.setStart(rangeNodes[0][0], rangeNodes[0][2]);
        const i = (rangeNodes.length > 1) ? 1 : 0;
        range.setEnd(rangeNodes[i][1], rangeNodes[i][3]);
        window.getSelection().addRange(range);
      }
    }

    // Basic inline formatting: wraps the selection in the specified tag.
    function applyFormat(styleIndex) {

      const selection = window.getSelection();

      if (!selection.rangeCount || selection.isCollapsed) return;
      const range = selection.getRangeAt(0);

      if (!editor.contains(range.commonAncestorContainer)) return;
      updateLinkStyles(editor);
      wrapRangeText(range, styleIndex);
    }

    // Applies inline style (e.g., font-size, text color, background color) by wrapping the selection in a <span>.
    function applyStyle(styleIndex) {

      const selection = window.getSelection();

      if (!selection.rangeCount || selection.isCollapsed) return;
      const range = selection.getRangeAt(0);

      if (!editor.contains(range.commonAncestorContainer)) return;
      updateLinkStyles(editor);
      wrapRangeText(range, styleIndex);
    }

    // Applies inline url
    async function applyURL() {

      const selection = window.getSelection();

      if (!selection.rangeCount || selection.isCollapsed) return;
      const range = selection.getRangeAt(0);

      if (!editor.contains(range.commonAncestorContainer)) return;
      const url = (await showPrompt("URL"))?.trim();

      if (!url) return;
      updateLinkStyles(editor);
      let linkStyleIndex = STYLES.length - 1;

      for ( ; linkStyleIndex > STYLE_LINK_BASE_INDEX; linkStyleIndex--) {
        if (STYLES[linkStyleIndex].tagName === "a" &&
            STYLES[linkStyleIndex].attributes &&
            STYLES[linkStyleIndex].attributes["href"] === url) {
          break;
        }
      }

      if (linkStyleIndex <= STYLE_LINK_BASE_INDEX) {
        STYLES.push({tagName: "a", style: null, attributes: { "href": url }});
        linkStyleIndex = STYLES.length - 1;
      }

      wrapRangeText(range, linkStyleIndex);
    }

    // Called by the text size dropdown.
    function applyFontSize(size) {

      if (!size) return;
      applyStyle(STYLE_FONT_BASE_INDEX + size);
    }

    // Called when a text color swatch is clicked.
    function applyTextColor(color) {

      if (!color) return;
      applyStyle(STYLE_TEXT_COLOR_BASE_INDEX + color);
    }

    // Called when a highlight (background color) swatch is clicked.
    function applyHighlightColor(color) {

      if (!color) return;
      applyStyle(STYLE_HIGHLIGHT_COLOR_BASE_INDEX + color);
    }

    // Changes the nodes specified by their ids into the specified text level.
    // Used by the undo stack.
    function changeTextLevels(nodeIds, nodeTextLevelClasses, textLevelClass) {

      for (let i = 0; i < nodeIds.length; ++i) {

        const nodeId = nodeIds[i];
        const node = document.getElementById(nodeId);

        if (node) {

          const nodeTextLevelClass = nodeTextLevelClasses[i];

          if (node.classList?.contains(nodeTextLevelClass)) node.classList.remove(nodeTextLevelClass);

          if (textLevelClass !== "medium-text") {
            node.classList?.add(textLevelClass);
          }
        }
      }
    }

    // Changes the nodes specified by their ids back into the specified text levels.
    // Used by the undo stack.
    function undoChangeTextLevels(nodeIds, nodeTextLevelClasses, textLevelClass) {

      for (let i = 0; i < nodeIds.length; ++i) {

        const nodeId = nodeIds[i];
        const node = document.getElementById(nodeId);

        if (node) {

          if (node.classList?.contains(textLevelClass)) node.classList.remove(textLevelClass);

          const nodeTextLevelClass = nodeTextLevelClasses[i];

          if (nodeTextLevelClass !== "medium-text") {
            node.classList?.add(nodeTextLevelClass);
          }
        }
      }
    }

    const TEXT_LEVEL_CLASSES = ["xlarge-text", "large-text", "medium-text", "small-text"];

    // Converts the currently selected text blocks (direct children of #editor) to the chosen text level.
    function changeBlock(textLevelClass) {

      const selection = window.getSelection();

      if (!selection.rangeCount) return;
      const range = selection.getRangeAt(0);
      const nodeIds = [];

      function isSelectableNode(node) {

        const textLevelClasses = ["xlarge-text", "large-text", "small-text"];
        return node?.classList?.contains("text-block") &&
              (textLevelClass === "medium-text" ? [...node.classList].some(c => textLevelClasses.indexOf(c) > -1) :
                                                  !node.classList.contains(textLevelClass));
      }

      function getCurrentTextLevel(node) {

        for (let textLevelClass of TEXT_LEVEL_CLASSES) {
          if (node.classList.contains(textLevelClass)) return textLevelClass;
        }

        return "medium-text";
      }

      if (range) {

        if (range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {

          const node = getTopLevelNodeOf(range.startContainer, editor);

          if (isSelectableNode(node)) nodeIds.push(node.id);
        } else {

          let nodeStart = getTopLevelNodeOf(range.startContainer, editor);
          let nodeEnd = getTopLevelNodeOf(range.endContainer, editor);

          while (nodeStart) {

            if (isSelectableNode(nodeStart))
              nodeIds.push(nodeStart.id);
            
            if (nodeStart === nodeEnd) {

              nodeEnd = null;
              break;
            }

            nodeStart = nodeStart.nextElementSibling;
          }

          while (nodeEnd) {

            if (isSelectableNode(nodeEnd))
              nodeIds.push(nodeEnd.id);
            
            if (nodeStart === nodeEnd) break;

            nodeEnd = nodeEnd.previousElementSibling;
          }
        }
        const startContainer = range.startContainer;
        const endContainer = range.endContainer;
        const startContainerId = startContainer.id;
        const endContainerId = endContainer.id;
        const startOffset = range.startOffset;
        const endOffset = range.endOffset;
        const nodeTextLevelClasses = nodeIds.map((nodeId) => getCurrentTextLevel(document.getElementById(nodeId))) ?? [];

        if (nodeIds.length > 0) UNDO_STACK.push(changeTextLevels, undoChangeTextLevels, nodeIds, nodeTextLevelClasses, textLevelClass);

        range.setStart(startContainerId ? document.getElementById(startContainerId) : startContainer, startOffset);
        range.setEnd(endContainerId ? document.getElementById(endContainerId) : endContainer, endOffset);

        selection.removeAllRanges();
        selection.addRange(range);
      }
    }

    // Helper: Gets the last deepest child of the specified node
    function getLastDeepestChild(node) {

      if (!node) return node;

      while (node.lastChild) {

        node = node.lastChild;

        while (node.previousSibling &&
               node.nodeType === Node.TEXT_NODE &&
               !node.textContent.length)
          node = node.previousSibling;

        if (node.nodeName === "BR") break;
      }

      return node;
    }

    // Splits the current block at the caret.
    function splitBlock(range) {

      if (!range) return;
      let block = range.startContainer;

      while (block && block.parentNode !== editor) {
        block = block.parentNode;
      }

      if (!block) { // adds a new empty text block (paragraph) at the end of the document

        const p = document.createElement("p");
        p.setAttribute("id", `text${generateUId()}`);
        p.setAttribute("class", "text-block");
        p.innerHTML = "<br/>";
        editor.appendChild(p);
        setCaret(p, 0);
        return;
      }
      const isTextBlock = block.classList?.contains("text-block");
      const newBlock = document.createElement(isTextBlock ? block.nodeName.toLowerCase() : "p");
      newBlock.setAttribute("id", `text${generateUId()}`);
      newBlock.setAttribute("class", isTextBlock ? block.getAttribute("class") : "text-block");

      const startContainer = range.startContainer;
      const extractRange = range.cloneRange();
      extractRange.setEndAfter(block.lastChild || block);
      const extracted = extractRange.extractContents(); // selects all content from start of caret to end of current block

      if (!extracted.childNodes.length) { // this should not happen: this means the caret is at the end of current block
        newBlock.innerHTML = "<br/>";
      } else {

        newBlock.appendChild(extracted);
        const ldc = getLastDeepestChild(newBlock);

        if (ldc?.nodeName !== "BR") {

          if (ldc.nodeType === Node.ELEMENT_NODE) {
            ldc.appendChild(document.createElement("br"));
          } else if (ldc.nodeType === Node.TEXT_NODE) {
            if (ldc.parentNode.nodeName !== "BR") ldc.parentNode.appendChild(document.createElement("br"));
            else ldc.parentNode.parentNode.appendChild(document.createElement("br"));
          } else {
            newBlock.appendChild(document.createElement("br"));
          }
        }
      }
      editorInsertBefore(newBlock, block.nextSibling?.id);
      const ldc = getLastDeepestChild(block);

      if (ldc.nodeName !== "BR" || ldc !== startContainer) {

        if (ldc.nodeType === Node.TEXT_NODE || ldc.nodeName === "BR") {
          if (ldc.parentNode.nodeName !== "BR") ldc.parentNode.appendChild(document.createElement("br"));
          else ldc.parentNode.parentNode.appendChild(document.createElement("br"));
        } else if (ldc.nodeType === Node.ELEMENT_NODE) {
          ldc.appendChild(document.createElement("br"));
        } else {
          block.appendChild(document.createElement("br"));
        }
      }

      setCaret(newBlock, 0); // move the caret into the new block
    }

    // Normalizes stray text nodes and nested blocks.
    function normalizeEditor() {

      Array.from(editor.childNodes).forEach(node => {

        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {

          const p = document.createElement("p");
          p.setAttribute("id", `text${generateUId()}`);
          p.setAttribute("class", "text-block");
          p.textContent = node.textContent;
          editor.replaceChild(p, node);
        }
      });
      editor.querySelectorAll("p p, h1 p, h2 p, h3 p, h4 p, h5 p, h6 p, p font, small p").forEach(nested => {

        const parent = nested.parentNode;

        if (!parent.id && nested.childElementCount === 1) {

          parent.insertBefore(nested.firstChild, nested);
          parent.removeChild(nested);
          parent.id = nested.id;
          return ;
        }

        while (nested.firstChild) {
          parent.insertBefore(nested.firstChild, nested);
        }
        parent.removeChild(nested);
      });
    }

    // Normalize stray text nodes and nested blocks.
    function cleanEditor() {

      if (editor.firstChild && ["H1", "H2", "H3", "H4", "H5", "H6", "P", "SMALL"].includes(editor.firstChild.nodeName)) {
        return;
      }
      const htmlText = editor.innerHTML.trim();

      if (htmlText === "" || htmlText === "<br>" || htmlText === "<br/>") {
        editor.innerHTML = `<p class="text-block" id="text${generateUId()}"><br/></p>`;
      }
    }

    function updateTitle() {

      if (filename.innerHTML === "<br>" || filename.innerHTML === "<br/>") {
        filename.innerHTML = "";
      }

      document.title = filename.innerHTML.trim() || "Nash Note";
    }

    function handleEnterKey(range, parentNodeNames) {

      let block = range?.startContainer;

      while (block && block !== editor) {

        if (block.nodeType === Node.ELEMENT_NODE && parentNodeNames.includes(block.nodeName)) {

          const textNode = range.startContainer;

          if (textNode.nodeName === "BR") {

            const brNode = document.createElement("br");
            textNode.parentNode.insertBefore(brNode, textNode.nextSibling);
            setCaret(brNode, 0);
          } else if (parentNodeNames.includes(textNode.nodeName) || textNode.nodeType === Node.ELEMENT_NODE) {

            if (textNode.childNodes.length > range.startOffset) {
              textNode.insertBefore(document.createElement("br"), textNode.childNodes[range.startOffset]);
            } else {
              textNode.appendChild(document.createElement("br"));
            }
            setCaret(textNode, range.startOffset + 1);
          } else if (textNode.nodeType === Node.TEXT_NODE) {

            const text1 = textNode.textContent.substring(0, range.startOffset);
            const text2 = textNode.textContent.substring(range.startOffset);
            const newTextNode = text2?.length ? document.createTextNode(text2) : null;
            const parentNode = textNode.parentNode;
            const nextSibling = textNode.nextSibling;
            const brNode = document.createElement("br");
            parentNode.insertBefore(brNode, nextSibling);

            if (text1?.length) {

              if (textNode.textContent !== text1) {
                textNode.textContent = text1;
              }
            } else {
              parentNode.removeChild(textNode);
            }

            if (newTextNode) {

              parentNode.insertBefore(newTextNode, nextSibling);
              setCaret(newTextNode, 0);
            } else if (text1?.length) {

              if (!nextSibling) {

                if (parentNodeNames.includes(parentNode.nodeName)) {

                  const brNode2 = document.createElement("br");
                  parentNode.insertBefore(brNode2, nextSibling);
                  setCaret(parentNode, [...parentNode.childNodes].indexOf(brNode2));
                } else {
                  let p = parentNode;
                  while (p && !p.nextSibling) p = p.parentNode;
                  if (p?.nextSibling) setCaret(p.nextSibling, 0);
                }
              } else {
                setCaret(parentNode, [...parentNode.childNodes].indexOf(nextSibling));
              }
            } else {

              const brNode2 = document.createElement("br");
              parentNode.insertBefore(brNode2, nextSibling);
              setCaret(brNode2, 0);
            }
          }
          return true;
        }
        block = block.parentNode;
      }

      return false;
    }

    function handleBackspaceInEmptyTextContent(topNode, e) {

      let shouldHandle = topNode.classList?.contains("code-block") &&
                         topNode.firstChild.nodeName === "PRE" &&
                         (!topNode.textContent?.length || topNode.textContent === "\n" || topNode.innerText === "\n");
      shouldHandle = shouldHandle || (topNode.classList?.contains("text-block") && (!topNode.innerText?.length || topNode.innerText === "\n"));

      if (shouldHandle) { // if the node is empty

        e.stopImmediatePropagation();  // cancel the event
        e.preventDefault();
        let sibling = topNode.previousElementSibling; // find a previous text or code sibling node to move the focus to (the cursor caret)

        while (sibling &&
              !sibling.classList?.contains("text-block") &&
              !sibling.classList?.contains("code-block")) {
          sibling = sibling.previousElementSibling;
        }

        if (sibling) {   // if a sibling was found

          const selection = window.getSelection(); // remove all selections
          selection.removeAllRanges();
          topNode.replaceChildren();
          topNode.remove();
          let lastChild = null; // get the last deepest child of the text or code block

          if (sibling.classList?.contains("code-block")) {
            lastChild = getLastDeepestChild(sibling.querySelector("code"));
          } else {
            lastChild = getLastDeepestChild(sibling);
          }

          if (lastChild) setCaret(lastChild, lastChild.textContent?.length ?? 0); // and set the caret at the end of it
        }

        return true; // node with empty text was handled
      }

      return false;
    }

    function keydownHandler(e) {

      let range = null;
      const selection = window.getSelection();

      if (selection.rangeCount) {
        range = selection.getRangeAt(0);
      }
      let block = range?.startContainer;

      if (block) {

        const BLOCKED_NODE_CLASSES = [
          "embedded-local-epub",
          "embedded-local-pdf",
          "embedded-local-image",
          "embedded-local-audio",
          "embedded-table",
          "image-link",
          "audio-link",
          "video-link",
          "pdf-link",
          "audio-recording",
          "recording-control-buttons-container"
        ];

        if (block.parentNode &&
            [...block.parentNode.classList].some(c => BLOCKED_NODE_CLASSES.indexOf(c) > -1)) {
            e.stopImmediatePropagation();
            e.preventDefault();
            return;
        }
        let p = block;
        let shouldNormalizeEditor = true;

        while (p && p.id !== "editor") {

          if (p.classList?.contains("text-block") ||
              p.classList?.contains("code-block") ||
              p.classList?.contains("embedded-table")) {
            shouldNormalizeEditor = false;
            break;
          }
          p = p.parentNode;
        }

        if (shouldNormalizeEditor) {

          // don't block some control keys (like Left, Right, Up and Down); block the rest
          const keyCode = e.keyCode || e.which;

          if (keyCode < 33 || keyCode > 44) {

            e.stopImmediatePropagation();
            e.preventDefault();
            return;
          }
        }
      }

      if (e.key === "Enter" && !e.shiftKey) {

        if (block && handleEnterKey(range, ["CODE", "TD", "TH"])) {

          e.stopImmediatePropagation();
          e.preventDefault();
          return;
        }
        e.preventDefault();
        splitBlock(range);
        return;
      }
      let handleBackspace = false;
      let topNode = null;

      if (e.key === "Backspace") {

        if (range.startContainer === range.endContainer &&
            range.startOffset === range.endOffset) {

          if (range.startOffset === 0) {
            handleBackspace = true;
          } else {
            topNode = getTopLevelNodeOfCurrentPosition();

            if (topNode) {

              if (block === topNode) {

                const childNodes = [...topNode.childNodes];
                handleBackspace = true;

                for (let i = 0; i < range.startOffset && i < childNodes.length; i++) {

                  if (childNodes[i].nodeType !== Node.TEXT_NODE || childNodes[i].textContent.length) {
                    handleBackspace = false;
                    break;
                  } 
                }
              }
            }
          }
        }
      }

      if (handleBackspace) {

        topNode = topNode || getTopLevelNodeOfCurrentPosition();

        if (topNode) {

          // blocks moving of the current line in the code block into the previous sibling p node
          if (topNode.classList?.contains("code-block") && !(block?.previousSibling)) {

            if (handleBackspaceInEmptyTextContent(topNode, e)) return;

            e.stopImmediatePropagation();
            e.preventDefault();
            return;
          }

          if (topNode.classList?.contains("text-block")) {

            if (handleBackspaceInEmptyTextContent(topNode, e)) return;

            const previousElementSibling = topNode.previousElementSibling;

            if (topNode === block &&
                (!previousElementSibling ||
                !previousElementSibling.classList?.contains("text-block"))) {

              e.stopImmediatePropagation();
              e.preventDefault();
              return;
            }
            let focusChild = (block === topNode ? block.firstChild : block);

            while (block !== topNode) {

              while (block.previousSibling) {
  
                block = block.previousSibling;

                if (block.nodeName === "BR") {
                  return;
                }

                if (block.nodeType === Node.TEXT_NODE) {

                  if (getNodeText(block).length) {
                    return;
                  }
                } else if (block.nodeType === Node.ELEMENT_NODE) {

                  if (getNodeText(block).length || block.querySelector("br")) {
                    return;
                  }
                }
              }

              block = block.parentNode;
            }

            if (!previousElementSibling ||
                !previousElementSibling.classList?.contains("text-block")) {

              e.stopImmediatePropagation();
              e.preventDefault();
              return;
            }

            // combining current text block with the previous text block
            let lastChild = previousElementSibling.lastChild;

            while (lastChild) {

              while (lastChild &&
                     (lastChild.nodeType !== Node.ELEMENT_NODE || !lastChild.lastChild) &&
                     !getNodeText(lastChild).length) {
                lastChild = lastChild.previousSibling;
              }

              if (lastChild &&
                  lastChild.nodeName !== "BR" &&
                  lastChild.lastChild) {
                lastChild = lastChild.lastChild;
              } else {
                break;
              }
            }
            lastChild = lastChild || previousElementSibling;

            if (lastChild === previousElementSibling) {
              previousElementSibling.replaceChildren();
            } else if (lastChild.nodeName === "BR") {

              if (lastChild.hasChildNodes) lastChild.replaceChildren();
              lastChild.remove();
            }
            previousElementSibling.append(...topNode.childNodes);
            topNode.replaceChildren();
            topNode.remove();

            if (focusChild) {
              setCaret(focusChild, 0);
            } else {
              selection.removeAllRanges();
              editor?.focus();
            }
            e.stopImmediatePropagation();
            e.preventDefault();
          }
        }
      }

      if ((e.ctrlKey || e.metaKey) && (e.key === "z" || e.key === "y")) {
        e.preventDefault();
      }
    }

    function clickHandler(e) {
      const target = e.target.closest("a");
      if (!target || !document.getElementById("editorContainer").contains(target)) return;

      e.preventDefault();

      const userConfirmed = confirm(`"${target.href}" open this url?`);
      if (userConfirmed) {
        window.open(target.href, "_blank");
      }
    }

    function unloadHandler(e) {

      if (document.getElementById("editor").contentEditable !== "true") {
        return;
      }
      e.preventDefault()
      e.returnValue = "";
    }

    let lastValidSelectionRange = null;

    document.onselectionchange = () => {

      const selection = document.getSelection();

      if (selection?.rangeCount) {

        const range = selection.getRangeAt(0);

        if (editor.contains(range.commonAncestorContainer)) {

          lastValidSelectionRange = range;
        }
      }

      if (lastValidSelectionRange &&
          (lastValidSelectionRange.startContainer !== lastValidSelectionRange.endContainer ||
          lastValidSelectionRange.startOffset !== lastValidSelectionRange.endOffset) &&
          editor.contains(lastValidSelectionRange.commonAncestorContainer)) {

        document.getElementById("btnLinkText").removeAttribute("disabled");
        document.getElementById("btnLinkText").setAttribute("title", "Make text link");
      } else {

        document.getElementById("btnLinkText").setAttribute("disabled", " ");
        document.getElementById("btnLinkText").setAttribute("title", "Select a text to make link");
      }
    };

    editor.addEventListener("keydown", keydownHandler);
    editor.addEventListener("click", clickHandler);
    editor.addEventListener("blur", normalizeEditor);
    editor.addEventListener("input", cleanEditor);
    editor.addEventListener("focus", cleanEditor);

    filename.addEventListener("input", updateTitle);

    window.addEventListener("beforeunload", unloadHandler);

    loadAllReferencedDocuments();

    document.querySelectorAll(".text-block").forEach(el => {
      if (!el.getAttribute("id")) el.setAttribute("id", `text${generateUId()}`);
    });

    updateTitle();

    /* Event handlers */

    document.querySelectorAll(".embedded-math math").forEach(mathNode => mathNode.addEventListener("click", onMathClick));

    document.getElementById("btnH1").addEventListener("click", (e) => changeBlock("xlarge-text"));
    document.getElementById("btnH2").addEventListener("click", (e) => changeBlock("large-text"));
    document.getElementById("btnM").addEventListener("click", (e) => changeBlock("medium-text"));
    document.getElementById("btnS").addEventListener("click", (e) => changeBlock("small-text"));

    document.getElementById("btnB").addEventListener("click", (e) => applyFormat(STYLE_STRONG_INDEX));
    document.getElementById("btnI").addEventListener("click", (e) => applyFormat(STYLE_EM_INDEX));
    document.getElementById("btnU").addEventListener("click", (e) => applyFormat(STYLE_U_INDEX));
    document.getElementById("btnStrikethrough").addEventListener("click", (e) => applyFormat(STYLE_S_INDEX));

    document.getElementById("btnTextColorMenu").addEventListener("click", (e) => toggleDropdown("textColorDropdown"));

    for (let i = 1; i < TEXT_COLORS_N + 1; ++i) {
      document.getElementById(`btnTextColor${i}`).addEventListener("click", (e) => {
        applyTextColor(i);
        toggleDropdown("textColorDropdown");
      });
    }

    document.getElementById("btnTextHighlightMenu").addEventListener("click", (e) => toggleDropdown("highlightDropdown"));

    for (let i = 1; i < HIGHLIGHT_COLORS_N + 1; ++i) {
      document.getElementById(`btnTextHighlight${i}`).addEventListener("click", (e) => {
        applyHighlightColor(i);
        toggleDropdown("highlightDropdown");
      });
    }

    document.getElementById("btnFontSizeMenu").addEventListener("click", (e) => toggleDropdown("fontSizeDropdown"));

    for (let i = 1; i < FONT_SIZES_N + 1; ++i) {
      document.getElementById(`btnFontSize${i}`).addEventListener("click", (e) => {
        applyFontSize(i);
        toggleDropdown("fontSizeDropdown");
      });
    }

    document.getElementById("btnAlign").addEventListener("click", (e) => toggleDropdown("alignDropdown"));
    document.getElementById("btnLeftTextAlign").addEventListener("click", (e) => {
      toggleDropdown("alignDropdown");
      doAlign(AlignType.LEFT);
    });
    document.getElementById("btnCenterTextAlign").addEventListener("click", (e) => {
      toggleDropdown("alignDropdown");
      doAlign(AlignType.CENTER);
    });
    document.getElementById("btnRightTextAlign").addEventListener("click", (e) => {
      toggleDropdown("alignDropdown");
      doAlign(AlignType.RIGHT);
    });
    document.getElementById("btnJustifyTextAlign").addEventListener("click", (e) => {
      toggleDropdown("alignDropdown");
      doAlign(AlignType.JUSTIFY);
    });

    document.getElementById("btnText").addEventListener("click", (e) => insertText());
    document.getElementById("btnCode").addEventListener("click", (e) => insertCode());

    document.getElementById("btnLinks").addEventListener("click", (e) => toggleDropdown("linksDropdown"));
    document.getElementById("btnLinkText").addEventListener("click", (e) => {
      toggleDropdown("linksDropdown");
      applyURL();
    });
    document.getElementById("btnLinkImage").addEventListener("click", (e) => {
      toggleDropdown("linksDropdown");
      insertImageLink();
    });
    document.getElementById("btnLinkAudio").addEventListener("click", (e) => {
      toggleDropdown("linksDropdown");
      insertAudioLink();
    });
    document.getElementById("btnLinkVideo").addEventListener("click", (e) => {
      toggleDropdown("linksDropdown");
      insertVideoLink();
    });
    document.getElementById("btnLinkPdf").addEventListener("click", (e) => {
      toggleDropdown("linksDropdown");
      insertPdfLink();
    });

    document.getElementById("btnEmbed").addEventListener("click", (e) => toggleDropdown("embedDropdown"));
    document.getElementById("btnEmbedWeb").addEventListener("click", (e) => {
      toggleDropdown("embedDropdown");
      insertEmbeddedContent();
    });
    document.getElementById("imageUpload").addEventListener("change", (e) => {
      toggleDropdown("embedDropdown");
      insertImage(e);
    });
    document.getElementById("audioUpload").addEventListener("change", (e) => {
      toggleDropdown("embedDropdown");
      insertAudio(event);
    });
    document.getElementById("pdfUpload").addEventListener("change", (e) => {
      toggleDropdown("embedDropdown");
      insertPdf(e);
    });
    document.getElementById("epubUpload").addEventListener("change", (e) => {
      toggleDropdown("embedDropdown");
      insertEpub(e);
    });

    document.getElementById("btnRecordAudio").addEventListener("click", (e) => insertAudioRecording());

    document.getElementById("btnEmbedMath").addEventListener("click", (e) => insertMath());

    document.getElementById("btnTable").addEventListener("click", (e) => toggleDropdown("tableDropdown"));
    document.getElementById("btnSimpleTable").addEventListener("click", (e) => {
      toggleDropdown("tableDropdown");
      insertTable(false);
    });
    document.getElementById("btnHeadlessTable").addEventListener("click", (e) => {
      toggleDropdown("tableDropdown");
      insertTable(true);
    });

    document.getElementById("btnUndo").addEventListener("click", (e) => UNDO_STACK.undo());
    document.getElementById("btnRedo").addEventListener("click", (e) => UNDO_STACK.redo());

    document.getElementById("btnSaveMenu").addEventListener("click", (e) => toggleDropdown("saveDropdown"));
    document.getElementById("btnSave").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(SaveType.DOWNLOAD, true);
    });
    document.getElementById("btnSaveTo").addEventListener("click", async (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(SaveType.FILE, true);
    });
    document.getElementById("btnShare").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(SaveType.SHARE, true);
    });
    document.getElementById("btnSaveReadOnly").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(SaveType.DOWNLOAD, false);
    });
    document.getElementById("btnSaveToReadOnly").addEventListener("click", async (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(SaveType.FILE, false);
    });
    document.getElementById("btnShareReadOnly").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(SaveType.SHARE, false);
    });

    editor.focus();
  </script>

  <script>
    const editor = document.getElementById("editor");

    function editorRemoveChild(childNode, siblingNodeId) {

      if (childNode && editor.contains(childNode)) editor.removeChild(childNode);
    }

    function editorInsertBefore(childNode, siblingNodeId) {

      if (childNode && !editor.contains(childNode)) {

        const siblingNode = siblingNodeId ? document.getElementById(siblingNodeId) : null;
        if (!siblingNode || editor.contains(siblingNode)) editor.insertBefore(childNode, siblingNode);
      }
    }

    function handleXRemoveEvent(event) {

      const parentNode = event.target?.parentNode?.parentNode;

      if (parentNode === editor) {

        const childNode = event.target?.parentNode;
        const childSibling = childNode?.nextElementSibling;
        editor.UNDO_STACK.push(editorRemoveChild, editorInsertBefore,
                               childNode, childSibling?.id);
      }
    }
  </script>

</body>

</html>