<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nash Note</title>
  <link rel="icon" type="image/svg+xml"
    href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%20100%20100%22%3E%0A%20%20%3Crect%20width%3D%22100%22%20height%3D%22100%22%20rx%3D%2220%22%20fill%3D%22black%22%2F%3E%0A%20%20%3Ctext%20x%3D%2250%25%22%20y%3D%2250%25%22%20font-size%3D%2260%22%20font-weight%3D%22bold%22%20text-anchor%3D%22middle%22%20fill%3D%22white%22%20font-family%3D%22Arial%2C%20sans-serif%22%20dominant-baseline%3D%22central%22%3EN.%3C%2Ftext%3E%0A%3C%2Fsvg%3E">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/5.0.375/pdf_viewer.min.css">
  <style> /* pdfjs-viewer.css */
    /*
      Copyright 2020 Carlos de Alfonso (https://github.com/dealfonso)

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    */
    .pdfjs-viewer {
        overflow: auto;
        border: 1px solid #aaa;
        background: #ccc;
        width: 100%;
    }
    .pdfjs-viewer.horizontal-scroll {
        display: flex;
    }
    .pdfjs-viewer.horizontal-scroll .pdfpage {
        margin-left: 1em;
        margin-top: 0.25em !important;
        margin-bottom: 0.25em !important;
        display: block;
    }
    .pdfpage {
        position: relative;
        margin-bottom: 1em;
        margin-top: 1em;
        margin-left: auto;
        margin-right: auto;
        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.1), 0 6px 20px 0 rgba(0, 0, 0, 0.09);
        /* display: flex; */
    }
    .pdfpage canvas {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        width: 100%;
    }
    .pdfpage.placeholder {
        display: flex;
        margin-bottom: 0em !important;
        margin-top: 0em !important;
        height: 100%;
        width: 100%;
    }
    .pdfpage .content-wrapper {
        margin: 0 !important;
        padding: 0 !important;
        display: flex !important;
    }
    .pdfpage .content-wrapper .loader {
        border: 2px solid #f3f3f3;
        border-top: 3px solid #3498db;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        animation: spin 1s linear infinite;
        margin: auto;
    }
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
  </style>
  <style> /* pdftoolbar.css */
    .pdfjs-toolbar {
        width: 100%;
        height: 32px;
        background: #ddd;
        z-index: 100;
        vertical-align: middle;
        display: flex;
        margin: 0;
        padding: 0;
    }
    .pdfjs-toolbar * {
        margin: auto 0;
    }
    .pdfjs-toolbar span {
        margin-right: 0.5em;
        margin-left: 0.5em;
        width: 4em !important;
        font-size: 12px;
    }
    .pdfjs-toolbar button, .pdfjs-toolbar label.button, .pdfjs-toolbar a.button {
        min-width: 26px;
        height: 28px;
        border: none;
        padding: 2px 4px 0;
        margin: auto 1px;
        border-radius: 2px;
        line-height: 12px;
        font-size: 14px;
        background-color: #ddd;
        cursor: pointer;
    }
    .pdfjs-toolbar button i, .pdfjs-toolbar label.button i {
        font-size: 26px;
        padding: 0;
        margin: 0;
    }
    .pdfjs-toolbar button:hover, .pdfjs-toolbar label.button:hover, .pdfjs-toolbar a.button:hover {
        background-color: #ccc;
    }
    button.pushed {
        background-color: #aaa !important;
    }
    .pdfjs-toolbar a.button {
        color: inherit;
    }
    .pdfjs-toolbar .divider {
        flex: 1;
    }
    .pdfjs-toolbar .v-sep {
        width: 0px;
        height: 20px;
        border-left: 1px solid #bbb;
    }
    .pdfjs-toolbar .h-sep {
        width: 100%;
        height: 0px;
        border-top: 1px solid #bbb;
        margin: 0.25em 0;
    }
    .pdfjs-toolbar .dropdown.dropdown-right, .pdfjs-toolbar .dropdown.right {
        float: right
    }
    .pdfjs-toolbar .dropdown.dropdown-right .dropdown-content, .pdfjs-toolbar .dropdown.right .dropdown-content {
        right: 0;
        left: auto;
    }
    .pdfjs-toolbar .dropdown-value {
        background-color: #ccc;
        padding: 0px 4px 2;
        cursor: pointer;
    }
    .pdfjs-toolbar .dropdown-value i {
        width: auto;
        font-size: 12px;
    }        
    /* Dropdown Content (Hidden by Default) */
    .pdfjs-toolbar .dropdown-content {
        display: none;
        position: absolute;
        margin-top: 0;
        background-color: #eee;
        min-width: 10em;
        z-index: 1;
        font-size: 12px;
        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.1), 0 6px 20px 0 rgba(0, 0, 0, 0.09);
    }
    /* Links inside the dropdown */
    .pdfjs-toolbar .dropdown-content a {
        all: initial;
        font: inherit;
        color: black;
        padding: 6px 8px;
        text-decoration: none;
        display: flex;
        cursor: pointer;
    }
    .pdfjs-toolbar .dropdown-content i {
        font-size: 16px;
        padding-right: 0.5em;
    }
    .pdfjs-toolbar .dropdown-content a:hover {
        background-color: #ddd;
    }
    .pdfjs-toolbar .dropdown:hover .dropdown-content, .dropdown .dropdown-content:hover {
        display: block;
    }
  </style>
  <style>
    :root {
      --page-bg-color: #f8f9fa;
      --page-text-color: #333;

      --control-bg-color: #f8f9fa;
      --control-text-color: buttontext;
      --control-hover-bg-color: #f0f0f0;
      --control-hover-text-color: #bbb;

      --note-bg-color: #fff;
      --note-placeholer-color: #bbb;
      --note-link-color: #616161;

      --attribution-color: #bbb;

      --code-bg-color: #e5e4e2;
      --code-text-color: #333;

      /* text background colors */
      --note-text-color-1: #000000;
      /* black */
      --note-text-color-2: #FF3B30;
      /* red */
      --note-text-color-3: #FF9500;
      /* orange */
      --note-text-color-4: #FFCC00;
      /* yellow */
      --note-text-color-5: #4CD964;
      /* green */
      --note-text-color-6: #5AC8FA;
      /* light-blue */
      --note-text-color-7: #007AFF;
      /* dark-blue */
      --note-text-color-8: #5856D6;
      /* violet */

      /* highlight background colors */
      --note-highlight-color-1: #FCECEC;
      /* red */
      --note-highlight-color-2: #FFECEB;
      /* orange */
      --note-highlight-color-3: #FFF8E1;
      /* yellow */
      --note-highlight-color-4: #F1FAE5;
      /* green */
      --note-highlight-color-5: #E6F9F0;
      /* light-blue */
      --note-highlight-color-6: #E8F0FE;
      /* violet */
      --note-highlight-color-7: #E7F0FF;
      /* dark-blue */
      --note-highlight-color-8: #F3E8FF;
      /* purple */
    }

    /* dark mode */
    @media (prefers-color-scheme: dark) {
      :root {
        --page-bg-color: #3a3a3a;
        --page-text-color: #ddd;

        --control-bg-color: #444;
        --control-text-color: #aaa;
        --control-hover-bg-color: #666;
        --control-hover-text-color: #eee;

        --note-bg-color: #333;
        --note-placeholder-color: #555;

        --code-bg-color: #36454f;
        --code-text-color: #fff;

        /*
               TODO: choose nicer colors :-)
            */

        /* text background colors */
        --note-text-color-1: #FAFAFA;
        /* black / white */
        --note-text-color-2: #FF3B30;
        /* red */
        --note-text-color-3: #FF9500;
        /* orange */
        --note-text-color-4: #FFCC00;
        /* yellow */
        --note-text-color-5: #4CD964;
        /* green */
        --note-text-color-6: #5AC8FA;
        /* light-blue */
        --note-text-color-7: #007AFF;
        /* dark-blue */
        --note-text-color-8: #5856D6;
        /* violet */

        /* highlight background colors */
        --note-highlight-color-1: hsl(0 50% 30%);
        /* red */
        --note-highlight-color-2: hsl(30 50% 30%);
        /* orange */
        --note-highlight-color-3: hsl(45 50% 30%);
        /* yellow */
        --note-highlight-color-4: hsl(120 50% 30%);
        /* green */
        --note-highlight-color-5: hsl(240 70% 40%);
        /* light-blue */
        --note-highlight-color-6: hsl(300 70% 40%);
        /* violet */
        --note-highlight-color-7: hsl(240 50% 30%);
        /* dark-blue */
        --note-highlight-color-8: hsl(330 50% 30%);
        /* purple */
      }
    }

    body {
      font-family: 'Arial', sans-serif;
      background-color: var(--page-bg-color);
      color: var(--page-text-color);
      margin: 0;
      padding: 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .editor-container {
      width: 100%;
      max-width: 900px;
      background: var(--note-bg-color);
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0px 5px 15px rgba(0, 0, 0, 0.1);
    }

    .file-title {
      font-size: 28px;
      font-weight: bold;
      margin-bottom: 15px;
      padding: 0px 15px;
      outline: none;
      border: none;
      width: 100%;
      background: transparent;
    }

    .file-title:empty::before {
      content: "Write your title here...";
      color: var(--note-placeholder-color);
      display: block;
    }

    #toolbar {
      position: sticky;
      position: -webkit-sticky;
      gap: 8px;
      top: 5px;
      padding: 0 10px;
      z-index: 9999;
      background-color: var(--control-bg-color);
      border-radius: 12px;
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      align-items: center;
    }

    #toolbar #splitbar {
      margin-left: auto;
    }

    #toolbar input[type="file"] {
      display: none;
    }


    #toolbar button,
    #toolbar label,
    #toolbar select {
      padding: 8px;
      border: none;
      background: none;
      color: var(--control-text-color);
      font-size: 16px;
      cursor: pointer;
      transition: opacity 0.2s
    }

    #toolbar button:hover,
    #toolbar label:hover,
    #toolbar select:hover {
      background: var(--control-hover-bg-color);
      border-color: var(--control-hover-text-color);
      color: var(--control-hover-text-color);
    }

    /* Dropdown container */
    .dropdown {
      position: relative;
      display: inline-block;
    }

    /* Dropdown button style */
    .dropdown>button {
      padding: 6px 10px;
    }

    /* Dropdown content (hidden by default) */
    .dropdown-content {
      display: none;
      position: absolute;
      top: 110%;
      right: 0;
      background: var(--control-bg-color);
      border: 1px solid var(--control-bg-color);
      color: var(--control-text-color);
      padding: 8px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      z-index: 10;
    }

    /* Show dropdown when .show is added */
    .dropdown-content.show {
      display: block;
    }

    /* Grid of swatches */
    .swatch-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, 24px);
      gap: 6px;
    }

    .color-swatch {
      width: 24px;
      height: 24px;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .color-swatch:hover {
      transform: scale(1.1);
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);
    }

    #saveDropdown {
      width: 200px;
    }

    #saveDropdown button {
      width: 100%;
      text-align: left;
    }

    #editor {
      border-radius: 12px;
      padding: 15px;
      min-height: 250px;
      outline: none;
      font-size: 16px;
      line-height: 1.6;
      /* background: #f4f4f4; */
    }

    #editor p {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
    }

    #editor a {
      color: var(--note-link-color);
      text-decoration: none;
      font-weight: 800;
      transition: all 0.2s ease-in-out;
      border-bottom: 2px solid transparent;
    }

    #editor a:hover {
      border-bottom: 2px solid var(--note-link-color);
      color: var(--note-link-color);
    }

    #editor a::before {
      content: "🔗";
    }

    #editor pre code {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
      background: var(--code-bg-color);
      color: var(--code-text-color);
      display: block;
      margin: 0;
      padding: 8px;
      border-radius: 6px;
    }

    #editor:empty::before,
    #editor p:empty::before {
      content: "Write your note here...";
      color: var(--note-placeholder-color);
      display: block;
    }

    #footer {
      text-align: center;
      margin-top: 20px;
      color: var(--attribution-color);
    }

    #footer a {
      text-decoration: none;
      color: var(--attribution-color);
    }

    img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 10px 0;
      border-radius: 12px;
    }

    audio {
      width: 100%;
      display: block;
      margin: 10px 0;
    }

    video {
      width: 100%;
      height: auto;
      display: block;
      margin: 10px 0;
      border-radius: 12px;
    }

    .embedded-content {
      width: 100%;
      height: auto;
      display: block;
      margin: 10px 0;
    }

    .embedded-local-epub {
      width: 100%;
      height: auto;
      display: block;
      margin: 20px 0;
    }

    .embedded-local-pdf {
      width: 100%;
      height: auto;
      display: block;
      margin: 20px 0;
    }

    .thin-line::before {
      content: "";
      display: block;
      width: 100%;
      height: 1px;
      background-color: var(--control-bg-color);
      color: var(--control-text-color);
      margin: 10px 0;
    }

    .embedded-local-epub,
    .embedded-local-pdf,
    .embedded-local-image,
    .embedded-local-audio,
    .image-link,
    .audio-link,
    .video-link {
      display: block;
      position: relative;
    }

    .x-remover {
      background-color: #aaa;
      padding: 5px 9px;
      color: #ff3b30;
      display: none;
      position: absolute;
      top: 0;
      right: 0;
      margin-top: -10px;
      margin-right: -10px;
      font-weight: 700;
      border-radius: 50%;
      border: 1px solid #333;
      text-align: center;
      line-height: 20px;
      font-family: sans-serif;
      cursor: default;
    }

    .embedded-local-image:hover .x-remover,
    .embedded-local-audio:hover .x-remover,
    .image-link:hover .x-remover,
    .audio-link:hover .x-remover,
    .video-link:hover .x-remover,
    .embedded-local-epub:hover .x-remover,
    .embedded-local-pdf:hover .x-remover {
      display: block;
    }

    @media print {
      .no-print {
        display: none !important;
      }

      .editor-container {
        width: 100%;
        max-width: 100%;
        box-shadow: none;
      }
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/5.0.375/pdf.min.mjs" type="module"></script>
  <script type="module">
    let { pdfjsLib } = globalThis;
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/5.0.375/pdf.worker.mjs';
  </script>
</head>

<body>

  <div class="editor-container">
    <div id="filename" contenteditable="plaintext-only" class="file-title"></div>

    <div id="toolbar" class="no-print">
      <button id="btnH1">XL</button>
      <button id="btnH2">L</button>
      <button id="btnM">M</button>
      <button id="btnS">S</button>

      <button id="btnB"><b>B</b></button>
      <button id="btnI"><i>I</i></button>
      <button id="btnU"><u>U</u></button>
      <button id="btnLink">🔗</button>

      <label for="imageUpload">📷</label>
      <input type="file" id="imageUpload" accept="image/*" onclick="this.value = null">

      <button id="btnImageLink"">🖼</button>

      <div class="dropdown">
        <button id="btnTextColorMenu">Color</button>
        <div id="textColorDropdown" class="dropdown-content">
          <div class="swatch-grid">
            <button id="btnTextColor1" class="color-swatch" style="background: var(--note-text-color-1);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextColor2" class="color-swatch" style="background: var(--note-text-color-2);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextColor3" class="color-swatch" style="background: var(--note-text-color-3);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextColor4" class="color-swatch" style="background: var(--note-text-color-4);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextColor5" class="color-swatch" style="background: var(--note-text-color-5);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextColor6" class="color-swatch" style="background: var(--note-text-color-6);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextColor7" class="color-swatch" style="background: var(--note-text-color-7);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextColor8" class="color-swatch" style="background: var(--note-text-color-8);"
              onmousedown="event.preventDefault();"></button>
          </div>
        </div>
      </div>

      <!-- Highlight Color Dropdown -->
      <div class="dropdown">
        <button id="btnTextHighlightMenu">Highlight</button>
        <div id="highlightDropdown" class="dropdown-content">
          <div class="swatch-grid">
            <button id="btnTextHighlight1" class="color-swatch" style="background: var(--note-highlight-color-1);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextHighlight2" class="color-swatch" style="background: var(--note-highlight-color-2);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextHighlight3" class="color-swatch" style="background: var(--note-highlight-color-3);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextHighlight4" class="color-swatch" style="background: var(--note-highlight-color-4);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextHighlight5" class="color-swatch" style="background: var(--note-highlight-color-5);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextHighlight6" class="color-swatch" style="background: var(--note-highlight-color-6);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextHighlight7" class="color-swatch" style="background: var(--note-highlight-color-7);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextHighlight8" class="color-swatch" style="background: var(--note-highlight-color-8);"
              onmousedown="event.preventDefault();"></button>
          </div>
        </div>
      </div>
      <button id="btnText"><b>T</b></button>
      <button id="btnCode">🖥</button>
      <button id="btnEmbedContent">🗂</button>

      <label for="audioUpload">🔈</label>
      <input type="file" id="audioUpload" accept="audio/*" onclick="this.value = null">

      <button id="btnAudioLink">🔊</button>
      <button id="btnVideoLink">📽</button>

      <label for="epubUpload">📖</label>
      <input type="file" id="epubUpload" accept="epub/*" onclick="this.value = null">

      <label for="pdfUpload">📖</label>
      <input type="file" id="pdfUpload" accept="pdf/*" onclick="this.value = null">

      <div id="splitbar">|</div>
      <!-- Block conversion -->
      <div class="dropdown">
        <button id="btnSaveMenu">💾</button>
        <div id="saveDropdown" class="dropdown-content">
          <button id="btnSave">Save</button>
          <button id="btnShare">Share</button>
          <button id="btnSaveReadOnly">Save as Read-Only</button>
          <button id="btnShareReadOnly">Share as Read-Only</button>
        </div>
      </div>

    </div>

    <div id="editorContainer" class="thin-line">
      <div id="editor" contenteditable="true">
        <p class="text-block"></p>
      </div>
    </div>

    <div id="footer">
      <small><a href="https://github.com/flaviup">flaviup@github</a></small>
      <br/>
      <small>Nash 0.1</small>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script -->
  <script src="https://github.com/futurepress/epub.js/releases/download/v0.3.88/epub.min.js"></script> <!-- check newer versions like 0.3.93 -->

  <script type="module">

    /* pdfjs-viewer */

    /*
      Copyright 2020 Carlos de Alfonso (https://github.com/dealfonso)

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.
    */
    'use strict';

    if ($ === undefined) {
        console.error("jQuery-like library not available");
    }

    let defaults = {
        // Threshold to consider that a page is visible
        visibleThreshold: 0.5,
        // Number of extra pages to load (appart from the visible)
        extraPagesToLoad: 3,
        // The class used for each page (the div that wraps the content of the page)
        pageClass: "pdfpage",
        // Prefix of the id used for each page (the page id will be <pageIdPrefix>-<page number>)
        pageIdPrefix: "page",
        // The class used for the content of each page (the div that contains the page)
        contentClass: "content-wrapper",
        // Function called when a document has been loaded and its structure has been created
        onDocumentReady: () => {},
        // Function called when a new page is created (it is bound to the object, and receives a html object as parameter, and the page number)
        onNewPage: (page, i) => {},
        // Function called when a page is rendered (it is bound to the object, and receives a html object as parameter, and the page number)
        onPageRender: (page, i) => {},
        // Posible zoom values to iterate over using "in" and "out"
        zoomValues: [ 0.25, 0.5, 0.75, 1, 1.25, 1.50, 2, 4, 8 ],
        // Function called when the zoom level changes (it receives the zoom level)
        onZoomChange: (zoomlevel) => {},
        // Function called whenever the active page is changed (the active page is the one that is shown in the viewer)
        onActivePageChanged: (page, i) => {},
        // Percentage of the container that will be filled with the page
        zoomFillArea: 0.95,
        // Function called to get the content of an empty page
        emptyContent: () => $ ? $('<div class="loader"></div>') : {},
        // The scale to which the pages are rendered (1.5 is the default value for the PDFjs viewer); a higher value will render the pages with a higher resolution
        //   but it will consume more memory and CPU. A lower value will render the pages with a lower resolution, but they will be uglier.
        renderingScale: 1.5,
    }
    
    // Class used to help in zoom management; probably it can be moved to the main class, but it is used to group methods
    class Zoomer {
        /**
         * Construct the helper class
         * @param {PDFjsViewer} viewer - the viewer object
         * @param {*} options - the options object
         */
        constructor(viewer, options = {}) {
            let defaults = {
                // The possible zoom values to iterate through using "in" and "out"
                zoomValues: [ 0.25, 0.5, 0.75, 1, 1.25, 1.50, 2, 4, 8 ],
                // The area to fill the container with the zoomed pages
                fillArea: 0.9,
            }
    
            // The current zooom value
            this.current = 1;
            // The viewer instance whose pages may be zoomed
            this.viewer = viewer;
            // The settings
            this.settings = Object.assign({}, defaults, options);
            
            // Need having the zoom values in order
            this.settings.zoomValues = this.settings.zoomValues.sort();
        }
    
        /** Translates a zoom value into a float value; possible values:
         * - a float value
         * - a string with a keyword (e.g. "width", "height", "fit", "in", "out")
         * @param {number} zoom - the zoom value to be translated
         * @return {number} The zoom value
        */
        get(zoom = null) {
            // If no zoom is specified, return the current one
            if (zoom === null) {
                return this.current;
            }
            // If it is a number, return it
            if (parseFloat(zoom) == zoom) {
                return zoom;
            } 
            let $activepage = this.viewer.getActivePage();
            let zoomValues = [];
            // If it is a keyword, return the corresponding value
            switch(zoom) {
                case "in":
                    zoom = this.current;
                    zoomValues = this.settings.zoomValues.filter((x) => x > zoom);
                    if (zoomValues.length > 0) {
                        zoom = Math.min(...zoomValues);
                    }
                    break;
                case "out":
                    zoom = this.current;
                    zoomValues = this.settings.zoomValues.filter((x) => x < zoom);
                    if (zoomValues.length > 0) {
                        zoom = Math.max(...zoomValues);
                    }
                    break;
                case "fit":
                    zoom = Math.min(this.get("width"), this.get("height"));
                    break;
                case "width":
                    zoom = this.settings.fillArea * this.viewer.$container.width() / $activepage.data("width");
                    break;
                case "height":
                    zoom = this.settings.fillArea * this.viewer.$container.height() / $activepage.data("height");
                    break;
                default:
                    zoom = this.current;
                    break;
            }
            return zoom;
        }
    
        /**
         * Sets the zoom value to each page (changes both the page and the content div); relies on the data-values for the page
         * @param {number} zoom - the zoom value to be set
         */
        zoomPages(zoom) {
            zoom = this.get(zoom);
            this.viewer.getPages().forEach(function(page) {
                let $page = page.$div;
                let c_width = $page.data("width");
                let c_height = $page.data("height");
    
                $page.width(c_width * zoom).height(c_height * zoom);
                $page.data('zoom', zoom);
                $page.find(`.${this.viewer.settings.contentClass}`).width(c_width * zoom).height(c_height * zoom);
            }.bind(this));
            this.current = zoom;
        }
    }

    class PDFjsViewer {
        // The version of the viewer
        version = "2.0.0";
        
        /**
         * Constructs the object, and initializes actions:
         *   - add the scroll handler to the container
         *   - set the first adjusting action when the page is loaded
         *   - creates the zoom helper
         * @param {jQuery} $container the jQuery value that will hold the pages
         * @param {dictionary} options options for the viewer
         */
        constructor($container, options = {}) {
    
            this.settings = Object.assign({}, defaults, options);
    
            // Create the zoomer helper
            this._zoom = new Zoomer(this, {
                zoomValues: this.settings.zoomValues,
                fillArea: this.settings.zoomFillArea,
            });
    
            $container = $($container);

            // Store the container
            this.$container = $container;
    
            // Add a reference to this object to the container
            $container.get(0)._pdfjsViewer = this;
    
            // Add the event listeners
            this._setScrollListener();

            // Initialize some variables
            this.pages = [];
            this.pdf = null;

            // Whether the document is ready or not
            this._documentReady = false;
        }    
    
        /**
         * Sets the current zoom level and applies it to all the pages
         * @param {number} zoom the desired zoom level, which will be a value (1 equals to 100%), or the keywords 'in', 'out', 'width', 'height' or 'fit'
         */
        setZoom(zoom) {
            let container = this.$container.get(0);

            // Get the previous zoom and scroll position
            let prevzoom = this._zoom.current;
            let prevScroll = {
                top: container.scrollTop,
                left: container.scrollLeft
            };

            // Now zoom the pages
            this._zoom.zoomPages(zoom);

            // Update the scroll position (to match the previous one), according to the new relationship of zoom
            container.scrollLeft = prevScroll.left * this._zoom.current / prevzoom;
            container.scrollTop = prevScroll.top * this._zoom.current / prevzoom;

            // Force to redraw the visible pages to upgrade the resolution
            this._visiblePages(true);

            // Call the callback (if provided)
            if (this._documentReady) {
                if (typeof this.settings.onZoomChange === "function")
                    this.settings.onZoomChange.call(this, this._zoom.current);                
                this.$container.get(0).dispatchEvent(new CustomEvent("zoomchange", { detail: { zoom: this._zoom.current } }));
            }

            return this._zoom.current;
        }
    
        /**
         * Obtain the current zoom level
         * @returns {number} the current zoom level
         */
        getZoom() {
            return this._zoom.current;
        }
    
        /**
         * Function that removes the content of a page and replaces it with the empty content (i.e. a content generated by function emptyContent)
         *   such content will not be visible except for the time that the 
         * @param {jQuery} $page the page to be emptied
         */
        _cleanPage($page) {
            let $emptyContent = this.settings.emptyContent();
            $page.find(`.${this.settings.contentClass}`).html("").append($emptyContent)
        }
    
        /**
         * Function that replaces the content with the empty class in a page with a new content
         * @param {*} $page the page to be modified
         * @param {*} $content the new content that will be set in the page
         */
        _setPageContent($page, $content) {
            $page.find(`.${this.settings.contentClass}`).html("").append($content)
        }

        /**
         *  Recalculates which pages are now visible and forces redrawing them (moreover it cleans those not visible) 
        */
        refreshAll() {
            this._visiblePages(true);
        }
    
        /** Function that creates a scroll handler to update the active page and to load more pages as the scroll position changes */
        _setScrollListener() {
            // Create a scroll handler that prevents reentrance if called multiple times and the loading of pages is not finished
            let scrollLock = false;
            let scrollPos = { top:0 , left:0 };
            this.__scrollHandler = function(e) {
                // Avoid re-entrance for the same event while loading pages
                if (scrollLock === true) {
                    return;
                }
                scrollLock = true;
    
                let container = this.$container.get(0);
                if ((Math.abs(container.scrollTop - scrollPos.top) > (container.clientHeight * 0.2 * this._zoom.current)) ||
                    (Math.abs(container.scrollLeft - scrollPos.left) > (container.clientWidth * 0.2 * this._zoom.current))) {
                    scrollPos = {
                        top: container.scrollTop,
                        left: container.scrollLeft
                    }
                    this._visiblePages();
                }
    
                scrollLock = false;
            }.bind(this);
    
            // Set the scroll handler
            this.$container.off('scroll');
            this.$container.on('scroll', this.__scrollHandler);            
        }    
        /**
         * Function that creates the pageinfo structure for one page, along with the skeleton to host the page (i.e. <div class="page"><div class="content-wrapper"></div></div>)
         *   If the page is a pageinfo, the new pageinfo structure will not rely on the size (it will copy it, but it won't be marked as loaded). If it is a page, the size will
         *   be calculated from the viewport and it will be marked as loaded.
         *   This is done in this way, because when creating the pages in the first time, they will be created assuming that they are of the same size than the first one. If they
         *   are not, the size will be adjusted later, when the pages are loaded.
         * 
         * @param {*} page - the pageinfo (or the page) from which to create the pageinfo structure
         * @param {*} i - the number of the page to be created
         * @returns pageinfo - the pageinfo structure for the page
         */
        _createSkeleton(page, i) {
            let pageinfo = {
                $div: null,
                width: 0,
                height: 0,
                loaded: false,
            };
    
            // If it is a page, the size will be obtained from the viewport; otherwise, it will be copied from the provided pageinfo
            if (page.getViewport !== undefined) {
                let viewport = page.getViewport({rotation:this._rotation,scale:1});
                pageinfo.width = viewport.width;
                pageinfo.height = viewport.height;
                pageinfo.loaded = true;
            } else {
                pageinfo.width = page.width;
                pageinfo.height = page.height;
            }
            console.assert(((pageinfo.width > 0) && (pageinfo.height > 0)), "Page width and height must be greater than 0");
    
            // Now create the skeleton for the divs
            pageinfo.$div = $(`<div id="${this.settings.pageIdPrefix}-${i}">`)
                .attr('data-page', i)
                .data('width', pageinfo.width)
                .data('height', pageinfo.height)
                .data('zoom', this._zoom.current)
                .addClass(this.settings.pageClass)
                .width(pageinfo.width * this._zoom.current)
                .height(pageinfo.height * this._zoom.current);
                
            let $content = $(`<div class="${this.settings.contentClass}">`)
                .width(pageinfo.width)
                .height(pageinfo.height);

            pageinfo.$div.append($content);
            
            // Clean the page (i.e. put the empty content, etc.)
            this._cleanPage(pageinfo.$div);
            
            return pageinfo;
        }
    
        /**
         * This function places the page.$div in the container, according to its page number (i.e. it searches for the previous page and puts this page after)
         *   * in principle, this method sould not be needed because all the pages are put in order; but this is created just in case it is needed in further versions
         * @param {*} pageinfo - the pageinfo structure for the page (needs a valid $div)
         * @param {*} i - the number of the page
         */
        _placeSkeleton(pageinfo, i) {
            let prevpage = i - 1;
            let $prevpage = null;
            while ((prevpage>0) && (($prevpage = this.$container.find(`.${this.settings.pageClass}[data-page="${prevpage}"]`)).length === 0)) {
                prevpage--;
            }
            if (prevpage === 0) {
                this.$container.append(pageinfo.$div);
            }
            else {
                $prevpage.after(pageinfo.$div);
            }
        }
    
        /**
         * Creates the initial skeletons for all the pages, and places them into the container
         * @param {page/pageinfo} pageinfo - the initial pageinfo (or page) structure
         */
        _createSkeletons(pageinfo) {
            for (let i = 1; i <= this.pageCount; i++) {
                if (this.pages[i] === undefined) {

                    // Create the pageinfo structure, store it and place it in the appropriate place (the next page will be created similar to the previous one)
                    pageinfo = this._createSkeleton(pageinfo, i);
                    this.pages[i] = pageinfo;
                    this._placeSkeleton(pageinfo, i);

                    // Call the callback function (if provided)
                    if (typeof this.settings.onNewPage === "function") {
                        this.settings.onNewPage.call(this, pageinfo.$div.get(0), i);
                    }
                    this.$container.get(0).dispatchEvent(new CustomEvent("newpage", { detail: { pageNumber: i, page: pageinfo.$div.get(0) } }));
                }
            }
        }
    
        /**
         * Function to set the active page, and calling the callback (if provided)
         * @param {*} i - the number of the page to set active
         */
        _setActivePage(i) {
            if (this._activePage !== i) {
                this._activePage = i;
                let activePage = this.getActivePage();
                if (this._documentReady) {
                    activePage = activePage==null?null:activePage.get(0);
                    if (typeof this.settings.onActivePageChanged === "function") {
                        this.settings.onActivePageChanged.call(this, activePage, i);
                    }
                    this.$container.get(0).dispatchEvent(new CustomEvent("activepagechanged", { detail: { activePageNumber: i, activePage: activePage } }));
                }
            }
        }
    
        /**
         * Obtains the area of a div that falls in the viewer
         * @param {*} $page - div whose area is to be calculated
         * @returns the visible area
         */
        _areaOfPageVisible($page) {
            if ($page === undefined) {
                return 0;
            }
            let c_offset = this.$container.offset();
            let c_width = this.$container.width();
            let c_height = this.$container.height();
            let position = $page.offset();
            position.top -= c_offset.top;
            position.left -= c_offset.left;
            position.bottom = position.top + $page.outerHeight();
            position.right = position.left + $page.outerWidth();
            let page_y0 = Math.min(Math.max(position.top, 0), c_height);
            let page_y1 = Math.min(Math.max($page.outerHeight() + position.top, 0), c_height);
            let page_x0 = Math.min(Math.max(position.left, 0), c_width);
            let page_x1 = Math.min(Math.max($page.outerWidth() + position.left, 0), c_width);
            let vis_x = page_x1 - page_x0;
            let vis_y = page_y1 - page_y0;
            return (vis_x * vis_y);
        }

        /**
         * Function that returns true if the page is considered to be visible (the amount of visible area is greater than the threshold)
         * @param {*} i - the number of page to check
         * @returns true if the page is visible
         */
        isPageVisible(i) {
            if ((this.pdf === null) || (i === undefined) || (i === null) || (i < 1) || (i > this.pdf.numPages)) {
                return false;
            }
            if (typeof i === "string") {
                i = parseInt(i);
            }
            let $page = i;
            if (typeof i === "number") {
                if (this.pages[i] === undefined)
                    return false;
                $page = this.pages[i].$div;
            }
            return this._areaOfPageVisible($page) > ($page.outerWidth() * $page.outerHeight() * this.settings.visibleThreshold);
        }

        /**
         * Function that calculates which pages are visible in the viewer, draws them (if not already drawn), and clears those not visible
         * @param {*} forceRedraw - if true, the visible pages will be redrawn regardless of whether they are already drawn (useful for zoom changes)
         */
        _visiblePages(forceRedraw = false) {    
            // Will grab the page with the greater visible area to set it as active
            let max_area = 0;
            let i_page = null;
    
            // If there are no visible pages, return
            if (this.pages.length === 0) {
                this._visibles = [];
                this._setActivePage(0);
                return;
            }

            // Calculate the visible area for each page and consider it visible if the visible area is greater than 0
            let $visibles = this.pages.filter(function(pageinfo) {
                let areaVisible = this._areaOfPageVisible(pageinfo.$div);
                if (areaVisible > max_area) {
                    max_area = areaVisible;
                    i_page = pageinfo.$div.data('page');
                }
                return areaVisible > 0;
            }.bind(this)).map((x) => x.$div);
    
            // Set the active page
            this._setActivePage(i_page);
    
            // Now get the visible pages
            let visibles = $visibles.map((x) => {
                return parseInt($(x).data('page'))
            });
            if (visibles.length > 0) {
                // Now will add some extra pages (before and after) the visible ones, to have them prepared in case of scroll
                let minVisible = Math.min(...visibles);
                let maxVisible = Math.max(...visibles);

                for (let i = Math.max(1, minVisible - this.settings.extraPagesToLoad) ; i < minVisible ; i++) {
                    if (!visibles.includes(i)) 
                        visibles.push(i)
                }
                for (let i = maxVisible + 1; i <= Math.min(maxVisible + this.settings.extraPagesToLoad, this.pdf.numPages); i++) {
                    if (!visibles.includes(i)) 
                        visibles.push(i)
                }
            }
    
            // Now will draw the visible pages, but if not forcing, will only draw those that were not visible before
            let nowVisibles = visibles;
            if (! forceRedraw) {
                nowVisibles = visibles.filter(function (x) { 
                    return !this._visibles.includes(x) 
                }.bind(this));
            }
    
            // Get the pages that were visible before, that are not visible now, and clear them
            this._visibles.filter(function (x) { 
                return !visibles.includes(x) 
            }).forEach(function (i) {
                this._cleanPage(this.pages[i].$div);
            }.bind(this))
    
            // Store the new visible pages
            this._visibles = visibles;
    
            // And now we'll queue the pages to load
            this.loadPages(...nowVisibles);
        }

        /**
         * Function queue a set of pages to be loaded; if not loading, the function starts the loading worker
         * @param  {...pageinfo} pages - the pages to load
         */
        loadPages(...pages) {
            this._pagesLoading.push(...pages);
            if (this._loading) {
                return;
            }
            this._loadingTask();
        }

        /**
         * Function that gets the pages pending to load and renders them sequentially (to avoid multiple rendering promises)
         */
        _loadingTask() {
            this._loading = true;
            if (this._pagesLoading.length > 0) {
                let pagei = this._pagesLoading.shift();                
                this.pdf.getPage(pagei).then(function(page) {
                    // Render the page and update the information about the page with the loaded values
                    this._renderPage(page, pagei);
                }.bind(this)).then(function(pageinfo) {
                    // Once loaded, we are not loading anymore
                    if (this._pagesLoading.length > 0) {
                        this._loadingTask();
                    }
                }.bind(this));
            }
            // Free the loading state
            this._loading = false;
        }        
    
        /**
         * Function that sets the scroll position of the container to the specified page
         * @param {*} i - the number of the page to set the scroll position
         */
        scrollToPage(i) {
            if ((this.pages.length === 0) || (this.pages[i] === undefined)) {
                return;
            }
            let $page = this.pages[i].$div;
            if ($page.length === 0) {
                console.warn(`Page ${i} not found`);
                return;
            }
            let position = $page.position();
            let containerPosition = this.$container.position();
            if (position !== undefined) {
                this.$container.get(0).scrollTop = this.$container.get(0).scrollTop + position.top - containerPosition.top;
                this.$container.get(0).scrollLeft = this.$container.get(0).scrollLeft + position.left - containerPosition.left;
            }
            this._setActivePage(i);
        }

        /**
         * Function that renders the page in a canvas, and sets the canvas into the $div
         * @param {*} page - the page to be rendered
         * @param {*} i - the number of the page to be rendered
         * @returns a promise to render the page (the result of the promise will be the pageinfo)
         */
        _renderPage(page, i) {
            // Get the pageinfo structure
            let pageinfo = this.pages[i];
            let scale = this.settings.renderingScale;
    
            // Calculate the pixel ratio of the device (we'll use a minimum of 1)
            let pixel_ratio = window.devicePixelRatio || 1;
            // Update the information that we know about the page to the actually loaded page
            let viewport = page.getViewport({rotation: this._rotation, scale: this._zoom.current * scale});
            pageinfo.width = (viewport.width / this._zoom.current) / scale;
            pageinfo.height = (viewport.height / this._zoom.current) / scale;
            pageinfo.$div.data("width", pageinfo.width);
            pageinfo.$div.data("height", pageinfo.height);
            pageinfo.$div.width(pageinfo.width * this._zoom.current);
            pageinfo.$div.height(pageinfo.height * this._zoom.current);
            pageinfo.loaded = true;
    
            // Create the canvas and prepare the rendering context
            let $canvas = $('<canvas></canvas>');
            let canvas = $canvas.get(0);
            let context = canvas.getContext('2d');
            canvas.height = viewport.height * pixel_ratio;
            canvas.width = viewport.width * pixel_ratio;
            canvas.getContext("2d")//.scale(pixel_ratio, pixel_ratio);
            var transform = pixel_ratio !== 1
                ? [pixel_ratio, 0, 0, pixel_ratio, 0, 0]
                : null;
            var renderContext = {
                canvasContext: context,
                viewport: viewport,
                transform: transform,
            };
    
            // Render the page and put the resulting rendered canvas into the page $div
            return page.render(renderContext).promise.then(function() {
                this._setPageContent(pageinfo.$div, $canvas);

                // Call the callback (if provided)
                if (this._documentReady) {
                    if (typeof this.settings.onPageRender === "function") {
                        this.settings.onPageRender.call(this, pageinfo.$div.get(0), i);
                    }
                    this.$container.get(0).dispatchEvent(new CustomEvent("pagerender", { detail: { pageNumber: i, page: pageinfo.$div.get(0) } }));
                }
                return pageinfo;
            }.bind(this));
        }
    
        /** Gets the div object corresponding to the active page */
        getActivePage() {
            if ((this._activePage === null) || (this.pdf === null)) {
                return null;
            }
            if ((this._activePage < 1) || (this._activePage > this.pdf.numPages)) {
                return null;
            }
            return this.pages[this._activePage].$div;
        }
    
        /** Gets all the pages of the document (the pageinfo structures) */
        getPages() {
            return this.pages;
        }
    
        /** Gets the number of pages of the document */
        getPageCount() {
            if (this.pdf === null) {
                return 0;
            }
            return this.pdf.numPages;
        }

        /** Scrolls to the next page (if any) */ 
        next() {
            if (this._activePage < this.pdf.numPages) {
                this.scrollToPage(this._activePage + 1);
            }
        }
    
        /** Scrolls to the previous page (if any) */
        prev() {
            if (this._activePage > 1) {
                this.scrollToPage(this._activePage - 1);
            }
        }

        first() {
            if (this._activePage !== 1) {
                this.scrollToPage(1);
            }
        }
    
        last() {
            if (this.pdf === null)
                return;
            if (this._activePage !== this.pdf.numPages) {
                this.scrollToPage(this.pdf.numPages);
            }
        }
        /**
         * Rotates the pages of the document
         * @param {*} deg - degrees to rotate the pages
         * @param {*} accumulate - whether the rotation is accumulated or not
         */
        rotate(deg, accumulate = false) {
            if (accumulate) {
                deg = deg + this._rotation;
            }
            this._rotation = deg;

            let container = this.$container.get(0);
            let prevScroll = {
                top: container.scrollTop,
                left: container.scrollLeft,
                height: container.scrollHeight,
                width: container.scrollWidth
            };

            return this.forceViewerInitialization().then(function() {
                let newScroll = {
                    top: container.scrollTop,
                    left: container.scrollLeft,
                    height: container.scrollHeight,
                    width: container.scrollWidth
                };
                container.scrollTop = prevScroll.top * (newScroll.height / prevScroll.height);
                container.scrollLeft = prevScroll.left * (newScroll.width / prevScroll.width);
            }.bind(this));
        }
        /**
         * This functions forces the creation of the whole content of the viewer (i.e. new divs, structures, etc.). It is usefull for full refresh of the viewer (e.g. when changes
         *   the rotation of the pages)
         * @returns a promise that is resolved when the viewer is fully initialized
         */
        forceViewerInitialization() {
            // Store the pdf file
            // Now prepare a placeholder for the pages
            this.pages = [];
    
            // Remove all the pages
            this.$container.find(`.${this.settings.pageClass}`).remove();

            this._pagesLoading = [];
            this._loading = false;
            this._visibles = [];
            this._activePage = null;
            return this.pdf.getPage(1).then(function(page) {
                this._createSkeletons(page);
                this._visiblePages();
                this._setActivePage(1);
            }.bind(this));
        }
        /** 
         * Loads the document and creates the pages
         * @param {string} document - the url of the document to load
         */
        async loadDocument(document) {
            // The document is not ready while loading
            this._documentReady = false;

            // Now prepare a placeholder for the pages
            this.pages = [];
    
            // Remove all the pages
            this.$container.find(`.${this.settings.pageClass}`).remove();
    
            // Let's free the pdf file (if there was one before), and rely on the garbage collector to free the memory
            this.pdf = null;

            // Load the task and return the promise to load the document
            let loadingTask = pdfjsLib.getDocument(document);
            return loadingTask.promise.then(function(pdf) {
                // Store the pdf file and get the 
                this.pdf = pdf;
                this.pageCount = pdf.numPages;
                this._rotation = 0;
                return this.forceViewerInitialization();
            }.bind(this)).then(function() {
                if (typeof this.settings.onDocumentReady === "function") {
                    this.settings.onDocumentReady.call(this);
                }
                this.$container.get(0).dispatchEvent(new CustomEvent("documentready", { detail: { document: this.pdf } }));

                // This is a trick to force active page changed event triggering after the document is ready
                this._setActivePage(0)
                this._documentReady = true;
                this._setActivePage(1)
            }.bind(this));
        }
    }

    function recoverAttributes(target, attributeDefaults) {
        const camelcaseToSnakecase = str => str.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`);
        let $target = $(target);
        let result = {};
        if ($target.length > 0) {
            $target = $($target[0]);
            for (let originalAttributeName in attributeDefaults) {
                let attributeName = camelcaseToSnakecase(originalAttributeName)
                let attributeValue = $target.attr(attributeName);
                if (attributeValue != null) {
                    switch (typeof(attributeDefaults[originalAttributeName])) {
                        case 'float':
                            try {
                                attributeValue = parseFloat(attributeValue);
                            } catch (_) {
                            }
                            break;
                        case 'number':
                            try {
                                attributeValue = parseInt(attributeValue);
                            } catch (_) {
                            }
                            break;
                        case 'function':
                            let functionString = attributeValue;
                            attributeValue = function() { eval(functionString); }.bind(target[0]); break;
                        default:
                            break;
                    }
                    result[originalAttributeName] = attributeValue;
                }
            };
        }
        return result;
    }

    function init(element) {
        let options = recoverAttributes(element, Object.assign({
            pdfDocument: "", initialZoom: ""
        }, defaults));
        if (options["pdfDocument"] != null) {
            let pdfViewer = new PDFjsViewer($(element), options);
            pdfViewer.loadDocument(options["pdfDocument"]).then(function() {
                if (options["initialZoom"] != null) {
                    pdfViewer.setZoom(options["initialZoom"]);
                }
            })
            element.get(0).pdfViewer = pdfViewer;
        }
    }

    if ($ !== undefined) {
      $('.pdfjs-viewer').each(function() {
        let $viewer = $(this);
        init($viewer);
      });
    }

    /* END OF pdfjs-viewer */

    const NON_STYLABLE_NODE_NAMES = ["CODE", "IFRAME"];

    function setEditMode(editMode) {
      let editor = document.getElementById("editor");
      let toolbar = document.getElementById("toolbar");
      let filename = document.getElementById("filename");

      if (editMode) {
        editor.contentEditable = "true";
        filename.contentEditable = "plaintext-only";
        toolbar.style.display = "flex";
      }
      else {
        editor.contentEditable = "false";
        filename.contentEditable = "false";
        toolbar.style.display = "none";
      }
    }

    function removeDocumentNodes(html) {

      const template = document.createElement('template');
      template.innerHTML = html;

      template.content.querySelectorAll('.embedded-local-epub').forEach(el => {
        el.replaceChildren();
      });

      template.content.querySelectorAll('.embedded-local-pdf').forEach(el => {
        el.replaceChildren();
      });

      return template.innerHTML;
    }

    async function exportToFile(save, editMode) {
      let filename = document.getElementById("filename").innerText.trim();
      if (!filename) {
        alert("title is empty!");
        return;
      }

      filename = filename.endsWith(".html") ? filename : filename + ".html";

      if (editMode === false) {
        setEditMode(false);
      }

      let content = removeDocumentNodes(document.documentElement.outerHTML);
      let blob = new Blob(["<!DOCTYPE html>\n" + content], { type: "text/html" });
      let file = new File([blob], filename, { type: "text/html" });

      if (editMode === false) {
        setEditMode(true);
      }

      if (save == false && navigator.canShare && navigator.canShare({ files: [file] })) {
        try {
          await navigator.share({
            files: [file],
            title: filename,
            text: ""
          });
        } catch (error) {
          console.error("share failed:", error);
        }
      } else {
        let a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
        URL.revokeObjectURL(a.href);
      }
    }

    function getTopLevelNodeOfCurrentPosition(useSelectionRange = null) {

      let topNode = null;
      let range = useSelectionRange;

      if (!range) {

        let selection = window.getSelection();

        if (selection?.rangeCount) {
          range = selection.getRangeAt(0);
        }
      }

      if (range) {

        let block = range.startContainer;

        if (block && block !== editor) {

          while (block.parentNode && block.parentNode !== editor) {
            block = block.parentNode;
          }

          if (block.parentNode === editor) {
            topNode = block;
          }
        }
      }

      return topNode;
    }

    function createRemover(callback = null) {

      const divNode = document.createElement("div");
      divNode.innerText = "✕";
      divNode.addEventListener('click', function (e) {

        const parentNode = e.target?.parentNode;

        if (parentNode?.parentNode) {

          parentNode.parentNode.removeChild(parentNode);

          if (callback) {
            callback();
          }
        }
      }, false);
      divNode.setAttribute("class", "x-remover");
      divNode.setAttribute("contenteditable", "false");
      return divNode;
    }

    function insertImage(event) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextSibling;
        reader.onload = function (e) {
          const divNode = document.createElement("div");
          const img = document.createElement("img");
          img.src = e.target.result;
          divNode.appendChild(img);
          divNode.appendChild(createRemover());
          divNode.setAttribute("class", "embedded-local-image");
          divNode.setAttribute("contenteditable", "false");
          editor.insertBefore(divNode, nextSibling);
        };
        reader.readAsDataURL(file);
      }
    }

    function insertImageLink() {

      const url = prompt("Image URL")?.trim();
      if (!url) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");
      const img = document.createElement("img");
      img.src = `${url}`;
      divNode.appendChild(img);
      divNode.appendChild(createRemover());
      divNode.setAttribute("class", "image-link");
      divNode.setAttribute("contenteditable", "false");
      editor.insertBefore(divNode, nextSibling);
    }

    function insertAudio(event) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextSibling;
        reader.onload = function (e) {
          const divNode = document.createElement("div");
          const audio = document.createElement("audio");
          audio.src = e.target.result;
          audio.setAttribute("controls", "");
          divNode.appendChild(audio);
          divNode.appendChild(createRemover());
          divNode.setAttribute("class", "embedded-local-audio");
          divNode.setAttribute("contenteditable", "false");
          editor.insertBefore(divNode, nextSibling);
        };
        reader.readAsDataURL(file);
      }
    }

    function insertAudioLink() {

      const url = prompt("Audio URL")?.trim();
      if (!url) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");
      const audio = document.createElement("audio");
      audio.src = `${url}`;
      audio.setAttribute("controls", "");
      divNode.appendChild(audio);
      divNode.appendChild(createRemover());
      divNode.setAttribute("class", "audio-link");
      divNode.setAttribute("contenteditable", "false");
      editor.insertBefore(divNode, nextSibling);
    }

    function insertVideoLink() {

      const url = prompt("Video URL")?.trim();
      if (!url) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");
      const video = document.createElement("video");
      video.src = `${url}`;
      video.setAttribute("controls", "");
      divNode.appendChild(video);
      divNode.appendChild(createRemover());
      divNode.setAttribute("class", "video-link");
      divNode.setAttribute("contenteditable", "false");
      editor.insertBefore(divNode, nextSibling);
    }

    function generateUId() {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }
      return s4() + s4() + s4() + s4() +
             s4() + s4() + s4() + s4();
    }

    function loadAllReferencedDocuments() {

      document.querySelectorAll('.embedded-local-epub').forEach(async el => {
        const dataUrl = el.getAttribute("data-epub");
        await loadEpub(dataUrl, null, el);
      });

      document.querySelectorAll('.embedded-local-pdf').forEach(async el => {
        const dataUrl = el.getAttribute("data-pdf");
        await loadPdf(dataUrl, null, el);
      });
    }

    function insertEpub(event, element = null) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextSibling;
        reader.onload = async function (e) {
          await loadEpub(e.target?.result, nextSibling);
        }
        reader.readAsDataURL(file);
      }
    }

    async function loadEpub(epubData, nextSibling, element = null) {

      if (epubData) {

        let book = null;

        try {
          //book = ePub(epubData, { openAs: "base64" }); // BUG: not working
          book = ePub(await (await window.fetch(epubData)).blob());
        } catch (error) { // we allow ePub loading only if epub library is available and the data could be loaded
          console.log(error);
          return;
        }

        const epubId = generateUId();
        const strEpubId = `epub${epubId}`;
        const strTocId = `toc${epubId}`;

        const navButtons = document.createElement("div");
        navButtons.style = "float: top; display: flow-root;";
        navButtons.setAttribute("contenteditable", "false");
        const prev = document.createElement("div");
        const next = document.createElement("div");
        prev.setAttribute("id", `prev${epubId}`);
        next.setAttribute("id", `next${epubId}`);
        prev.textContent = "<PREV";
        next.textContent = "NEXT>";
        prev.style = "float: left; left: 0; margin: 5px 5px; cursor: default;\
                      user-select: none;\
                      -webkit-user-select: none;\
                      -ms-user-select: none;\
                      -webkit-touch-callout: none;\
                      -o-user-select: none;\
                      -moz-user-select: none;";
        next.style = "float: right; right: 0; margin: 5px 5px; cursor: default;\
                      user-select: none;\
                      -webkit-user-select: none;\
                      -ms-user-select: none;\
                      -webkit-touch-callout: none;\
                      -o-user-select: none;\
                      -moz-user-select: none;";
        prev.setAttribute("contenteditable", "false");
        next.setAttribute("contenteditable", "false");
        navButtons.appendChild(prev);
        navButtons.appendChild(next);

        element?.replaceChildren();
        const divNode = element || document.createElement("div");
        const selectToc = document.createElement("select");
        const divEbook = document.createElement("div");
        divEbook.style = "flex: top;";
        divEbook.setAttribute("class", "ebook-content");
        divEbook.setAttribute("id", strEpubId);
        selectToc.style = "float: top; left: 0; margin: 5px 5px; background: inherit; color: inherit;";
        selectToc.setAttribute("id", strTocId);
        divNode.appendChild(selectToc);

        divNode.appendChild(navButtons);

        divNode.appendChild(divEbook);
        divEbook.book = book;
        divNode.appendChild(createRemover(function() { book.destroy(); }));
        divNode.setAttribute("class", "embedded-local-epub");
        divNode.setAttribute("contenteditable", "false");
        divNode.setAttribute("data-epub", epubData);
        if (!element) editor.insertBefore(divNode, nextSibling);

        const rendition = book.renderTo(strEpubId, { flow: "scrolled",
                                                     width: "100%", height: 600, replacements: "base64" /*, allowScriptedContent: true*/ });

        const keyListener = function(e) {

          // Left Key
          if ((e.keyCode || e.which) == 37) {
            rendition?.prev();
          }

          // Right Key
          if ((e.keyCode || e.which) == 39) {
            rendition?.next();
          }
        };
        rendition?.on("keyup", keyListener);
        document.addEventListener("keyup", keyListener, false);

        prev.addEventListener("click", function(e){
          rendition?.prev();
          e.preventDefault();
        }, false);

        next.addEventListener("click", function(e){
          rendition?.next();
          e.preventDefault();
        }, false);

        const displayed = rendition?.display();
        book.loaded.navigation.then(function(toc) {

          const docfrag = document.createDocumentFragment();

          toc.forEach(function(chapter) {

            const option = document.createElement("option");
            option.textContent = chapter.label;
            option.setAttribute("ref", chapter.href);

            docfrag.appendChild(option);
          });
          selectToc.appendChild(docfrag);
          selectToc.onchange = function() {

              const index = selectToc.selectedIndex,
                    url = selectToc.options[index].getAttribute("ref");
              rendition?.display(url);

              return false;
          };
        });
        function navigatedTo(href) {

          let result = false;

          if (href) {

            const selectToc = document.getElementById(strTocId);
            const selectedOption = selectToc.querySelector("option[selected]");

            if (selectedOption) {
              selectedOption.removeAttribute("selected");
            }
            const allOptions = selectToc.querySelectorAll("option");

            for (let i = 0; i < allOptions.length; ++i) {

              let selected = allOptions[i].getAttribute("ref") === href;

              if (selected) {
                allOptions[i].setAttribute("selected", "true");
                selectToc.selectedIndex = i;
                result = true;
              }
            }
          }

          return result;
        }
        rendition?.on("rendered", function(section) {

          const current = book.navigation && book.navigation.get(section.href);
          navigatedTo(current?.href);
        });
        rendition?.on("relocated", function(location) {

          let current = book.navigation.get(location.start?.href);

          while (current?.parent) {
            current = book.navigation.get(current.parent);
          }
          navigatedTo(current?.href);
        });
      }
    }

    function insertPdf(event, element = null) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextSibling;
        reader.onload = async function (e) {
          await loadPdf(e.target?.result, nextSibling);
        }
        reader.readAsDataURL(file);
      }
    }

    async function loadPdf(pdfData, nextSibling, element = null) {

      if (pdfData) {

        element?.replaceChildren();
        const divNode = element || document.createElement("div");
        divNode.appendChild(createRemover());
        divNode.setAttribute("class", "embedded-local-pdf");
        divNode.setAttribute("contenteditable", "false");
        divNode.setAttribute("data-pdf", pdfData);

        divNode.innerHTML = `
            <div class="pdfjs-toolbar">
                <div>
                    <button id="btnFirst">FIRST</button>
                    <button id="btnPrev">&lt;PREV</button>
                    <span class="pageno"></span>
                    <button id="btnNext">NEXT&gt;</button>
                    <button id="btnLast">LAST</button>
                </div>
                <div>
                    <button id="bntZoomOut"><b>-</b></button>
                    <span id="zoomval"><b>100%</b></span>
                    <button id="bntZoomIn"><b>+</b></button>
                    <button id="bntZoomWidth">SWAP HORIZ</button>
                    <button id="bntZoomHeight">SWAP VERT</button>
                    <button id="bntZoomFit">FIT</button>
                </div>
            </div>
            <div id="pdfView" class="pdfjs-viewer">
            </div>`;

        let strPdfId = divNode.getAttribute("id");

        if (!strPdfId) {

          const pdfId = generateUId();
          strPdfId = `pdf${pdfId}`;
          divNode.setAttribute("id", strPdfId);
        }

        if (!element) editor.insertBefore(divNode, nextSibling);

        try {

          const pdfView = divNode.querySelector(`#${strPdfId} #pdfView`);
          const pdfViewer = new PDFjsViewer(pdfView);
          pdfViewer.loadDocument(pdfData).then(function() {
              pdfViewer.setZoom("fit");
              divNode.pdfViewer = pdfViewer;

              divNode.querySelector("#btnFirst")?.addEventListener("click", (e) => pdfViewer.first());
              divNode.querySelector("#btnPrev")?.addEventListener("click", (e) => {
                pdfViewer.prev();
                return false;
              });
              divNode.querySelector("#btnNext")?.addEventListener("click", (e) => {
                pdfViewer.next();
                return false;
              });
              divNode.querySelector("#btnLast")?.addEventListener("click", (e) => pdfViewer.last());

              divNode.querySelector("#btnZoomOut")?.addEventListener("click", (e) => pdfViewer.setZoom("out"));
              divNode.querySelector("#btnZoomIn")?.addEventListener("click", (e) => pdfViewer.setZoom("in"));
              divNode.querySelector("#btnZoomWidth")?.addEventListener("click", (e) => pdfViewer.setZoom("width"));
              divNode.querySelector("#btnZoomHeight")?.addEventListener("click", (e) => pdfViewer.setZoom("height"));
              divNode.querySelector("#btnZoomFit")?.addEventListener("click", (e) => pdfViewer.setZoom("fit"));
          });
        } catch (e) {
          console.log(e);
          if (!element) editor.removeChild(divNode);
        }
      }
    }

    function insertText() {

      const topNode = getTopLevelNodeOfCurrentPosition();
      const p = document.createElement("p");
      p.setAttribute("class", "text-block");
      p.appendChild(document.createElement("br"));
      editor.insertBefore(p, topNode?.nextSibling);
      setCaret(p, 0);
    }

    function insertCode() {

      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");
      const pre = document.createElement("pre");
      const code = document.createElement("code");
      code.setAttribute("contenteditable", "plaintext-only");
      code.style = "white-space: pre;"
      code.innerText = "\n";
      pre.appendChild(code);
      divNode.appendChild(pre);
      divNode.setAttribute("class", "code-block");
      divNode.setAttribute("contenteditable", "true");
      editor.insertBefore(divNode, nextSibling);
      setCaret(code, 0);
    }

    function insertEmbeddedContent() {

      const iframeHtml = prompt("Embedded Page (iframe or URL)")?.trim();
      if (!iframeHtml) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");

      if (iframeHtml.length < "<IFRAME".length || !iframeHtml.toUpperCase().startsWith("<IFRAME")) {
        divNode.innerHTML = `<iframe src="${iframeHtml}" allow="fullscreen" width="100%" height="400"></iframe>`;
      } else {
        divNode.innerHTML = `${iframeHtml}`;
      }
      divNode.setAttribute("class", "embedded-content");
      divNode.setAttribute("contenteditable", "true");
      editor.insertBefore(divNode, nextSibling);
      setCaret(divNode, 0);
    }

    // Toggle dropdown visibility
    function toggleDropdown(id) {
      const dropdown = document.getElementById(id);
      if (dropdown.classList.contains('show')) {
        dropdown.classList.remove('show');
      } else {
        // Close any open dropdowns first
        document.querySelectorAll('.dropdown-content').forEach(el => el.classList.remove('show'));
        dropdown.classList.add('show');
      }
    }

    // Close dropdowns if clicking outside
    document.addEventListener('click', function (e) {
      if (!e.target.closest('.dropdown')) {
        document.querySelectorAll('.dropdown-content').forEach(el => el.classList.remove('show'));
      }
    });

    // Helper: Place the caret at a given element and offset.
    function setCaret(el, pos) {
      const selection = window.getSelection();
      const range = document.createRange();
      range.setStart(el, pos);
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    // Wrap only the selected portions of text nodes.
    // If selection is entirely within one text node, process it directly.
    function wrapRangeText(range, tagName, style, hook) {

      const textNodes = [];
      if (range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {
        textNodes.push(range.commonAncestorContainer);
      } else {
        const walker = document.createTreeWalker(
          range.commonAncestorContainer,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode: function (node) {

              let isRejectableTag = false;
              let nd = node;

              while (nd && nd.parentNode !== editor) {
                if (NON_STYLABLE_NODE_NAMES.includes(nd.nodeName)) {
                  isRejectableTag = true;
                  break;
                }
                nd = nd.parentNode;
              }

              if (nd && NON_STYLABLE_NODE_NAMES.includes(nd.nodeName)) isRejectableTag = true;

              return !isRejectableTag && range.intersectsNode(node)
                ? NodeFilter.FILTER_ACCEPT
                : NodeFilter.FILTER_REJECT;
            }
          }
        );
        let node;
        while (node = walker.nextNode()) {
          textNodes.push(node);
        }
      }

      textNodes.forEach(function (textNode) {
        let start = 0, end = textNode.textContent.length;
        if (textNode === range.startContainer) {
          start = range.startOffset;
        }
        if (textNode === range.endContainer) {
          end = range.endOffset;
        }
        if (start >= end) return;

        const parent = textNode.parentNode;
        const wrapper = document.createElement(tagName);
        if (style) {
          wrapper.style.cssText = style;
        }
        if (hook) {
          hook(wrapper);
        }
        wrapper.textContent = textNode.textContent.substring(start, end);

        const frag = document.createDocumentFragment();
        const beforeText = textNode.textContent.substring(0, start);
        const afterText = textNode.textContent.substring(end);
        if (beforeText) {
          frag.appendChild(document.createTextNode(beforeText));
        }
        frag.appendChild(wrapper);
        if (afterText) {
          frag.appendChild(document.createTextNode(afterText));
        }
        parent.replaceChild(frag, textNode);
      });
    }

    // Basic inline formatting: wraps the selection in the specified tag.
    function applyFormat(tagName) {
      const selection = window.getSelection();
      if (!selection.rangeCount || selection.isCollapsed) return;
      const range = selection.getRangeAt(0);
      const editor = document.getElementById('editor');
      if (!editor.contains(range.commonAncestorContainer)) return;
      wrapRangeText(range, tagName);
      selection.removeAllRanges();
    }

    // Apply inline style (e.g., font-size, text color, background color) by wrapping the selection in a <span>.
    function applyStyle(styleString) {
      const selection = window.getSelection();
      if (!selection.rangeCount || selection.isCollapsed) return;
      const range = selection.getRangeAt(0);
      const editor = document.getElementById('editor');
      if (!editor.contains(range.commonAncestorContainer)) return;
      wrapRangeText(range, 'span', styleString);
      selection.removeAllRanges();
    }

    // Apply inline url 
    function applyURL() {
      const selection = window.getSelection();
      if (!selection.rangeCount || selection.isCollapsed) return;
      const range = selection.getRangeAt(0);
      const editor = document.getElementById('editor');
      if (!editor.contains(range.commonAncestorContainer)) return;
      const url = prompt("URL")?.trim();
      if (!url) return;
      wrapRangeText(range, 'a', null, function (element) {
        element.href = url;
      });
      selection.removeAllRanges();
    }

    // Called by the text size dropdown.
    function applyTextSize(size) {
      if (!size) return;
      applyStyle("font-size: " + size + ";");
    }

    // Called when a text color swatch is clicked.
    function applyTextColor(color) {
      if (!color) return;
      applyStyle("color: var(--note-text-color-" + color + ");");
    }

    // Called when a highlight (background color) swatch is clicked.
    function applyHighlightColor(color) {
      if (!color) return;
      applyStyle("background-color: var(--note-highlight-color-" + color + ");");
    }

    // Convert the current block (direct child of #editor) to the chosen tag.
    function changeBlock(tag) {
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      let node = selection.anchorNode;
      const editor = document.getElementById('editor');
      while (node && node.parentNode !== editor) {
        if (NON_STYLABLE_NODE_NAMES.includes(node.nodeName)) return;
        node = node.parentNode;
      }
      if (!node || node === editor) return;
      if (NON_STYLABLE_NODE_NAMES.includes(node.nodeName)) return;
      const newBlock = document.createElement(tag);
      while (node.firstChild) {
        if (
          node.firstChild.nodeType === Node.ELEMENT_NODE &&
          node.firstChild.matches('p') &&
          tag.match(/^H[1-6]$/)
        ) {
          let child = node.firstChild;
          while (child.firstChild) {
            newBlock.appendChild(child.firstChild);
          }
          node.removeChild(child);
        } else {
          newBlock.appendChild(node.firstChild);
        }
      }
      editor.replaceChild(newBlock, node);
      const range = document.createRange();
      range.selectNodeContents(newBlock);
      range.collapse(false);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    // Splits the current block at the caret.
    function splitBlock() {
      const editor = document.getElementById('editor');
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      const range = selection.getRangeAt(0);

      let block = range.startContainer;
      while (block && block.parentNode !== editor) {
        block = block.parentNode;
      }
      if (!block) {
        const p = document.createElement('p');
        p.innerHTML = '<br>';
        editor.appendChild(p);
        setCaret(p, 0);
        return;
      }

      const afterRange = range.cloneRange();
      afterRange.setStart(range.endContainer, range.endOffset);
      afterRange.setEndAfter(block.lastChild || block);
      const afterContent = afterRange.cloneContents();

      const isAtEnd = !Array.from(afterContent.childNodes).some(n => {
        return (n.nodeType === Node.ELEMENT_NODE) ||
          (n.nodeType === Node.TEXT_NODE && n.textContent.trim());
      });

      if (isAtEnd) {
        const newBlock = document.createElement('p');
        newBlock.innerHTML = '<br>';
        if (block.nextSibling) {
          editor.insertBefore(newBlock, block.nextSibling);
        } else {
          editor.appendChild(newBlock);
        }
        setCaret(newBlock, 0);
      } else {
        const newBlock = document.createElement('p');
        const extractRange = range.cloneRange();
        extractRange.setEndAfter(block.lastChild || block);
        const extracted = extractRange.extractContents();
        if (!extracted.childNodes.length) {
          newBlock.innerHTML = '<br>';
        } else {
          newBlock.appendChild(extracted);
        }
        if (block.nextSibling) {
          editor.insertBefore(newBlock, block.nextSibling);
        } else {
          editor.appendChild(newBlock);
        }
        setCaret(newBlock, 0);
      }

      if (!block.textContent.trim() && !block.querySelector('img, video, iframe, embed, object')) {
        block.innerHTML = '<br>';
      }
    }

    // Normalize stray text nodes and nested blocks.
    function normalizeEditor() {
      const editor = document.getElementById('editor');
      Array.from(editor.childNodes).forEach(node => {
        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
          const p = document.createElement('p');
          p.textContent = node.textContent;
          editor.replaceChild(p, node);
        }
      });
      editor.querySelectorAll('p p, h1 p, h2 p, h3 p, h4 p, h5 p, h6 p, p font, small p').forEach(nested => {
        const parent = nested.parentNode;
        while (nested.firstChild) {
          parent.insertBefore(nested.firstChild, nested);
        }
        parent.removeChild(nested);
      });
    }

    // Normalize stray text nodes and nested blocks.
    function cleanEditor() {
      const editor = document.getElementById('editor');
      if (editor.firstChild && ["H1", "H2", "H3", "H4", "H5", "H6", "P"].includes(editor.firstChild.nodeName)) {
        return;
      }
      if (editor.innerHTML.trim() === "" || editor.innerHTML.trim() === "<br>") {
        editor.innerHTML = "<p></p>";
      }
    }

    function updateTitle() {
      let filename = document.getElementById("filename");
      if (filename.innerHTML === "<br>") {
        filename.innerHTML = "";
      }
      document.title = filename.innerHTML.trim() || "Nash Note";
    }

    /*function printSelectionInfo() {
      const selection = window.getSelection();
      console.log("selection: ", selection);

      if (selection?.rangeCount) {
        const range = selection.getRangeAt(0);
        console.log("range: ", range);
      }
    }*/

    function keydownHandler(e) {

      if (e.key === 'Enter' && !e.shiftKey) {

        const selection = window.getSelection();

        if (selection.rangeCount) {

          const range = selection.getRangeAt(0);
          let block = range.startContainer;

          while (block && block !== editor) {

            if (block.nodeType === Node.ELEMENT_NODE && block.nodeName === "CODE") {

              const textNode = range.startContainer;

              if (textNode.nodeName === "CODE") {

                //printSelectionInfo();

                if (textNode.childNodes.length > range.startOffset) {
                  textNode.insertBefore(document.createElement("br"), textNode.childNodes[range.startOffset]);
                } else {
                  textNode.appendChild(document.createElement("br"));
                }
                setCaret(textNode, range.startOffset + 1);
              } else if (textNode.nodeName === "BR") {

                //printSelectionInfo();
                const brNode = document.createElement("br");
                textNode.parentNode.insertBefore(brNode, textNode.nextSibling);
                setCaret(brNode, 0);
              } else if (textNode.nodeType === Node.TEXT_NODE && textNode.nodeName == "#text") {

                //printSelectionInfo();
                const text1 = textNode.textContent.substring(0, range.startOffset);
                const text2 = textNode.textContent.substring(range.startOffset);
                const newTextNode = (text2 && text2 !== "") ? document.createTextNode(text2) : null;
                const parentNode = textNode.parentNode;
                const nextSibling = textNode.nextSibling;
                const brNode = document.createElement("br");
                parentNode.insertBefore(brNode, nextSibling);

                if (text1 && text1 !== "") {

                  if (textNode.textContent !== text1) {
                    textNode.textContent = text1;
                  }
                } else {
                  parentNode.removeChild(textNode);
                }

                if (newTextNode) {

                  parentNode.insertBefore(newTextNode, nextSibling);
                  setCaret(newTextNode, 0);
                } else if (text1 && text1 !== "") {

                  if (!nextSibling) {

                    const brNode2 = document.createElement("br");
                    parentNode.insertBefore(brNode2, nextSibling);
                    setCaret(parentNode, [...parentNode.childNodes].indexOf(brNode2));
                  } else {
                    setCaret(parentNode, [...parentNode.childNodes].indexOf(nextSibling));
                  }
                } else {

                  const brNode2 = document.createElement("br");
                  parentNode.insertBefore(brNode2, nextSibling);
                  setCaret(brNode2, 0);
                }
              }
              e.stopImmediatePropagation();
              e.preventDefault();
              return;
            }
            block = block.parentNode;
          }
        }
        e.preventDefault();
        splitBlock();
      }

      if ((e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'y')) {
        e.preventDefault();
      }
    }

    function clickHandler(e) {
      const target = e.target.closest("a");
      if (!target || !document.getElementById("editorContainer").contains(target)) return;

      e.preventDefault();

      const userConfirmed = confirm(`"${target.href}" open this url?`);
      if (userConfirmed) {
        window.open(target.href, "_blank");
      }
    }

    function unloadHandler(e) {
      if (document.getElementById("editor").contentEditable !== "true") {
        return;
      }
      e.preventDefault()
      e.returnValue = '';
    }

    let lastValidSelectionRange = null;

    document.onselectionchange = () => {
      const selection = document.getSelection();

      if (selection?.rangeCount) {

        const range = selection.getRangeAt(0);

        if (editor.contains(range.startContainer)) {
          lastValidSelectionRange = range;
        }
      }
    };

    let editor = document.getElementById('editor');
    let filename = document.getElementById('filename');

    editor.addEventListener('keydown', keydownHandler);
    editor.addEventListener('click', clickHandler);
    editor.addEventListener('blur', normalizeEditor);
    editor.addEventListener("input", cleanEditor);
    editor.addEventListener("focus", cleanEditor);

    filename.addEventListener("input", updateTitle);

    window.addEventListener("beforeunload", unloadHandler);

    loadAllReferencedDocuments();

    updateTitle();

    /* Event handlers */

    document.getElementById("btnH1").addEventListener("click", (e) => changeBlock("h1"));
    document.getElementById("btnH2").addEventListener("click", (e) => changeBlock("h2"));
    document.getElementById("btnM").addEventListener("click", (e) => changeBlock("p"));
    document.getElementById("btnS").addEventListener("click", (e) => changeBlock("small"));

    document.getElementById("btnB").addEventListener("click", (e) => applyFormat("strong"));
    document.getElementById("btnI").addEventListener("click", (e) => applyFormat("em"));
    document.getElementById("btnU").addEventListener("click", (e) => applyFormat("u"));
    document.getElementById("btnLink").addEventListener("click", (e) => applyURL());

    document.getElementById("imageUpload").addEventListener("change", (e) => insertImage(e));
    document.getElementById("btnImageLink").addEventListener("click", (e) => insertImageLink());

    document.getElementById("btnTextColorMenu").addEventListener("click", (e) => toggleDropdown("textColorDropdown"));
    
    for (let i = 1; i < 9; ++i) {
      document.getElementById(`btnTextColor${i}`).addEventListener("click", (e) => {
        applyTextColor(`${i}`);
        toggleDropdown("textColorDropdown");
      });
    }

    document.getElementById("btnTextHighlightMenu").addEventListener("click", (e) => toggleDropdown("highlightDropdown"));
    
    for (let i = 1; i < 9; ++i) {
      document.getElementById(`btnTextHighlight${i}`).addEventListener("click", (e) => {
        applyHighlightColor(`${i}`);
        toggleDropdown("highlightDropdown");
      });
    }

    document.getElementById("btnText").addEventListener("click", (e) => insertText());
    document.getElementById("btnCode").addEventListener("click", (e) => insertCode());
    document.getElementById("btnEmbedContent").addEventListener("click", (e) => insertEmbeddedContent());

    document.getElementById("audioUpload").addEventListener("change", (e) => insertAudio(event));

    document.getElementById("btnAudioLink").addEventListener("click", (e) => insertAudioLink());
    document.getElementById("btnVideoLink").addEventListener("click", (e) => insertVideoLink());

    document.getElementById("epubUpload").addEventListener("change", (e) => insertEpub(e));
    document.getElementById("pdfUpload").addEventListener("change", (e) => insertPdf(e));

    document.getElementById("btnSaveMenu").addEventListener("click", (e) => toggleDropdown("saveDropdown"));
    document.getElementById("btnSave").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(true, true);
    });
    document.getElementById("btnShare").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(false, true);
    });
    document.getElementById("btnSaveReadOnly").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(true, false);
    });
    document.getElementById("btnShareReadOnly").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(false, false);
    });
  </script>

</body>

</html>