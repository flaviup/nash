<!DOCTYPE html>
<html lang="en-US">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Nash Note</title>
  <link rel="icon" type="image/svg+xml"
    href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%20100%20100%22%3E%0A%20%20%3Crect%20width%3D%22100%22%20height%3D%22100%22%20rx%3D%2220%22%20fill%3D%22black%22%2F%3E%0A%20%20%3Ctext%20x%3D%2250%25%22%20y%3D%2250%25%22%20font-size%3D%2260%22%20font-weight%3D%22bold%22%20text-anchor%3D%22middle%22%20fill%3D%22white%22%20font-family%3D%22Arial%2C%20sans-serif%22%20dominant-baseline%3D%22central%22%3EN.%3C%2Ftext%3E%0A%3C%2Fsvg%3E">
  <style>
    :root {
      --page-bg-color: #f8f9fa;
      --page-text-color: #333;

      --control-bg-color: #f8f9fa;
      --control-text-color: buttontext;
      --control-hover-bg-color: #f0f0f0;
      --control-hover-text-color: #bbb;

      --note-bg-color: #fff;
      --note-placeholer-color: #bbb;
      --note-link-color: #616161;

      --attribution-color: #bbb;

      --code-bg-color: #e5e4e2;
      --code-text-color: #333;

      /* text background colors */
      --note-text-color-1: #000000;
      /* black */
      --note-text-color-2: #FF3B30;
      /* red */
      --note-text-color-3: #FF9500;
      /* orange */
      --note-text-color-4: #FFCC00;
      /* yellow */
      --note-text-color-5: #4CD964;
      /* green */
      --note-text-color-6: #5AC8FA;
      /* light-blue */
      --note-text-color-7: #007AFF;
      /* dark-blue */
      --note-text-color-8: #5856D6;
      /* violet */

      /* highlight background colors */
      --note-highlight-color-1: #FCECEC;
      /* red */
      --note-highlight-color-2: #FFECEB;
      /* orange */
      --note-highlight-color-3: #FFF8E1;
      /* yellow */
      --note-highlight-color-4: #F1FAE5;
      /* green */
      --note-highlight-color-5: #E6F9F0;
      /* light-blue */
      --note-highlight-color-6: #E8F0FE;
      /* violet */
      --note-highlight-color-7: #E7F0FF;
      /* dark-blue */
      --note-highlight-color-8: #F3E8FF;
      /* purple */
    }

    /* dark mode */
    @media (prefers-color-scheme: dark) {
      :root {
        --page-bg-color: #3a3a3a;
        --page-text-color: #ddd;

        --control-bg-color: #444;
        --control-text-color: #aaa;
        --control-hover-bg-color: #666;
        --control-hover-text-color: #eee;

        --note-bg-color: #333;
        --note-placeholder-color: #555;

        --code-bg-color: #36454f;
        --code-text-color: #fff;

        /*
               TODO: choose nicer colors :-)
            */

        /* text background colors */
        --note-text-color-1: #FAFAFA;
        /* black / white */
        --note-text-color-2: #FF3B30;
        /* red */
        --note-text-color-3: #FF9500;
        /* orange */
        --note-text-color-4: #FFCC00;
        /* yellow */
        --note-text-color-5: #4CD964;
        /* green */
        --note-text-color-6: #5AC8FA;
        /* light-blue */
        --note-text-color-7: #007AFF;
        /* dark-blue */
        --note-text-color-8: #5856D6;
        /* violet */

        /* highlight background colors */
        --note-highlight-color-1: hsl(0 50% 30%);
        /* red */
        --note-highlight-color-2: hsl(30 50% 30%);
        /* orange */
        --note-highlight-color-3: hsl(45 50% 30%);
        /* yellow */
        --note-highlight-color-4: hsl(120 50% 30%);
        /* green */
        --note-highlight-color-5: hsl(240 70% 40%);
        /* light-blue */
        --note-highlight-color-6: hsl(300 70% 40%);
        /* violet */
        --note-highlight-color-7: hsl(240 50% 30%);
        /* dark-blue */
        --note-highlight-color-8: hsl(330 50% 30%);
        /* purple */
      }
    }

    body {
      font-family: 'Arial', sans-serif;
      background-color: var(--page-bg-color);
      color: var(--page-text-color);
      margin: 0;
      padding: 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .editor-container {
      width: 100%;
      max-width: 900px;
      background: var(--note-bg-color);
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0px 5px 15px rgba(0, 0, 0, 0.1);
    }

    .file-title {
      font-size: 28px;
      font-weight: bold;
      margin-bottom: 15px;
      padding: 0px 15px;
      outline: none;
      border: none;
      width: 100%;
      background: transparent;
    }

    .file-title:empty::before {
      content: "Write your title here...";
      color: var(--note-placeholder-color);
      display: block;
    }

    #toolbar {
      position: sticky;
      position: -webkit-sticky;
      gap: 8px;
      top: 5px;
      padding: 0 10px;
      z-index: 9999;
      background-color: var(--control-bg-color);
      border-radius: 12px;
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      align-items: center;
    }

    #toolbar #splitbar {
      margin-left: auto;
    }

    #toolbar input[type="file"] {
      display: none;
    }


    #toolbar button,
    #toolbar label,
    #toolbar select {
      padding: 8px;
      border: none;
      background: none;
      color: var(--control-text-color);
      font-size: 16px;
      cursor: pointer;
      transition: opacity 0.2s
    }

    #toolbar button:hover,
    #toolbar label:hover,
    #toolbar select:hover {
      background: var(--control-hover-bg-color);
      border-color: var(--control-hover-text-color);
      color: var(--control-hover-text-color);
    }

    /* Dropdown container */
    .dropdown {
      position: relative;
      display: inline-block;
    }

    /* Dropdown button style */
    .dropdown>button {
      padding: 6px 10px;
    }

    /* Dropdown content (hidden by default) */
    .dropdown-content {
      display: none;
      position: absolute;
      top: 110%;
      right: 0;
      background: var(--control-bg-color);
      border: 1px solid var(--control-bg-color);
      color: var(--control-text-color);
      padding: 8px;
      border-radius: 4px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      z-index: 10;
    }

    /* Show dropdown when .show is added */
    .dropdown-content.show {
      display: block;
    }

    /* Grid of swatches */
    .swatch-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, 24px);
      gap: 6px;
    }

    .color-swatch {
      width: 24px;
      height: 24px;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .color-swatch:hover {
      transform: scale(1.1);
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.3);
    }

    #saveDropdown {
      width: 200px;
    }

    #saveDropdown button {
      width: 100%;
      text-align: left;
    }

    #editor {
      border-radius: 12px;
      padding: 15px;
      min-height: 250px;
      outline: none;
      font-size: 16px;
      line-height: 1.6;
      /* background: #f4f4f4; */
    }

    #editor p {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
    }

    #editor a {
      color: var(--note-link-color);
      text-decoration: none;
      font-weight: 800;
      transition: all 0.2s ease-in-out;
      border-bottom: 2px solid transparent;
    }

    #editor a:hover {
      border-bottom: 2px solid var(--note-link-color);
      color: var(--note-link-color);
    }

    #editor a::before {
      content: "ðŸ”—";
    }

    #editor pre code {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
      background: var(--code-bg-color);
      color: var(--code-text-color);
      display: block;
      margin: 0;
      padding: 8px;
      border-radius: 6px;
    }

    #editor:empty::before,
    #editor p:empty::before {
      content: "Write your note here...";
      color: var(--note-placeholder-color);
      display: block;
    }

    #footer {
      text-align: center;
      margin-top: 20px;
      color: var(--attribution-color);
    }

    #footer a {
      text-decoration: none;
      color: var(--attribution-color);
    }

    img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 10px 0;
      border-radius: 12px;
    }

    audio {
      width: 100%;
      display: block;
      margin: 10px 0;
    }

    video {
      width: 100%;
      height: auto;
      display: block;
      margin: 10px 0;
      border-radius: 12px;
    }

    .embedded-content {
      width: 100%;
      height: auto;
      display: block;
      margin: 10px 0;
    }

    .embedded-local-epub {
      width: 100%;
      height: auto;
      display: block;
      margin: 20px 0;
    }

    .embedded-local-pdf {
      width: 100%;
      height: auto;
      display: block;
      margin: 20px 0;
    }

    .thin-line::before {
      content: "";
      display: block;
      width: 100%;
      height: 1px;
      background-color: var(--control-bg-color);
      color: var(--control-text-color);
      margin: 10px 0;
    }

    .embedded-local-epub,
    .embedded-local-pdf,
    .embedded-local-image,
    .embedded-local-audio,
    .image-link,
    .audio-link,
    .video-link {
      display: block;
      position: relative;
    }

    .x-remover {
      background-color: #aaa;
      padding: 5px 9px;
      color: #ff3b30;
      display: none;
      position: absolute;
      top: 0;
      right: 0;
      margin-top: -10px;
      margin-right: -10px;
      font-weight: 700;
      border-radius: 50%;
      border: 1px solid #333;
      text-align: center;
      line-height: 20px;
      font-family: sans-serif;
      cursor: default;
    }

    .embedded-local-image:hover .x-remover,
    .embedded-local-audio:hover .x-remover,
    .image-link:hover .x-remover,
    .audio-link:hover .x-remover,
    .video-link:hover .x-remover,
    .embedded-local-epub:hover .x-remover,
    .embedded-local-pdf:hover .x-remover {
      display: block;
    }

    @media print {
      .no-print {
        display: none !important;
      }

      .editor-container {
        width: 100%;
        max-width: 100%;
        box-shadow: none;
      }
    }
  </style>
</head>

<body>

  <div class="editor-container">
    <div id="filename" contenteditable="plaintext-only" class="file-title"></div>

    <div id="toolbar" class="no-print">
      <button id="btnH1">XL</button>
      <button id="btnH2">L</button>
      <button id="btnM">M</button>
      <button id="btnS">S</button>

      <button id="btnB"><b>B</b></button>
      <button id="btnI"><i>I</i></button>
      <button id="btnU"><u>U</u></button>
      <button id="btnLink">ðŸ”—</button>

      <label for="imageUpload">ðŸ“·</label>
      <input type="file" id="imageUpload" accept="image/*" onclick="this.value = null">

      <button id="btnImageLink"">ðŸ–¼</button>

      <div class="dropdown">
        <button id="btnTextColorMenu">Color</button>
        <div id="textColorDropdown" class="dropdown-content">
          <div class="swatch-grid">
            <button id="btnTextColor1" class="color-swatch" style="background: var(--note-text-color-1);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextColor2" class="color-swatch" style="background: var(--note-text-color-2);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextColor3" class="color-swatch" style="background: var(--note-text-color-3);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextColor4" class="color-swatch" style="background: var(--note-text-color-4);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextColor5" class="color-swatch" style="background: var(--note-text-color-5);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextColor6" class="color-swatch" style="background: var(--note-text-color-6);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextColor7" class="color-swatch" style="background: var(--note-text-color-7);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextColor8" class="color-swatch" style="background: var(--note-text-color-8);"
              onmousedown="event.preventDefault();"></button>
          </div>
        </div>
      </div>

      <!-- Highlight Color Dropdown -->
      <div class="dropdown">
        <button id="btnTextHighlightMenu">Highlight</button>
        <div id="highlightDropdown" class="dropdown-content">
          <div class="swatch-grid">
            <button id="btnTextHighlight1" class="color-swatch" style="background: var(--note-highlight-color-1);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextHighlight2" class="color-swatch" style="background: var(--note-highlight-color-2);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextHighlight3" class="color-swatch" style="background: var(--note-highlight-color-3);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextHighlight4" class="color-swatch" style="background: var(--note-highlight-color-4);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextHighlight5" class="color-swatch" style="background: var(--note-highlight-color-5);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextHighlight6" class="color-swatch" style="background: var(--note-highlight-color-6);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextHighlight7" class="color-swatch" style="background: var(--note-highlight-color-7);"
              onmousedown="event.preventDefault();"></button>
            <button id="btnTextHighlight8" class="color-swatch" style="background: var(--note-highlight-color-8);"
              onmousedown="event.preventDefault();"></button>
          </div>
        </div>
      </div>
      <button id="btnText"><b>T</b></button>
      <button id="btnCode">ðŸ–¥</button>
      <button id="btnEmbedContent">ðŸ—‚</button>

      <label for="audioUpload">ðŸ”ˆ</label>
      <input type="file" id="audioUpload" accept="audio/*" onclick="this.value = null">

      <button id="btnAudioLink">ðŸ”Š</button>
      <button id="btnVideoLink">ðŸ“½</button>

      <label for="epubUpload">ðŸ“–</label>
      <input type="file" id="epubUpload" accept="epub/*" onclick="this.value = null">

      <label for="pdfUpload">ðŸ“–</label>
      <input type="file" id="pdfUpload" accept="pdf/*" onclick="this.value = null">

      <div id="splitbar">|</div>
      <!-- Block conversion -->
      <div class="dropdown">
        <button id="btnSaveMenu">ðŸ’¾</button>
        <div id="saveDropdown" class="dropdown-content">
          <button id="btnSave">Save</button>
          <button id="btnShare">Share</button>
          <button id="btnSaveReadOnly">Save as Read-Only</button>
          <button id="btnShareReadOnly">Share as Read-Only</button>
        </div>
      </div>

    </div>

    <div id="editorContainer" class="thin-line">
      <div id="editor" contenteditable="true">
        <p class="text-block"></p>
      </div>
    </div>

    <div id="footer">
      <small><a href="https://github.com/flaviup">flaviup@github</a></small>
      <br/>
      <small>Nash 0.1</small>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <!-- script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script -->
  <script src="https://github.com/futurepress/epub.js/releases/download/v0.3.88/epub.min.js"></script> <!-- check newer versions like 0.3.93 -->

  <script type="module">
    /**
     *  PDFObject v2.3.1
     *  https://github.com/pipwerks/PDFObject
     *  @license
     *  Copyright (c) 2008-2025 Philip Hutchison
     *  MIT-style license: http://pipwerks.mit-license.org/
     *  UMD module pattern from https://github.com/umdjs/umd/blob/master/templates/returnExports.js
     */

    (function (root, factory) {
        if (typeof define === "function" && define.amd) {
            // AMD. Register as an anonymous module.
            define([], factory);
        } else if (typeof module === "object" && module.exports) {
            // Node. Does not work with strict CommonJS, but
            // only CommonJS-like environments that support module.exports,
            // like Node.
            module.exports = factory();
        } else {
            // Browser globals (root is window)
            root.PDFObject = factory();
        }
    }(globalThis, function () {

        "use strict";

        //PDFObject is designed for client-side (browsers), not server-side (node)
        //Will choke on undefined navigator and window vars when run on server
        //Return boolean false and exit function when running server-side

        if(typeof window === "undefined" || window.navigator === undefined || window.navigator.userAgent === undefined){ return false; }

        let pdfobjectversion = "2.3.1";
        let win = window;
        let nav = win.navigator;
        let ua = nav.userAgent;
        let suppressConsole = false;

        //Fallback validation when navigator.pdfViewerEnabled is not supported
        let isModernBrowser = function (){

            /*
              userAgent sniffing is not the ideal path, but most browsers revoked the ability to check navigator.mimeTypes
              for security purposes. As of 2023, browsers have begun implementing navigator.pdfViewerEnabled, but older versions
              do not have navigator.pdfViewerEnabled or the ability to check navigator.mimeTypes. We're left with basic browser
              sniffing and assumptions of PDF support based on browser vendor.
            */

            //Chromium has provided native PDF support since 2011.
            //Most modern browsers use Chromium under the hood: Google Chrome, Microsoft Edge, Opera, Brave, Vivaldi, Arc, and more.
            //Chromium uses the PDFium rendering engine, which is based on Foxit's PDF rendering engine.
            //Note that MS Edge opts to use a different PDF rendering engine. As of 2024, Edge uses a version of Adobe's Reader
            let isChromium = (win.chrome !== undefined);

            //Safari on macOS has provided native PDF support since 2009.
            //This code snippet also detects the DuckDuckGo browser, which uses Safari/Webkit under the hood.
            let isSafari = (win.safari !== undefined || (nav.vendor !== undefined && /Apple/.test(nav.vendor) && /Safari/.test(ua)));

            //Firefox has provided PDF support via PDFJS since 2013.
            let isFirefox = (win.Mozilla !== undefined || /irefox/.test(ua));

            return isChromium || isSafari || isFirefox;

        };

        /*
          Special handling for Internet Explorer 11.
          Check for ActiveX support, then whether "AcroPDF.PDF" or "PDF.PdfCtrl" are valid.
          IE11 uses ActiveX for Adobe Reader and other PDF plugins, but window.ActiveXObject will evaluate to false.
          ("ActiveXObject" in window) evaluates to true.
          MS Edge does not support ActiveX so this test will evaluate false for MS Edge.
        */
        let validateAX = function (type){
            var ax = null;
            try {
                ax = new ActiveXObject(type);
            } catch (e) {
                //ensure ax remains null when ActiveXObject attempt fails
                ax = null;
            }
            return !!ax; //convert resulting object to boolean
        };

        let hasActiveXPDFPlugin = function (){ return ("ActiveXObject" in win) && (validateAX("AcroPDF.PDF") || validateAX("PDF.PdfCtrl")) };

        let checkSupport = function (){

            //Safari on iPadOS doesn't report as 'mobile' when requesting desktop site, yet still fails to embed PDFs
            let isSafariIOSDesktopMode = (nav.platform !== undefined && nav.platform === "MacIntel" && nav.maxTouchPoints !== undefined && nav.maxTouchPoints > 1);

            let isMobileDevice = (isSafariIOSDesktopMode || /Mobi|Tablet|Android|iPad|iPhone/.test(ua));

            //As of June 2023, no mobile browsers properly support inline PDFs. If mobile, just say no.
            if(isMobileDevice){ return false; }

            //Modern browsers began supporting navigator.pdfViewerEnabled in late 2022 and early 2023.
            let supportsPDFVE = (typeof nav.pdfViewerEnabled === "boolean");

            //If browser supports nav.pdfViewerEnabled and is explicitly saying PDFs are NOT supported (e.g. PDFJS disabled by user in Firefox), respect it.
            if(supportsPDFVE && !nav.pdfViewerEnabled){ return false; }

            return (supportsPDFVE && nav.pdfViewerEnabled) || isModernBrowser() || hasActiveXPDFPlugin();

        };

        //Determines whether PDF support is available
        let supportsPDFs = checkSupport();

        //Create a fragment identifier for using PDF Open parameters when embedding PDF
        let buildURLFragmentString = function(pdfParams){

            let string = "";
            let prop;
            let paramArray = [];
            let fdf = "";

            //The comment, viewrect, and highlight parameters require page to be set first.

            //Check to ensure page is used if comment, viewrect, or highlight are specified
            if(pdfParams.comment || pdfParams.viewrect || pdfParams.highlight){

                if(!pdfParams.page){

                    //If page is not set, use the first page
                    pdfParams.page = 1;

                    //Inform user that page needs to be set properly
                    embedError("The comment, viewrect, and highlight parameters require a page parameter, but none was specified. Defaulting to page 1.");

                }

            }

            //Let's go ahead and ensure page is always the first parameter.
            if(pdfParams.page){
                paramArray.push("page=" + encodeURIComponent(pdfParams.page));
                delete pdfParams.page;
            }

            //FDF needs to be the last parameter in the string
            if(pdfParams.fdf){
                fdf = pdfParams.fdf;
                delete pdfParams.fdf;
            }

            //Add all other parameters, as needed
            if(pdfParams){

                for (prop in pdfParams) {
                    if (pdfParams.hasOwnProperty(prop)) {
                        paramArray.push(encodeURIComponent(prop) + "=" + encodeURIComponent(pdfParams[prop]));
                    }
                }

                //Add fdf as the last parameter, if needed
                if(fdf){
                    paramArray.push("fdf=" + encodeURIComponent(fdf));
                }

                //Join all parameters in the array into a string
                string = paramArray.join("&");

                //The string will be empty if no PDF Parameters were provided
                //Only prepend the hash if the string is not empty
                if(string){
                    string = "#" + string;
                }

            }

            return string;

        };

        let embedError = function (msg){
            if(!suppressConsole){
                console.log("[PDFObject]", msg);
            }
            return false;
        };

        let emptyNodeContents = function (node){
            while(node.firstChild){
                node.removeChild(node.firstChild);
            }
        };

        let getTargetElement = function (targetSelector){

            //Default to body for full-browser PDF
            let targetNode = document.body;

            //If a targetSelector is specified, check to see whether
            //it's passing a selector, jQuery object, or an HTML element

            if(typeof targetSelector === "string"){

                //Is CSS selector
                targetNode = document.querySelector(targetSelector);

            } else if (win.jQuery !== undefined && targetSelector instanceof jQuery && targetSelector.length) {

                //Is jQuery element. Extract HTML node
                targetNode = targetSelector.get(0);

            } else if (targetSelector.nodeType !== undefined && targetSelector.nodeType === 1){

                //Is HTML element
                targetNode = targetSelector;

            }

            return targetNode;

        };

        let convertBase64ToDownloadableLink = function (b64, filename, targetNode, fallbackHTML) {

            //IE-11 safe version. More verbose than modern fetch()
            if (window.Blob && window.URL && window.URL.createObjectURL) {

                var xhr = new XMLHttpRequest();
                xhr.open('GET', b64, true);
                xhr.responseType = 'blob';
                xhr.onload = function() {

                    if (xhr.status === 200) {

                        var blob = xhr.response;
                        var link = document.createElement('a');
                        link.innerText = "Download PDF";
                        link.href = URL.createObjectURL(blob);
                        link.setAttribute('download', filename);
                        targetNode.innerHTML = fallbackHTML.replace(/\[pdflink\]/g, link.outerHTML);

                    }

                };

                xhr.send();

            }

        };


        let generatePDFObjectMarkup = function (embedType, targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute, PDFJS_URL){

            //Ensure target element is empty first
            emptyNodeContents(targetNode);

            let source = url;

            if(embedType === "pdfjs"){
                //If PDFJS_URL already contains a ?, assume querystring is in place, and use an ampersand to append PDFJS's file parameter
                let connector = (PDFJS_URL.indexOf("?") !== -1) ? "&" : "?";
                source = PDFJS_URL + connector + "file=" + encodeURIComponent(url) + pdfOpenFragment;
            } else {
                source += pdfOpenFragment;
            }

            let el = document.createElement("iframe");
            el.className = "pdfobject";
            el.type = "application/pdf";
            el.title = title;
            el.src = source;
            el.allow = "fullscreen";
            el.frameborder = "0";
            if(id){ el.id = id; }

            if(!omitInlineStyles){

                let style = "border: none;";

                if(targetNode !== document.body){
                    //assign width and height to target node
                    style += "width: " + width + "; height: " + height + ";";
                } else {
                    //this is a full-page embed, use CSS to fill the viewport
                    style += "position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: 100%; height: 100%;";
                }

                el.style.cssText = style;

            }

            //Allow developer to insert custom attribute on iframe element, but ensure it does not conflict with attributes used by PDFObject
            let reservedTokens = ["className", "type", "title", "src", "style", "id", "allow", "frameborder"];
            if(customAttribute && customAttribute.key && reservedTokens.indexOf(customAttribute.key) === -1){
                el.setAttribute(customAttribute.key, (typeof customAttribute.value !== "undefined") ? customAttribute.value : "");
            }

            targetNode.classList.add("pdfobject-container");
            targetNode.appendChild(el);

            return targetNode.getElementsByTagName("iframe")[0];

        };

        let embed = function(url, targetSelector, options){

            //If targetSelector is not defined, convert to boolean
            let selector = targetSelector || false;

            //Ensure options object is not undefined -- enables easier error checking below
            let opt = options || {};

            //Get passed options, or set reasonable defaults
            suppressConsole = (typeof opt.suppressConsole === "boolean") ? opt.suppressConsole : false;
            let id = (typeof opt.id === "string") ? opt.id : "";
            let page = opt.page || false;
            let pdfOpenParams = opt.pdfOpenParams || {};
            let fallbackLink = (typeof opt.fallbackLink === "string" || typeof opt.fallbackLink === "boolean") ? opt.fallbackLink : true;
            let width = opt.width || "100%";
            let height = opt.height || "100%";
            let title = opt.title || "Embedded PDF";
            let forcePDFJS = (typeof opt.forcePDFJS === "boolean") ? opt.forcePDFJS : false;
            let omitInlineStyles = (typeof opt.omitInlineStyles === "boolean") ? opt.omitInlineStyles : false;
            let PDFJS_URL = opt.PDFJS_URL || false;
            let targetNode = getTargetElement(selector);
            let pdfOpenFragment = "";
            let customAttribute = opt.customAttribute || {};
            let fallbackFileNameForBase64 = opt.fallbackFileNameForBase64;
            let fallbackHTML_default = "<p>This browser does not support inline PDFs. Please download the PDF to view it: [pdflink]</p>";

            //Ensure URL is available. If not, exit now.
            if(typeof url !== "string"){ return embedError("URL is not valid"); }

            //If target element is specified but is not valid, exit without doing anything
            if(!targetNode){ return embedError("Target element cannot be determined"); }

            //page option overrides pdfOpenParams, if found
            if(page){ pdfOpenParams.page = page; }

            //Stringify optional Adobe params for opening document (as fragment identifier)
            pdfOpenFragment = buildURLFragmentString(pdfOpenParams);


            // --== Do the dance: Embed attempt #1 ==--

            //If the forcePDFJS option is invoked, skip everything else and embed as directed
            if(forcePDFJS && PDFJS_URL){
                return generatePDFObjectMarkup("pdfjs", targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute, PDFJS_URL);
            }

            // --== Embed attempt #2 ==--

            //Embed PDF if support is detected, or if this is a relatively modern browser
            if(supportsPDFs){
                return generatePDFObjectMarkup("iframe", targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute);
            }

            // --== Embed attempt #3 ==--

            //If everything else has failed and a PDFJS fallback is provided, try to use it
            if(PDFJS_URL){
                return generatePDFObjectMarkup("pdfjs", targetNode, url, pdfOpenFragment, width, height, id, title, omitInlineStyles, customAttribute, PDFJS_URL);
            }

            // --== PDF embed not supported! Use fallback ==--

            //Display the fallback link if available
            if(fallbackLink){

                //If a custom fallback has been provided, handle it now
                if(typeof fallbackLink === "string"){

                    //Ensure [url] is set in custom fallback
                    targetNode.innerHTML = fallbackLink.replace(/\[url\]/g, url);

                } else {

                    //If the PDF is a base64 string, convert it to a downloadable link
                    const match = url.match(/data:application\/pdf;(?:.*filename=([^;]+);)?.*base64,/i);
                    if(match){

                        fallbackFileNameForBase64 =
                            fallbackFileNameForBase64 // from options
                            || match[1] // from data URI metadata
                            || "file.pdf"; // default

                        //Asynchronously append the link to the targetNode
                        convertBase64ToDownloadableLink(url, fallbackFileNameForBase64, targetNode, fallbackHTML_default);

                    } else {

                        //Use default fallback link
                        let link = "<a href='" + url + "'>Download PDF</a>";
                        targetNode.innerHTML = fallbackHTML_default.replace(/\[pdflink\]/g, link);

                    }

                }

            }

            return embedError("This browser does not support embedded PDFs");

        };

        return {
            embed: function (a,b,c){ return embed(a,b,c); },
            pdfobjectversion: (function () { return pdfobjectversion; })(),
            supportsPDFs: (function (){ return supportsPDFs; })()
        };

    })); // END OF PDFObject

    const NON_STYLABLE_NODE_NAMES = ["CODE", "IFRAME"];

    function setEditMode(editMode) {
      let editor = document.getElementById("editor");
      let toolbar = document.getElementById("toolbar");
      let filename = document.getElementById("filename");

      if (editMode) {
        editor.contentEditable = "true";
        filename.contentEditable = "plaintext-only";
        toolbar.style.display = "flex";
      }
      else {
        editor.contentEditable = "false";
        filename.contentEditable = "false";
        toolbar.style.display = "none";
      }
    }

    function removeDocumentNodes(html) {

      const template = document.createElement('template');
      template.innerHTML = html;

      template.content.querySelectorAll('.embedded-local-epub').forEach(el => {
        el.replaceChildren();
      });

      template.content.querySelectorAll('.embedded-local-pdf').forEach(el => {
        el.replaceChildren();
      });

      return template.innerHTML;
    }

    async function exportToFile(save, editMode) {
      let filename = document.getElementById("filename").innerText.trim();
      if (!filename) {
        alert("title is empty!");
        return;
      }

      filename = filename.endsWith(".html") ? filename : filename + ".html";

      if (editMode === false) {
        setEditMode(false);
      }

      let content = removeDocumentNodes(document.documentElement.outerHTML);
      let blob = new Blob(["<!DOCTYPE html>\n" + content], { type: "text/html" });
      let file = new File([blob], filename, { type: "text/html" });

      if (editMode === false) {
        setEditMode(true);
      }

      if (save == false && navigator.canShare && navigator.canShare({ files: [file] })) {
        try {
          await navigator.share({
            files: [file],
            title: filename,
            text: ""
          });
        } catch (error) {
          console.error("share failed:", error);
        }
      } else {
        let a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
        URL.revokeObjectURL(a.href);
      }
    }

    function getTopLevelNodeOfCurrentPosition(useSelectionRange = null) {

      let topNode = null;
      let range = useSelectionRange;

      if (!range) {

        let selection = window.getSelection();

        if (selection?.rangeCount) {
          range = selection.getRangeAt(0);
        }
      }

      if (range) {

        let block = range.startContainer;

        if (block && block !== editor) {

          while (block.parentNode && block.parentNode !== editor) {
            block = block.parentNode;
          }

          if (block.parentNode === editor) {
            topNode = block;
          }
        }
      }

      return topNode;
    }

    function createRemover(callback = null) {

      const divNode = document.createElement("div");
      divNode.innerText = "âœ•";
      divNode.addEventListener('click', function (e) {

        const parentNode = e.target?.parentNode;

        if (parentNode?.parentNode) {

          parentNode.parentNode.removeChild(parentNode);

          if (callback) {
            callback();
          }
        }
      }, false);
      divNode.setAttribute("class", "x-remover");
      divNode.setAttribute("contenteditable", "false");
      return divNode;
    }

    function insertImage(event) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextSibling;
        reader.onload = function (e) {
          const divNode = document.createElement("div");
          const img = document.createElement("img");
          img.src = e.target.result;
          divNode.appendChild(img);
          divNode.appendChild(createRemover());
          divNode.setAttribute("class", "embedded-local-image");
          divNode.setAttribute("contenteditable", "false");
          editor.insertBefore(divNode, nextSibling);
        };
        reader.readAsDataURL(file);
      }
    }

    function insertImageLink() {

      const url = prompt("Image URL")?.trim();
      if (!url) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");
      const img = document.createElement("img");
      img.src = `${url}`;
      divNode.appendChild(img);
      divNode.appendChild(createRemover());
      divNode.setAttribute("class", "image-link");
      divNode.setAttribute("contenteditable", "false");
      editor.insertBefore(divNode, nextSibling);
    }

    function insertAudio(event) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextSibling;
        reader.onload = function (e) {
          const divNode = document.createElement("div");
          const audio = document.createElement("audio");
          audio.src = e.target.result;
          audio.setAttribute("controls", "");
          divNode.appendChild(audio);
          divNode.appendChild(createRemover());
          divNode.setAttribute("class", "embedded-local-audio");
          divNode.setAttribute("contenteditable", "false");
          editor.insertBefore(divNode, nextSibling);
        };
        reader.readAsDataURL(file);
      }
    }

    function insertAudioLink() {

      const url = prompt("Audio URL")?.trim();
      if (!url) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");
      const audio = document.createElement("audio");
      audio.src = `${url}`;
      audio.setAttribute("controls", "");
      divNode.appendChild(audio);
      divNode.appendChild(createRemover());
      divNode.setAttribute("class", "audio-link");
      divNode.setAttribute("contenteditable", "false");
      editor.insertBefore(divNode, nextSibling);
    }

    function insertVideoLink() {

      const url = prompt("Video URL")?.trim();
      if (!url) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");
      const video = document.createElement("video");
      video.src = `${url}`;
      video.setAttribute("controls", "");
      divNode.appendChild(video);
      divNode.appendChild(createRemover());
      divNode.setAttribute("class", "video-link");
      divNode.setAttribute("contenteditable", "false");
      editor.insertBefore(divNode, nextSibling);
    }

    function generateUId() {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }
      return s4() + s4() + s4() + s4() +
             s4() + s4() + s4() + s4();
    }

    function loadAllReferencedDocuments() {

      document.querySelectorAll('.embedded-local-epub').forEach(async el => {
        const dataUrl = el.getAttribute("data-epub");
        await loadEpub(dataUrl, null, el);
      });

      document.querySelectorAll('.embedded-local-pdf').forEach(async el => {
        const dataUrl = el.getAttribute("data-pdf");
        await loadPdf(dataUrl, null, el);
      });
    }

    function insertEpub(event, element = null) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextSibling;
        reader.onload = async function (e) {
          await loadEpub(e.target?.result, nextSibling);
        }
        reader.readAsDataURL(file);
      }
    }

    async function loadEpub(epubData, nextSibling, element = null) {

      if (epubData) {

        let book = null;

        try {
          //book = ePub(epubData, { openAs: "base64" }); // BUG: not working
          book = ePub(await (await window.fetch(epubData)).blob());
        } catch (error) { // we allow ePub loading only if epub library is available and the data could be loaded
          console.log(error);
          return;
        }

        const epubId = generateUId();
        const strEpubId = `epub${epubId}`;
        const strTocId = `toc${epubId}`;

        const navButtons = document.createElement("div");
        navButtons.style = "float: top; display: flow-root;";
        navButtons.setAttribute("contenteditable", "false");
        const prev = document.createElement("div");
        const next = document.createElement("div");
        prev.setAttribute("id", `prev${epubId}`);
        next.setAttribute("id", `next${epubId}`);
        prev.textContent = "<PREV";
        next.textContent = "NEXT>";
        prev.style = "float: left; left: 0; margin: 5px 5px; cursor: pointer;\
                      user-select: none;\
                      -webkit-user-select: none;\
                      -ms-user-select: none;\
                      -webkit-touch-callout: none;\
                      -o-user-select: none;\
                      -moz-user-select: none;";
        next.style = "float: right; right: 0; margin: 5px 5px; cursor: pointer;\
                      user-select: none;\
                      -webkit-user-select: none;\
                      -ms-user-select: none;\
                      -webkit-touch-callout: none;\
                      -o-user-select: none;\
                      -moz-user-select: none;";
        prev.setAttribute("contenteditable", "false");
        next.setAttribute("contenteditable", "false");
        navButtons.appendChild(prev);
        navButtons.appendChild(next);

        element?.replaceChildren();
        const divNode = element || document.createElement("div");
        const selectToc = document.createElement("select");
        const divEbook = document.createElement("div");
        divEbook.style = "flex: top;";
        divEbook.setAttribute("class", "ebook-content");
        divEbook.setAttribute("id", strEpubId);
        selectToc.style = "float: top; left: 0; margin: 5px 5px; background: inherit; color: inherit;";
        selectToc.setAttribute("id", strTocId);
        divNode.appendChild(selectToc);

        divNode.appendChild(navButtons);

        divNode.appendChild(divEbook);
        divEbook.book = book;
        divNode.appendChild(createRemover(function() { book.destroy(); }));
        divNode.setAttribute("class", "embedded-local-epub");
        divNode.setAttribute("contenteditable", "false");
        divNode.setAttribute("data-epub", epubData);
        if (!element) editor.insertBefore(divNode, nextSibling);

        const rendition = book.renderTo(strEpubId, { flow: "scrolled",
                                                     width: "100%", height: 600, replacements: "base64" /*, allowScriptedContent: true*/ });

        const keyListener = function(e) {

          // Left Key
          if ((e.keyCode || e.which) == 37) {
            rendition?.prev();
          }

          // Right Key
          if ((e.keyCode || e.which) == 39) {
            rendition?.next();
          }
        };
        rendition?.on("keyup", keyListener);
        document.addEventListener("keyup", keyListener, false);

        prev.addEventListener("click", function(e){
          rendition?.prev();
          e.preventDefault();
        }, false);

        next.addEventListener("click", function(e){
          rendition?.next();
          e.preventDefault();
        }, false);

        const displayed = rendition?.display();
        book.loaded.navigation.then(function(toc) {

          const docfrag = document.createDocumentFragment();

          toc.forEach(function(chapter) {

            const option = document.createElement("option");
            option.textContent = chapter.label;
            option.setAttribute("ref", chapter.href);

            docfrag.appendChild(option);
          });
          selectToc.appendChild(docfrag);
          selectToc.onchange = function() {

              const index = selectToc.selectedIndex,
                    url = selectToc.options[index].getAttribute("ref");
              rendition?.display(url);

              return false;
          };
        });
        function navigatedTo(href) {

          let result = false;

          if (href) {

            const selectToc = document.getElementById(strTocId);
            const selectedOption = selectToc.querySelector("option[selected]");

            if (selectedOption) {
              selectedOption.removeAttribute("selected");
            }
            const allOptions = selectToc.querySelectorAll("option");

            for (let i = 0; i < allOptions.length; ++i) {

              let selected = allOptions[i].getAttribute("ref") === href;

              if (selected) {
                allOptions[i].setAttribute("selected", "true");
                selectToc.selectedIndex = i;
                result = true;
              }
            }
          }

          return result;
        }
        rendition?.on("rendered", function(section) {

          const current = book.navigation && book.navigation.get(section.href);
          navigatedTo(current?.href);
        });
        rendition?.on("relocated", function(location) {

          let current = book.navigation.get(location.start?.href);

          while (current?.parent) {
            current = book.navigation.get(current.parent);
          }
          navigatedTo(current?.href);
        });
      }
    }

    function insertPdf(event, element = null) {

      const file = event.target.files[0];

      if (file) {

        let reader = new FileReader();
        const nextSibling = getTopLevelNodeOfCurrentPosition(lastValidSelectionRange)?.nextSibling;
        reader.onload = async function (e) {
          await loadPdf(e.target?.result, nextSibling);
        }
        reader.readAsDataURL(file);
      }
    }

    async function loadPdf(pdfData, nextSibling, element = null) {

      if (pdfData) {

        element?.replaceChildren();
        const divNode = element || document.createElement("div");
        divNode.appendChild(createRemover());
        divNode.setAttribute("class", "embedded-local-pdf");
        divNode.setAttribute("contenteditable", "true");
        divNode.setAttribute("data-pdf", pdfData);

        let strPdfId = divNode.getAttribute("id");

        if (!strPdfId) {

          const pdfId = generateUId();
          strPdfId = `pdf${pdfId}`;
          divNode.setAttribute("id", strPdfId);
        }

        if (!element) editor.insertBefore(divNode, nextSibling);

        PDFObject.embed(pdfData, divNode, {
          height: "800px",
        });
      }
    }

    function insertText() {

      const topNode = getTopLevelNodeOfCurrentPosition();
      const p = document.createElement("p");
      p.setAttribute("class", "text-block");
      p.appendChild(document.createElement("br"));
      editor.insertBefore(p, topNode?.nextSibling);
      setCaret(p, 0);
    }

    function insertCode() {

      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");
      const pre = document.createElement("pre");
      const code = document.createElement("code");
      code.setAttribute("contenteditable", "plaintext-only");
      code.style = "white-space: pre;"
      code.innerText = "\n";
      pre.appendChild(code);
      divNode.appendChild(pre);
      divNode.setAttribute("class", "code-block");
      divNode.setAttribute("contenteditable", "true");
      editor.insertBefore(divNode, nextSibling);
      setCaret(code, 0);
    }

    function insertEmbeddedContent() {

      const iframeHtml = prompt("Embedded Page (iframe or URL)")?.trim();
      if (!iframeHtml) return;
      const nextSibling = getTopLevelNodeOfCurrentPosition()?.nextSibling;
      const divNode = document.createElement("div");

      if (iframeHtml.length < "<IFRAME".length || !iframeHtml.toUpperCase().startsWith("<IFRAME")) {
        divNode.innerHTML = `<iframe src="${iframeHtml}" allow="fullscreen" width="100%" height="400"></iframe>`;
      } else {
        divNode.innerHTML = `${iframeHtml}`;
      }
      divNode.setAttribute("class", "embedded-content");
      divNode.setAttribute("contenteditable", "true");
      editor.insertBefore(divNode, nextSibling);
      setCaret(divNode, 0);
    }

    // Toggle dropdown visibility
    function toggleDropdown(id) {
      const dropdown = document.getElementById(id);
      if (dropdown.classList.contains('show')) {
        dropdown.classList.remove('show');
      } else {
        // Close any open dropdowns first
        document.querySelectorAll('.dropdown-content').forEach(el => el.classList.remove('show'));
        dropdown.classList.add('show');
      }
    }

    // Close dropdowns if clicking outside
    document.addEventListener('click', function (e) {
      if (!e.target.closest('.dropdown')) {
        document.querySelectorAll('.dropdown-content').forEach(el => el.classList.remove('show'));
      }
    });

    // Helper: Place the caret at a given element and offset.
    function setCaret(el, pos) {
      const selection = window.getSelection();
      const range = document.createRange();
      range.setStart(el, pos);
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    // Wrap only the selected portions of text nodes.
    // If selection is entirely within one text node, process it directly.
    function wrapRangeText(range, tagName, style, hook) {

      const textNodes = [];
      if (range.commonAncestorContainer.nodeType === Node.TEXT_NODE) {
        textNodes.push(range.commonAncestorContainer);
      } else {
        const walker = document.createTreeWalker(
          range.commonAncestorContainer,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode: function (node) {

              let isRejectableTag = false;
              let nd = node;

              while (nd && nd.parentNode !== editor) {
                if (NON_STYLABLE_NODE_NAMES.includes(nd.nodeName)) {
                  isRejectableTag = true;
                  break;
                }
                nd = nd.parentNode;
              }

              if (nd && NON_STYLABLE_NODE_NAMES.includes(nd.nodeName)) isRejectableTag = true;

              return !isRejectableTag && range.intersectsNode(node)
                ? NodeFilter.FILTER_ACCEPT
                : NodeFilter.FILTER_REJECT;
            }
          }
        );
        let node;
        while (node = walker.nextNode()) {
          textNodes.push(node);
        }
      }

      textNodes.forEach(function (textNode) {
        let start = 0, end = textNode.textContent.length;
        if (textNode === range.startContainer) {
          start = range.startOffset;
        }
        if (textNode === range.endContainer) {
          end = range.endOffset;
        }
        if (start >= end) return;

        const parent = textNode.parentNode;
        const wrapper = document.createElement(tagName);
        if (style) {
          wrapper.style.cssText = style;
        }
        if (hook) {
          hook(wrapper);
        }
        wrapper.textContent = textNode.textContent.substring(start, end);

        const frag = document.createDocumentFragment();
        const beforeText = textNode.textContent.substring(0, start);
        const afterText = textNode.textContent.substring(end);
        if (beforeText) {
          frag.appendChild(document.createTextNode(beforeText));
        }
        frag.appendChild(wrapper);
        if (afterText) {
          frag.appendChild(document.createTextNode(afterText));
        }
        parent.replaceChild(frag, textNode);
      });
    }

    // Basic inline formatting: wraps the selection in the specified tag.
    function applyFormat(tagName) {
      const selection = window.getSelection();
      if (!selection.rangeCount || selection.isCollapsed) return;
      const range = selection.getRangeAt(0);
      const editor = document.getElementById('editor');
      if (!editor.contains(range.commonAncestorContainer)) return;
      wrapRangeText(range, tagName);
      selection.removeAllRanges();
    }

    // Apply inline style (e.g., font-size, text color, background color) by wrapping the selection in a <span>.
    function applyStyle(styleString) {
      const selection = window.getSelection();
      if (!selection.rangeCount || selection.isCollapsed) return;
      const range = selection.getRangeAt(0);
      const editor = document.getElementById('editor');
      if (!editor.contains(range.commonAncestorContainer)) return;
      wrapRangeText(range, 'span', styleString);
      selection.removeAllRanges();
    }

    // Apply inline url 
    function applyURL() {
      const selection = window.getSelection();
      if (!selection.rangeCount || selection.isCollapsed) return;
      const range = selection.getRangeAt(0);
      const editor = document.getElementById('editor');
      if (!editor.contains(range.commonAncestorContainer)) return;
      const url = prompt("URL")?.trim();
      if (!url) return;
      wrapRangeText(range, 'a', null, function (element) {
        element.href = url;
      });
      selection.removeAllRanges();
    }

    // Called by the text size dropdown.
    function applyTextSize(size) {
      if (!size) return;
      applyStyle("font-size: " + size + ";");
    }

    // Called when a text color swatch is clicked.
    function applyTextColor(color) {
      if (!color) return;
      applyStyle("color: var(--note-text-color-" + color + ");");
    }

    // Called when a highlight (background color) swatch is clicked.
    function applyHighlightColor(color) {
      if (!color) return;
      applyStyle("background-color: var(--note-highlight-color-" + color + ");");
    }

    // Convert the current block (direct child of #editor) to the chosen tag.
    function changeBlock(tag) {
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      let node = selection.anchorNode;
      const editor = document.getElementById('editor');
      while (node && node.parentNode !== editor) {
        if (NON_STYLABLE_NODE_NAMES.includes(node.nodeName)) return;
        node = node.parentNode;
      }
      if (!node || node === editor) return;
      if (NON_STYLABLE_NODE_NAMES.includes(node.nodeName)) return;
      const newBlock = document.createElement(tag);
      while (node.firstChild) {
        if (
          node.firstChild.nodeType === Node.ELEMENT_NODE &&
          node.firstChild.matches('p') &&
          tag.match(/^H[1-6]$/)
        ) {
          let child = node.firstChild;
          while (child.firstChild) {
            newBlock.appendChild(child.firstChild);
          }
          node.removeChild(child);
        } else {
          newBlock.appendChild(node.firstChild);
        }
      }
      editor.replaceChild(newBlock, node);
      const range = document.createRange();
      range.selectNodeContents(newBlock);
      range.collapse(false);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    // Splits the current block at the caret.
    function splitBlock() {
      const editor = document.getElementById('editor');
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      const range = selection.getRangeAt(0);

      let block = range.startContainer;
      while (block && block.parentNode !== editor) {
        block = block.parentNode;
      }
      if (!block) {
        const p = document.createElement('p');
        p.innerHTML = '<br>';
        editor.appendChild(p);
        setCaret(p, 0);
        return;
      }

      const afterRange = range.cloneRange();
      afterRange.setStart(range.endContainer, range.endOffset);
      afterRange.setEndAfter(block.lastChild || block);
      const afterContent = afterRange.cloneContents();

      const isAtEnd = !Array.from(afterContent.childNodes).some(n => {
        return (n.nodeType === Node.ELEMENT_NODE) ||
          (n.nodeType === Node.TEXT_NODE && n.textContent.trim());
      });

      if (isAtEnd) {
        const newBlock = document.createElement('p');
        newBlock.innerHTML = '<br>';
        if (block.nextSibling) {
          editor.insertBefore(newBlock, block.nextSibling);
        } else {
          editor.appendChild(newBlock);
        }
        setCaret(newBlock, 0);
      } else {
        const newBlock = document.createElement('p');
        const extractRange = range.cloneRange();
        extractRange.setEndAfter(block.lastChild || block);
        const extracted = extractRange.extractContents();
        if (!extracted.childNodes.length) {
          newBlock.innerHTML = '<br>';
        } else {
          newBlock.appendChild(extracted);
        }
        if (block.nextSibling) {
          editor.insertBefore(newBlock, block.nextSibling);
        } else {
          editor.appendChild(newBlock);
        }
        setCaret(newBlock, 0);
      }

      if (!block.textContent.trim() && !block.querySelector('img, video, iframe, embed, object')) {
        block.innerHTML = '<br>';
      }
    }

    // Normalize stray text nodes and nested blocks.
    function normalizeEditor() {
      const editor = document.getElementById('editor');
      Array.from(editor.childNodes).forEach(node => {
        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
          const p = document.createElement('p');
          p.textContent = node.textContent;
          editor.replaceChild(p, node);
        }
      });
      editor.querySelectorAll('p p, h1 p, h2 p, h3 p, h4 p, h5 p, h6 p, p font, small p').forEach(nested => {
        const parent = nested.parentNode;
        while (nested.firstChild) {
          parent.insertBefore(nested.firstChild, nested);
        }
        parent.removeChild(nested);
      });
    }

    // Normalize stray text nodes and nested blocks.
    function cleanEditor() {
      const editor = document.getElementById('editor');
      if (editor.firstChild && ["H1", "H2", "H3", "H4", "H5", "H6", "P"].includes(editor.firstChild.nodeName)) {
        return;
      }
      if (editor.innerHTML.trim() === "" || editor.innerHTML.trim() === "<br>") {
        editor.innerHTML = "<p></p>";
      }
    }

    function updateTitle() {
      let filename = document.getElementById("filename");
      if (filename.innerHTML === "<br>") {
        filename.innerHTML = "";
      }
      document.title = filename.innerHTML.trim() || "Nash Note";
    }

    /*function printSelectionInfo() {
      const selection = window.getSelection();
      console.log("selection: ", selection);

      if (selection?.rangeCount) {
        const range = selection.getRangeAt(0);
        console.log("range: ", range);
      }
    }*/

    function keydownHandler(e) {

      if (e.key === 'Enter' && !e.shiftKey) {

        const selection = window.getSelection();

        if (selection.rangeCount) {

          const range = selection.getRangeAt(0);
          let block = range.startContainer;

          while (block && block !== editor) {

            if (block.nodeType === Node.ELEMENT_NODE && block.nodeName === "CODE") {

              const textNode = range.startContainer;

              if (textNode.nodeName === "CODE") {

                //printSelectionInfo();

                if (textNode.childNodes.length > range.startOffset) {
                  textNode.insertBefore(document.createElement("br"), textNode.childNodes[range.startOffset]);
                } else {
                  textNode.appendChild(document.createElement("br"));
                }
                setCaret(textNode, range.startOffset + 1);
              } else if (textNode.nodeName === "BR") {

                //printSelectionInfo();
                const brNode = document.createElement("br");
                textNode.parentNode.insertBefore(brNode, textNode.nextSibling);
                setCaret(brNode, 0);
              } else if (textNode.nodeType === Node.TEXT_NODE && textNode.nodeName == "#text") {

                //printSelectionInfo();
                const text1 = textNode.textContent.substring(0, range.startOffset);
                const text2 = textNode.textContent.substring(range.startOffset);
                const newTextNode = (text2 && text2 !== "") ? document.createTextNode(text2) : null;
                const parentNode = textNode.parentNode;
                const nextSibling = textNode.nextSibling;
                const brNode = document.createElement("br");
                parentNode.insertBefore(brNode, nextSibling);

                if (text1 && text1 !== "") {

                  if (textNode.textContent !== text1) {
                    textNode.textContent = text1;
                  }
                } else {
                  parentNode.removeChild(textNode);
                }

                if (newTextNode) {

                  parentNode.insertBefore(newTextNode, nextSibling);
                  setCaret(newTextNode, 0);
                } else if (text1 && text1 !== "") {

                  if (!nextSibling) {

                    const brNode2 = document.createElement("br");
                    parentNode.insertBefore(brNode2, nextSibling);
                    setCaret(parentNode, [...parentNode.childNodes].indexOf(brNode2));
                  } else {
                    setCaret(parentNode, [...parentNode.childNodes].indexOf(nextSibling));
                  }
                } else {

                  const brNode2 = document.createElement("br");
                  parentNode.insertBefore(brNode2, nextSibling);
                  setCaret(brNode2, 0);
                }
              }
              e.stopImmediatePropagation();
              e.preventDefault();
              return;
            }
            block = block.parentNode;
          }
        }
        e.preventDefault();
        splitBlock();
      }

      if ((e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'y')) {
        e.preventDefault();
      }
    }

    function clickHandler(e) {
      const target = e.target.closest("a");
      if (!target || !document.getElementById("editorContainer").contains(target)) return;

      e.preventDefault();

      const userConfirmed = confirm(`"${target.href}" open this url?`);
      if (userConfirmed) {
        window.open(target.href, "_blank");
      }
    }

    function unloadHandler(e) {
      if (document.getElementById("editor").contentEditable !== "true") {
        return;
      }
      e.preventDefault()
      e.returnValue = '';
    }

    let lastValidSelectionRange = null;

    document.onselectionchange = () => {
      const selection = document.getSelection();

      if (selection?.rangeCount) {

        const range = selection.getRangeAt(0);

        if (editor.contains(range.startContainer)) {
          lastValidSelectionRange = range;
        }
      }
    };

    let editor = document.getElementById('editor');
    let filename = document.getElementById('filename');

    editor.addEventListener('keydown', keydownHandler);
    editor.addEventListener('click', clickHandler);
    editor.addEventListener('blur', normalizeEditor);
    editor.addEventListener("input", cleanEditor);
    editor.addEventListener("focus", cleanEditor);

    filename.addEventListener("input", updateTitle);

    window.addEventListener("beforeunload", unloadHandler);

    loadAllReferencedDocuments();

    updateTitle();

    /* Event handlers */

    document.getElementById("btnH1").addEventListener("click", (e) => changeBlock("h1"));
    document.getElementById("btnH2").addEventListener("click", (e) => changeBlock("h2"));
    document.getElementById("btnM").addEventListener("click", (e) => changeBlock("p"));
    document.getElementById("btnS").addEventListener("click", (e) => changeBlock("small"));

    document.getElementById("btnB").addEventListener("click", (e) => applyFormat("strong"));
    document.getElementById("btnI").addEventListener("click", (e) => applyFormat("em"));
    document.getElementById("btnU").addEventListener("click", (e) => applyFormat("u"));
    document.getElementById("btnLink").addEventListener("click", (e) => applyURL());

    document.getElementById("imageUpload").addEventListener("change", (e) => insertImage(e));
    document.getElementById("btnImageLink").addEventListener("click", (e) => insertImageLink());

    document.getElementById("btnTextColorMenu").addEventListener("click", (e) => toggleDropdown("textColorDropdown"));
    
    for (let i = 1; i < 9; ++i) {
      document.getElementById(`btnTextColor${i}`).addEventListener("click", (e) => {
        applyTextColor(`${i}`);
        toggleDropdown("textColorDropdown");
      });
    }

    document.getElementById("btnTextHighlightMenu").addEventListener("click", (e) => toggleDropdown("highlightDropdown"));
    
    for (let i = 1; i < 9; ++i) {
      document.getElementById(`btnTextHighlight${i}`).addEventListener("click", (e) => {
        applyHighlightColor(`${i}`);
        toggleDropdown("highlightDropdown");
      });
    }

    document.getElementById("btnText").addEventListener("click", (e) => insertText());
    document.getElementById("btnCode").addEventListener("click", (e) => insertCode());
    document.getElementById("btnEmbedContent").addEventListener("click", (e) => insertEmbeddedContent());

    document.getElementById("audioUpload").addEventListener("change", (e) => insertAudio(event));

    document.getElementById("btnAudioLink").addEventListener("click", (e) => insertAudioLink());
    document.getElementById("btnVideoLink").addEventListener("click", (e) => insertVideoLink());

    document.getElementById("epubUpload").addEventListener("change", (e) => insertEpub(e));
    document.getElementById("pdfUpload").addEventListener("change", (e) => insertPdf(e));

    document.getElementById("btnSaveMenu").addEventListener("click", (e) => toggleDropdown("saveDropdown"));
    document.getElementById("btnSave").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(true, true);
    });
    document.getElementById("btnShare").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(false, true);
    });
    document.getElementById("btnSaveReadOnly").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(true, false);
    });
    document.getElementById("btnShareReadOnly").addEventListener("click", (e) => {
      toggleDropdown("saveDropdown");
      exportToFile(false, false);
    });
  </script>

</body>

</html>